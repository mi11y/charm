# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `datadog` gem.
# Please instead update this file by running `bin/tapioca gem datadog`.


# NOTE: This code is copied directly from Redis.
#       Its purpose is to resolve connection information.
#       It exists here only because it doesn't exist in the redis
#       library as a separated module and it allows to avoid
#       instantiating a new Redis::Client for resolving the connection
#
# source://datadog//lib/datadog/core/deprecations.rb#3
module Datadog
  extend ::Datadog::Core::Extensions
  extend ::Datadog::Core::Configuration
  extend ::Datadog::Tracing::Contrib::Extensions::Helpers
  extend ::Datadog::Tracing::Contrib::Extensions::Configuration
end

# Namespace for Datadog AppSec instrumentation
#
# source://datadog//lib/datadog/appsec/assets.rb#6
module Datadog::AppSec
  class << self
    # source://datadog//lib/datadog/appsec.rb#21
    def active_context; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec.rb#13
    def enabled?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec.rb#37
    def perform_api_security_check?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec.rb#17
    def rasp_enabled?; end

    # source://datadog//lib/datadog/appsec.rb#33
    def reconfigure!; end

    # source://datadog//lib/datadog/appsec.rb#29
    def security_engine; end

    # source://datadog//lib/datadog/appsec.rb#25
    def telemetry; end

    private

    # source://datadog//lib/datadog/appsec.rb#44
    def components; end
  end
end

# A namespace for API Security features.
#
# source://datadog//lib/datadog/appsec/api_security/lru_cache.rb#7
module Datadog::AppSec::APISecurity
  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/api_security.rb#9
    def enabled?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/api_security.rb#13
    def sample?(request, response); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/api_security.rb#17
    def sample_trace?(trace); end
  end
end

# source://datadog//lib/datadog/appsec/api_security/endpoint_collection/rails_route_serializer.rb#6
module Datadog::AppSec::APISecurity::EndpointCollection; end

# This module serializes Grape routes.
#
# source://datadog//lib/datadog/appsec/api_security/endpoint_collection/grape_route_serializer.rb#8
module Datadog::AppSec::APISecurity::EndpointCollection::GrapeRouteSerializer
  private

  # source://datadog//lib/datadog/appsec/api_security/endpoint_collection/grape_route_serializer.rb#11
  def serialize(route, path_prefix: T.unsafe(nil)); end

  class << self
    # source://datadog//lib/datadog/appsec/api_security/endpoint_collection/grape_route_serializer.rb#11
    def serialize(route, path_prefix: T.unsafe(nil)); end
  end
end

# This class works with a collection of rails routes
# and produces an Enumerator that yields serialized endpoints.
#
# source://datadog//lib/datadog/appsec/api_security/endpoint_collection/rails_collector.rb#13
class Datadog::AppSec::APISecurity::EndpointCollection::RailsCollector
  # @return [RailsCollector] a new instance of RailsCollector
  #
  # source://datadog//lib/datadog/appsec/api_security/endpoint_collection/rails_collector.rb#14
  def initialize(routes); end

  # source://datadog//lib/datadog/appsec/api_security/endpoint_collection/rails_collector.rb#18
  def to_enum; end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/api_security/endpoint_collection/rails_collector.rb#44
  def mounted_grape_app?(rack_app); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/api_security/endpoint_collection/rails_collector.rb#50
  def mounted_sinatra_app?(rack_app); end
end

# This module serializes Rails Journey Router routes.
#
# source://datadog//lib/datadog/appsec/api_security/endpoint_collection/rails_route_serializer.rb#8
module Datadog::AppSec::APISecurity::EndpointCollection::RailsRouteSerializer
  private

  # source://datadog//lib/datadog/appsec/api_security/endpoint_collection/rails_route_serializer.rb#13
  def serialize(route); end

  class << self
    # source://datadog//lib/datadog/appsec/api_security/endpoint_collection/rails_route_serializer.rb#13
    def serialize(route); end
  end
end

# source://datadog//lib/datadog/appsec/api_security/endpoint_collection/rails_route_serializer.rb#9
Datadog::AppSec::APISecurity::EndpointCollection::RailsRouteSerializer::FORMAT_SUFFIX = T.let(T.unsafe(nil), String)

# This module serializes Sinatra routes.
#
# source://datadog//lib/datadog/appsec/api_security/endpoint_collection/sinatra_route_serializer.rb#8
module Datadog::AppSec::APISecurity::EndpointCollection::SinatraRouteSerializer
  private

  # source://datadog//lib/datadog/appsec/api_security/endpoint_collection/sinatra_route_serializer.rb#11
  def serialize(route, method:, path_prefix: T.unsafe(nil)); end

  class << self
    # source://datadog//lib/datadog/appsec/api_security/endpoint_collection/sinatra_route_serializer.rb#11
    def serialize(route, method:, path_prefix: T.unsafe(nil)); end
  end
end

# An LRU (Least Recently Used) cache implementation that relies on the
# Ruby 1.9+ `Hash` implementation that guarantees insertion order.
#
# WARNING: This implementation is NOT thread-safe and should be used
#          in a single-threaded context.
#
# source://datadog//lib/datadog/appsec/api_security/lru_cache.rb#13
class Datadog::AppSec::APISecurity::LRUCache
  extend ::Forwardable

  # @raise [ArgumentError]
  # @return [LRUCache] a new instance of LRUCache
  #
  # source://datadog//lib/datadog/appsec/api_security/lru_cache.rb#18
  def initialize(max_size); end

  # NOTE: Accessing a key moves it to the end of the list.
  #
  # source://datadog//lib/datadog/appsec/api_security/lru_cache.rb#27
  def [](key); end

  # source://datadog//lib/datadog/appsec/api_security/lru_cache.rb#16
  def clear(*args, **_arg1, &block); end

  # source://datadog//lib/datadog/appsec/api_security/lru_cache.rb#16
  def empty?(*args, **_arg1, &block); end

  # NOTE: If the key exists, it's moved to the end of the list and
  #       if does not, the given block will be executed and the result
  #       will be stored (which will add it to the end of the list).
  #
  # source://datadog//lib/datadog/appsec/api_security/lru_cache.rb#44
  def fetch_or_store(key); end

  # source://datadog//lib/datadog/appsec/api_security/lru_cache.rb#33
  def store(key, value); end
end

# This is a helper module to extract the route pattern from the Rack::Request.
#
# source://datadog//lib/datadog/appsec/api_security/route_extractor.rb#7
module Datadog::AppSec::APISecurity::RouteExtractor
  class << self
    # HACK: We rely on the fact that each contrib will modify `request.env`
    #       and store information sufficient to compute the canonical
    #       route (ex: `/users/:id`).
    #
    #       When contribs like Sinatra or Grape are used, they could be mounted
    #       into the Rails app, hence you can see the use of the `script_name`
    #       that will contain the path prefix of the mounted app.
    #
    #       Rack
    #         does not support named arguments, so we have to use `path`
    #       Sinatra
    #         uses `sinatra.route` with a string like "GET /users/:id"
    #       Grape
    #         uses `grape.routing_args` with a hash with a `:route_info` key
    #         that contains a `Grape::Router::Route` object that contains
    #         `Grape::Router::Pattern` object with an `origin` method
    #       Rails < 7.1 (slow path)
    #         uses `action_dispatch.routes` to store `ActionDispatch::Routing::RouteSet`
    #         which can recognize requests
    #       Rails > 7.1 (fast path)
    #         uses `action_dispatch.route_uri_pattern` with a string like
    #         "/users/:id(.:format)"
    #
    # WARNING: This method works only *after* the request has been routed.
    #
    # WARNING: In Rails > 7.1 when a route was not found,
    #          `action_dispatch.route_uri_pattern` will not be set.
    #          In Rails < 7.1 it also will not be set even if a route was found,
    #          but in this case `action_dispatch.request.path_parameters` won't be empty.
    #
    # source://datadog//lib/datadog/appsec/api_security/route_extractor.rb#45
    def route_pattern(request); end
  end
end

# source://datadog//lib/datadog/appsec/api_security/route_extractor.rb#10
Datadog::AppSec::APISecurity::RouteExtractor::GRAPE_ROUTE_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/api_security/route_extractor.rb#14
Datadog::AppSec::APISecurity::RouteExtractor::RAILS_FORMAT_SUFFIX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/api_security/route_extractor.rb#13
Datadog::AppSec::APISecurity::RouteExtractor::RAILS_PATH_PARAMS_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/api_security/route_extractor.rb#12
Datadog::AppSec::APISecurity::RouteExtractor::RAILS_ROUTES_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/api_security/route_extractor.rb#11
Datadog::AppSec::APISecurity::RouteExtractor::RAILS_ROUTE_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/api_security/route_extractor.rb#8
Datadog::AppSec::APISecurity::RouteExtractor::SINATRA_ROUTE_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/api_security/route_extractor.rb#9
Datadog::AppSec::APISecurity::RouteExtractor::SINATRA_ROUTE_SEPARATOR = T.let(T.unsafe(nil), String)

# A thread-local sampler for API security based on defined delay between
# samples with caching capability.
#
# source://datadog//lib/datadog/appsec/api_security/sampler.rb#13
class Datadog::AppSec::APISecurity::Sampler
  # @raise [ArgumentError]
  # @return [Sampler] a new instance of Sampler
  #
  # source://datadog//lib/datadog/appsec/api_security/sampler.rb#37
  def initialize(sample_delay); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/api_security/sampler.rb#44
  def sample?(request, response); end

  class << self
    # @api private
    #
    # source://datadog//lib/datadog/appsec/api_security/sampler.rb#26
    def reset!; end

    # source://datadog//lib/datadog/appsec/api_security/sampler.rb#18
    def thread_local; end

    private

    # source://datadog//lib/datadog/appsec/api_security/sampler.rb#32
    def sample_delay; end
  end
end

# source://datadog//lib/datadog/appsec/api_security/sampler.rb#15
Datadog::AppSec::APISecurity::Sampler::MAX_CACHE_SIZE = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/appsec/api_security/sampler.rb#14
Datadog::AppSec::APISecurity::Sampler::THREAD_KEY = T.let(T.unsafe(nil), Symbol)

# this module encapsulates functions for handling actions that libddawf returns
#
# source://datadog//lib/datadog/appsec/actions_handler/serializable_backtrace.rb#5
module Datadog::AppSec::ActionsHandler
  private

  # source://datadog//lib/datadog/appsec/actions_handler.rb#45
  def generate_schema(_action_params); end

  # source://datadog//lib/datadog/appsec/actions_handler.rb#24
  def generate_stack(action_params); end

  # source://datadog//lib/datadog/appsec/actions_handler.rb#11
  def handle(actions_hash); end

  # source://datadog//lib/datadog/appsec/actions_handler.rb#20
  def interrupt_execution(action_params); end

  class << self
    # source://datadog//lib/datadog/appsec/actions_handler.rb#45
    def generate_schema(_action_params); end

    # source://datadog//lib/datadog/appsec/actions_handler.rb#24
    def generate_stack(action_params); end

    # source://datadog//lib/datadog/appsec/actions_handler.rb#11
    def handle(actions_hash); end

    # source://datadog//lib/datadog/appsec/actions_handler.rb#20
    def interrupt_execution(action_params); end
  end
end

# This module serves encapsulates MessagePack serialization for caller locations.
#
# It serializes part of the stack:
# up to 32 frames (configurable)
# keeping frames from top and bottom of the stack (75% to 25%, configurable).
#
# It represents the stack trace that is added to span metastruct field.
#
# source://datadog//lib/datadog/appsec/actions_handler/serializable_backtrace.rb#13
class Datadog::AppSec::ActionsHandler::SerializableBacktrace
  # @return [SerializableBacktrace] a new instance of SerializableBacktrace
  #
  # source://datadog//lib/datadog/appsec/actions_handler/serializable_backtrace.rb#16
  def initialize(locations:, stack_id:); end

  # source://datadog//lib/datadog/appsec/actions_handler/serializable_backtrace.rb#21
  def to_msgpack(packer = T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/appsec/actions_handler/serializable_backtrace.rb#67
  def build_serializable_locations_map; end
end

# source://datadog//lib/datadog/appsec/actions_handler/serializable_backtrace.rb#14
Datadog::AppSec::ActionsHandler::SerializableBacktrace::CLASS_AND_FUNCTION_NAME_REGEX = T.let(T.unsafe(nil), Regexp)

# Manual anonymization of the potential PII data
#
# source://datadog//lib/datadog/appsec/anonymizer.rb#8
module Datadog::AppSec::Anonymizer
  class << self
    # @raise [ArgumentError]
    #
    # source://datadog//lib/datadog/appsec/anonymizer.rb#9
    def anonymize(payload); end
  end
end

# Helper methods to get vendored assets
#
# source://datadog//lib/datadog/appsec/assets.rb#8
module Datadog::AppSec::Assets
  private

  # source://datadog//lib/datadog/appsec/assets.rb#23
  def blocked(format: T.unsafe(nil)); end

  # source://datadog//lib/datadog/appsec/assets.rb#39
  def dir; end

  # source://datadog//lib/datadog/appsec/assets.rb#31
  def filepath(filename); end

  # source://datadog//lib/datadog/appsec/assets.rb#27
  def path; end

  # source://datadog//lib/datadog/appsec/assets.rb#35
  def read(filename, mode = T.unsafe(nil)); end

  # source://datadog//lib/datadog/appsec/assets.rb#15
  def waf_processors; end

  # source://datadog//lib/datadog/appsec/assets.rb#11
  def waf_rules(kind = T.unsafe(nil)); end

  # source://datadog//lib/datadog/appsec/assets.rb#19
  def waf_scanners; end

  class << self
    # source://datadog//lib/datadog/appsec/assets.rb#23
    def blocked(format: T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/assets.rb#39
    def dir; end

    # source://datadog//lib/datadog/appsec/assets.rb#31
    def filepath(filename); end

    # source://datadog//lib/datadog/appsec/assets.rb#27
    def path; end

    # source://datadog//lib/datadog/appsec/assets.rb#35
    def read(filename, mode = T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/assets.rb#15
    def waf_processors; end

    # source://datadog//lib/datadog/appsec/assets.rb#11
    def waf_rules(kind = T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/assets.rb#19
    def waf_scanners; end
  end
end

# Core-pluggable component for AppSec
#
# source://datadog//lib/datadog/appsec/component.rb#12
class Datadog::AppSec::Component
  # @return [Component] a new instance of Component
  #
  # source://datadog//lib/datadog/appsec/component.rb#75
  def initialize(security_engine:, telemetry:); end

  # source://datadog//lib/datadog/appsec/component.rb#80
  def reconfigure!; end

  # Returns the value of attribute security_engine.
  #
  # source://datadog//lib/datadog/appsec/component.rb#73
  def security_engine; end

  # source://datadog//lib/datadog/appsec/component.rb#84
  def shutdown!; end

  # Returns the value of attribute telemetry.
  #
  # source://datadog//lib/datadog/appsec/component.rb#73
  def telemetry; end

  class << self
    # source://datadog//lib/datadog/appsec/component.rb#14
    def build_appsec_component(settings, telemetry:); end

    private

    # source://datadog//lib/datadog/appsec/component.rb#57
    def require_libddwaf(telemetry:); end
  end
end

# Converts complex schema payloads into JSON and compresses them into a
# base64 encoded string if the payload is worth compressing.
#
# See: https://github.com/DataDog/dd-trace-rb/pull/3177#issuecomment-1747221082
#
# source://datadog//lib/datadog/appsec/compressed_json.rb#15
module Datadog::AppSec::CompressedJson
  class << self
    # source://datadog//lib/datadog/appsec/compressed_json.rb#18
    def dump(payload); end

    private

    # source://datadog//lib/datadog/appsec/compressed_json.rb#29
    def compress_and_encode(payload); end
  end
end

# source://datadog//lib/datadog/appsec/compressed_json.rb#16
Datadog::AppSec::CompressedJson::MIN_SIZE_FOR_COMPRESSION = T.let(T.unsafe(nil), Integer)

# Configuration for AppSec
#
# source://datadog//lib/datadog/appsec/configuration/settings.rb#8
module Datadog::AppSec::Configuration; end

# Settings
#
# source://datadog//lib/datadog/appsec/configuration/settings.rb#10
module Datadog::AppSec::Configuration::Settings
  class << self
    # source://datadog//lib/datadog/appsec/configuration/settings.rb#45
    def add_settings!(base); end

    # @private
    #
    # source://datadog//lib/datadog/appsec/configuration/settings.rb#39
    def extended(base); end
  end
end

# source://datadog//lib/datadog/appsec/configuration/settings.rb#17
Datadog::AppSec::Configuration::Settings::ANONYMIZATION_AUTO_USER_INSTRUMENTATION_MODE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/configuration/settings.rb#35
Datadog::AppSec::Configuration::Settings::APPSEC_VALID_TRACK_USER_EVENTS_ENABLED_VALUES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/configuration/settings.rb#32
Datadog::AppSec::Configuration::Settings::APPSEC_VALID_TRACK_USER_EVENTS_MODE = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/configuration/settings.rb#19
Datadog::AppSec::Configuration::Settings::AUTO_USER_INSTRUMENTATION_MODES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/configuration/settings.rb#24
Datadog::AppSec::Configuration::Settings::AUTO_USER_INSTRUMENTATION_MODES_ALIASES = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/appsec/configuration/settings.rb#12
Datadog::AppSec::Configuration::Settings::DEFAULT_OBFUSCATOR_KEY_REGEX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/configuration/settings.rb#13
Datadog::AppSec::Configuration::Settings::DEFAULT_OBFUSCATOR_VALUE_REGEX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/configuration/settings.rb#16
Datadog::AppSec::Configuration::Settings::DISABLED_AUTO_USER_INSTRUMENTATION_MODE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/configuration/settings.rb#31
Datadog::AppSec::Configuration::Settings::EXTENDED_TRACK_USER_EVENTS_MODE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/configuration/settings.rb#18
Datadog::AppSec::Configuration::Settings::IDENTIFICATION_AUTO_USER_INSTRUMENTATION_MODE = T.let(T.unsafe(nil), String)

# NOTE: These two constants are deprecated
#
# source://datadog//lib/datadog/appsec/configuration/settings.rb#30
Datadog::AppSec::Configuration::Settings::SAFE_TRACK_USER_EVENTS_MODE = T.let(T.unsafe(nil), String)

# This class accumulates the context over the request life-cycle and exposes
# interface sufficient for instrumentation to perform threat detection.
#
# source://datadog//lib/datadog/appsec/context.rb#9
class Datadog::AppSec::Context
  # @return [Context] a new instance of Context
  #
  # source://datadog//lib/datadog/appsec/context.rb#34
  def initialize(trace, span, waf_runner); end

  # TODO: add delegators for active trace span
  #
  # source://datadog//lib/datadog/appsec/context.rb#13
  def events; end

  # source://datadog//lib/datadog/appsec/context.rb#79
  def export_metrics; end

  # source://datadog//lib/datadog/appsec/context.rb#86
  def export_request_telemetry; end

  # source://datadog//lib/datadog/appsec/context.rb#75
  def extract_schema; end

  # source://datadog//lib/datadog/appsec/context.rb#92
  def finalize!; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/context.rb#63
  def interrupted?; end

  # source://datadog//lib/datadog/appsec/context.rb#59
  def mark_as_interrupted!; end

  # source://datadog//lib/datadog/appsec/context.rb#50
  def run_rasp(type, persistent_data, ephemeral_data, timeout = T.unsafe(nil)); end

  # source://datadog//lib/datadog/appsec/context.rb#43
  def run_waf(persistent_data, ephemeral_data, timeout = T.unsafe(nil)); end

  # TODO: add delegators for active trace span
  #
  # source://datadog//lib/datadog/appsec/context.rb#13
  def span; end

  # TODO: add delegators for active trace span
  #
  # source://datadog//lib/datadog/appsec/context.rb#13
  def trace; end

  # source://datadog//lib/datadog/appsec/context.rb#71
  def waf_runner_known_addresses; end

  # source://datadog//lib/datadog/appsec/context.rb#67
  def waf_runner_ruleset_version; end

  class << self
    # @raise [ArgumentError]
    #
    # source://datadog//lib/datadog/appsec/context.rb#16
    def activate(context); end

    # source://datadog//lib/datadog/appsec/context.rb#29
    def active; end

    # source://datadog//lib/datadog/appsec/context.rb#23
    def deactivate; end
  end
end

# source://datadog//lib/datadog/appsec/context.rb#10
class Datadog::AppSec::Context::ActiveContextError < ::StandardError; end

# source://datadog//lib/datadog/appsec/contrib/integration.rb#5
module Datadog::AppSec::Contrib; end

# source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#10
module Datadog::AppSec::Contrib::ActiveRecord; end

# AppSec module that will be prepended to ActiveRecord adapter
#
# source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#12
module Datadog::AppSec::Contrib::ActiveRecord::Instrumentation
  private

  # source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#15
  def detect_sql_injection(sql, adapter_name); end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#15
    def detect_sql_injection(sql, adapter_name); end
  end
end

# patch for mysql2, sqlite3, and postgres+jdbc adapters in ActiveRecord < 7.1
#
# source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#56
module Datadog::AppSec::Contrib::ActiveRecord::Instrumentation::ExecQueryAdapterPatch
  # source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#57
  def exec_query(sql, *args, **rest); end
end

# patch for non-jdbc postgres adapter in ActiveRecord > 4
#
# source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#74
module Datadog::AppSec::Contrib::ActiveRecord::Instrumentation::ExecuteAndClearAdapterPatch
  # source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#75
  def execute_and_clear(sql, *args, **rest); end
end

# patch for mysql2, sqlite3, and postgres+jdbc adapters in ActiveRecord >= 7.1
#
# source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#47
module Datadog::AppSec::Contrib::ActiveRecord::Instrumentation::InternalExecQueryAdapterPatch
  # source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#48
  def internal_exec_query(sql, *args, **rest); end
end

# patch for mysql2, sqlite3, and postgres+jdbc db adapters in ActiveRecord 4
#
# source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#65
module Datadog::AppSec::Contrib::ActiveRecord::Instrumentation::Rails4ExecQueryAdapterPatch
  # source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#66
  def exec_query(sql, *args); end
end

# patch for non-jdbc postgres adapter in ActiveRecord 4
#
# source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#83
module Datadog::AppSec::Contrib::ActiveRecord::Instrumentation::Rails4ExecuteAndClearAdapterPatch
  # source://datadog//lib/datadog/appsec/contrib/active_record/instrumentation.rb#84
  def execute_and_clear(sql, name, binds); end
end

# This class provides helper methods that are used when patching ActiveRecord
#
# source://datadog//lib/datadog/appsec/contrib/active_record/integration.rb#11
class Datadog::AppSec::Contrib::ActiveRecord::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://datadog//lib/datadog/appsec/contrib/active_record/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/active_record/integration.rb#30
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/active_record/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/active_record/integration.rb#22
    def loaded?; end

    # source://datadog//lib/datadog/appsec/contrib/active_record/integration.rb#18
    def version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/active_record/integration.rb#14
Datadog::AppSec::Contrib::ActiveRecord::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# AppSec patcher module for ActiveRecord
#
# source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#10
module Datadog::AppSec::Contrib::ActiveRecord::Patcher
  private

  # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#66
  def patch_mysql2_adapter; end

  # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#78
  def patch_postgresql_adapter; end

  # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#54
  def patch_sqlite3_adapter; end

  # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#13
  def patched?; end

  # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#66
    def patch_mysql2_adapter; end

    # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#78
    def patch_postgresql_adapter; end

    # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#54
    def patch_sqlite3_adapter; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#13
    def patched?; end

    # source://datadog//lib/datadog/appsec/contrib/active_record/patcher.rb#17
    def target_version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#6
module Datadog::AppSec::Contrib::Devise; end

# A temporary configuration module to accomodate new RFC changes.
# NOTE: DEV-3 Remove module
#
# source://datadog//lib/datadog/appsec/contrib/devise/configuration.rb#9
module Datadog::AppSec::Contrib::Devise::Configuration
  private

  # NOTE: DEV-3 Replace method use with `auto_user_instrumentation.enabled?`
  #
  # source://datadog//lib/datadog/appsec/contrib/devise/configuration.rb#20
  def auto_user_instrumentation_enabled?; end

  # NOTE: DEV-3 Replace method use with `auto_user_instrumentation.mode`
  #
  # source://datadog//lib/datadog/appsec/contrib/devise/configuration.rb#32
  def auto_user_instrumentation_mode; end

  class << self
    # NOTE: DEV-3 Replace method use with `auto_user_instrumentation.enabled?`
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/devise/configuration.rb#20
    def auto_user_instrumentation_enabled?; end

    # NOTE: DEV-3 Replace method use with `auto_user_instrumentation.mode`
    #
    # source://datadog//lib/datadog/appsec/contrib/devise/configuration.rb#32
    def auto_user_instrumentation_mode; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/devise/configuration.rb#10
Datadog::AppSec::Contrib::Devise::Configuration::TRACK_USER_EVENTS_CONVERSION_RULES = T.let(T.unsafe(nil), Hash)

# Extracts user identification data from Devise resources.
# Supports both regular and anonymized data extraction modes.
#
# source://datadog//lib/datadog/appsec/contrib/devise/data_extractor.rb#11
class Datadog::AppSec::Contrib::Devise::DataExtractor
  # @return [DataExtractor] a new instance of DataExtractor
  #
  # source://datadog//lib/datadog/appsec/contrib/devise/data_extractor.rb#15
  def initialize(mode:); end

  # source://datadog//lib/datadog/appsec/contrib/devise/data_extractor.rb#20
  def extract_id(object); end

  # source://datadog//lib/datadog/appsec/contrib/devise/data_extractor.rb#40
  def extract_login(object); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/contrib/devise/data_extractor.rb#71
  def anonymize?; end

  # source://datadog//lib/datadog/appsec/contrib/devise/data_extractor.rb#57
  def find_devise_scope(object); end

  # source://datadog//lib/datadog/appsec/contrib/devise/data_extractor.rb#64
  def transform(value); end
end

# source://datadog//lib/datadog/appsec/contrib/devise/data_extractor.rb#12
Datadog::AppSec::Contrib::Devise::DataExtractor::PRIORITY_ORDERED_ID_KEYS = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/contrib/devise/data_extractor.rb#13
Datadog::AppSec::Contrib::Devise::DataExtractor::PRIORITY_ORDERED_LOGIN_KEYS = T.let(T.unsafe(nil), Array)

# Devise integration constants
#
# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#8
module Datadog::AppSec::Contrib::Devise::Ext; end

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#10
Datadog::AppSec::Contrib::Devise::Ext::EVENT_LOGIN_FAILURE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#9
Datadog::AppSec::Contrib::Devise::Ext::EVENT_LOGIN_SUCCESS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#11
Datadog::AppSec::Contrib::Devise::Ext::EVENT_SIGNUP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#16
Datadog::AppSec::Contrib::Devise::Ext::TAG_DD_COLLECTION_MODE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#18
Datadog::AppSec::Contrib::Devise::Ext::TAG_DD_LOGIN_FAILURE_MODE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#17
Datadog::AppSec::Contrib::Devise::Ext::TAG_DD_LOGIN_SUCCESS_MODE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#15
Datadog::AppSec::Contrib::Devise::Ext::TAG_DD_SIGNUP_MODE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#13
Datadog::AppSec::Contrib::Devise::Ext::TAG_DD_USR_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#14
Datadog::AppSec::Contrib::Devise::Ext::TAG_DD_USR_LOGIN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#25
Datadog::AppSec::Contrib::Devise::Ext::TAG_LOGIN_FAILURE_TRACK = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#28
Datadog::AppSec::Contrib::Devise::Ext::TAG_LOGIN_FAILURE_USR_EXISTS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#26
Datadog::AppSec::Contrib::Devise::Ext::TAG_LOGIN_FAILURE_USR_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#27
Datadog::AppSec::Contrib::Devise::Ext::TAG_LOGIN_FAILURE_USR_LOGIN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#29
Datadog::AppSec::Contrib::Devise::Ext::TAG_LOGIN_SUCCESS_TRACK = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#30
Datadog::AppSec::Contrib::Devise::Ext::TAG_LOGIN_SUCCESS_USR_LOGIN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#21
Datadog::AppSec::Contrib::Devise::Ext::TAG_SESSION_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#22
Datadog::AppSec::Contrib::Devise::Ext::TAG_SIGNUP_TRACK = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#23
Datadog::AppSec::Contrib::Devise::Ext::TAG_SIGNUP_USR_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#24
Datadog::AppSec::Contrib::Devise::Ext::TAG_SIGNUP_USR_LOGIN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/ext.rb#20
Datadog::AppSec::Contrib::Devise::Ext::TAG_USR_ID = T.let(T.unsafe(nil), String)

# Description of Devise integration
#
# source://datadog//lib/datadog/appsec/contrib/devise/integration.rb#11
class Datadog::AppSec::Contrib::Devise::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://datadog//lib/datadog/appsec/contrib/devise/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/devise/integration.rb#30
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/devise/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/devise/integration.rb#22
    def loaded?; end

    # source://datadog//lib/datadog/appsec/contrib/devise/integration.rb#18
    def version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/devise/integration.rb#14
Datadog::AppSec::Contrib::Devise::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Devise patcher
#
# source://datadog//lib/datadog/appsec/contrib/devise/patcher.rb#15
module Datadog::AppSec::Contrib::Devise::Patcher
  private

  # source://datadog//lib/datadog/appsec/contrib/devise/patcher.rb#30
  def patch; end

  # source://datadog//lib/datadog/appsec/contrib/devise/patcher.rb#22
  def patched?; end

  # source://datadog//lib/datadog/appsec/contrib/devise/patcher.rb#26
  def target_version; end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/devise/patcher.rb#30
    def patch; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/devise/patcher.rb#22
    def patched?; end

    # source://datadog//lib/datadog/appsec/contrib/devise/patcher.rb#26
    def target_version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/devise/patcher.rb#16
Datadog::AppSec::Contrib::Devise::Patcher::GUARD_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/appsec/contrib/devise/patches/signup_tracking_patch.rb#12
module Datadog::AppSec::Contrib::Devise::Patches; end

# A patch for Devise::Authenticatable strategy with tracking functionality
#
# source://datadog//lib/datadog/appsec/contrib/devise/patches/signin_tracking_patch.rb#14
module Datadog::AppSec::Contrib::Devise::Patches::SigninTrackingPatch
  # source://datadog//lib/datadog/appsec/contrib/devise/patches/signin_tracking_patch.rb#15
  def validate(resource, &block); end

  private

  # source://datadog//lib/datadog/appsec/contrib/devise/patches/signin_tracking_patch.rb#70
  def record_failed_signin(context, resource); end

  # source://datadog//lib/datadog/appsec/contrib/devise/patches/signin_tracking_patch.rb#46
  def record_successful_signin(context, resource); end
end

# A patch for Devise::RegistrationsController with tracking functionality
#
# source://datadog//lib/datadog/appsec/contrib/devise/patches/signup_tracking_patch.rb#14
module Datadog::AppSec::Contrib::Devise::Patches::SignupTrackingPatch
  # source://datadog//lib/datadog/appsec/contrib/devise/patches/signup_tracking_patch.rb#15
  def create; end

  private

  # source://datadog//lib/datadog/appsec/contrib/devise/patches/signup_tracking_patch.rb#40
  def record_successful_signup(context, resource); end
end

# To avoid tracking new sessions that are created by
# Rememberable strategy as Login Success events.
#
# source://datadog//lib/datadog/appsec/contrib/devise/patches/skip_signin_tracking_patch.rb#10
module Datadog::AppSec::Contrib::Devise::Patches::SkipSigninTrackingPatch
  # source://datadog//lib/datadog/appsec/contrib/devise/patches/skip_signin_tracking_patch.rb#11
  def validate(*args); end
end

# A Rack middleware capable of tracking currently signed user
#
# source://datadog//lib/datadog/appsec/contrib/devise/tracking_middleware.rb#11
class Datadog::AppSec::Contrib::Devise::TrackingMiddleware
  # @return [TrackingMiddleware] a new instance of TrackingMiddleware
  #
  # source://datadog//lib/datadog/appsec/contrib/devise/tracking_middleware.rb#15
  def initialize(app); end

  # source://datadog//lib/datadog/appsec/contrib/devise/tracking_middleware.rb#20
  def call(env); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/contrib/devise/tracking_middleware.rb#98
  def anonymize?; end

  # source://datadog//lib/datadog/appsec/contrib/devise/tracking_middleware.rb#66
  def extract_id(warden); end

  # source://datadog//lib/datadog/appsec/contrib/devise/tracking_middleware.rb#87
  def session_key_for(session_serializer, scope); end

  # source://datadog//lib/datadog/appsec/contrib/devise/tracking_middleware.rb#91
  def transform(value); end
end

# source://datadog//lib/datadog/appsec/contrib/devise/tracking_middleware.rb#13
Datadog::AppSec::Contrib::Devise::TrackingMiddleware::SESSION_ID_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/devise/tracking_middleware.rb#12
Datadog::AppSec::Contrib::Devise::TrackingMiddleware::WARDEN_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/contrib/excon/patcher.rb#6
module Datadog::AppSec::Contrib::Excon; end

# This class provides helper methods that are used when patching Excon
#
# source://datadog//lib/datadog/appsec/contrib/excon/integration.rb#11
class Datadog::AppSec::Contrib::Excon::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://datadog//lib/datadog/appsec/contrib/excon/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/excon/integration.rb#30
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/excon/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/excon/integration.rb#22
    def loaded?; end

    # source://datadog//lib/datadog/appsec/contrib/excon/integration.rb#18
    def version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/excon/integration.rb#14
Datadog::AppSec::Contrib::Excon::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# AppSec patcher module for Excon
#
# source://datadog//lib/datadog/appsec/contrib/excon/patcher.rb#8
module Datadog::AppSec::Contrib::Excon::Patcher
  private

  # source://datadog//lib/datadog/appsec/contrib/excon/patcher.rb#19
  def patch; end

  # source://datadog//lib/datadog/appsec/contrib/excon/patcher.rb#11
  def patched?; end

  # source://datadog//lib/datadog/appsec/contrib/excon/patcher.rb#15
  def target_version; end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/excon/patcher.rb#19
    def patch; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/excon/patcher.rb#11
    def patched?; end

    # source://datadog//lib/datadog/appsec/contrib/excon/patcher.rb#15
    def target_version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/faraday/patcher.rb#6
module Datadog::AppSec::Contrib::Faraday; end

# This class provides helper methods that are used when patching Faraday
#
# source://datadog//lib/datadog/appsec/contrib/faraday/integration.rb#12
class Datadog::AppSec::Contrib::Faraday::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://datadog//lib/datadog/appsec/contrib/faraday/integration.rb#35
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/faraday/integration.rb#31
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/faraday/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/faraday/integration.rb#23
    def loaded?; end

    # source://datadog//lib/datadog/appsec/contrib/faraday/integration.rb#19
    def version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/faraday/integration.rb#15
Datadog::AppSec::Contrib::Faraday::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher for Faraday
#
# source://datadog//lib/datadog/appsec/contrib/faraday/patcher.rb#8
module Datadog::AppSec::Contrib::Faraday::Patcher
  private

  # source://datadog//lib/datadog/appsec/contrib/faraday/patcher.rb#30
  def configure_default_faraday_connection; end

  # source://datadog//lib/datadog/appsec/contrib/faraday/patcher.rb#19
  def patch; end

  # source://datadog//lib/datadog/appsec/contrib/faraday/patcher.rb#11
  def patched?; end

  # source://datadog//lib/datadog/appsec/contrib/faraday/patcher.rb#15
  def target_version; end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/faraday/patcher.rb#30
    def configure_default_faraday_connection; end

    # source://datadog//lib/datadog/appsec/contrib/faraday/patcher.rb#19
    def patch; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/faraday/patcher.rb#11
    def patched?; end

    # source://datadog//lib/datadog/appsec/contrib/faraday/patcher.rb#15
    def target_version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/graphql/gateway/watcher.rb#13
module Datadog::AppSec::Contrib::GraphQL; end

# source://datadog//lib/datadog/appsec/contrib/graphql/gateway/watcher.rb#14
module Datadog::AppSec::Contrib::GraphQL::Gateway; end

# Watcher for Rack gateway events
#
# source://datadog//lib/datadog/appsec/contrib/graphql/gateway/watcher.rb#16
module Datadog::AppSec::Contrib::GraphQL::Gateway::Watcher
  class << self
    # source://datadog//lib/datadog/appsec/contrib/graphql/gateway/watcher.rb#18
    def watch; end

    # source://datadog//lib/datadog/appsec/contrib/graphql/gateway/watcher.rb#24
    def watch_multiplex(gateway = T.unsafe(nil)); end
  end
end

# Description of GraphQL integration
#
# source://datadog//lib/datadog/appsec/contrib/graphql/integration.rb#11
class Datadog::AppSec::Contrib::GraphQL::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://datadog//lib/datadog/appsec/contrib/graphql/integration.rb#47
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/graphql/integration.rb#41
    def ast_node_classes_defined?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/graphql/integration.rb#37
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/graphql/integration.rb#33
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/graphql/integration.rb#29
    def loaded?; end

    # source://datadog//lib/datadog/appsec/contrib/graphql/integration.rb#25
    def version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/graphql/integration.rb#16
Datadog::AppSec::Contrib::GraphQL::Integration::AST_NODE_CLASS_NAMES = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/appsec/contrib/graphql/integration.rb#14
Datadog::AppSec::Contrib::GraphQL::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher for AppSec on GraphQL
#
# source://datadog//lib/datadog/appsec/contrib/graphql/patcher.rb#14
module Datadog::AppSec::Contrib::GraphQL::Patcher
  private

  # source://datadog//lib/datadog/appsec/contrib/graphql/patcher.rb#25
  def patch; end

  # source://datadog//lib/datadog/appsec/contrib/graphql/patcher.rb#17
  def patched?; end

  # source://datadog//lib/datadog/appsec/contrib/graphql/patcher.rb#21
  def target_version; end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/graphql/patcher.rb#25
    def patch; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/graphql/patcher.rb#17
    def patched?; end

    # source://datadog//lib/datadog/appsec/contrib/graphql/patcher.rb#21
    def target_version; end
  end
end

# Base provides features that are shared across all integrations
#
# source://datadog//lib/datadog/appsec/contrib/integration.rb#7
module Datadog::AppSec::Contrib::Integration
  mixes_in_class_methods ::Datadog::AppSec::Contrib::Integration::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/appsec/contrib/integration.rb#12
    def included(base); end

    # source://datadog//lib/datadog/appsec/contrib/integration.rb#27
    def register(integration, name, options); end

    # source://datadog//lib/datadog/appsec/contrib/integration.rb#31
    def registry; end
  end
end

# Class-level methods for Integration
#
# source://datadog//lib/datadog/appsec/contrib/integration.rb#17
module Datadog::AppSec::Contrib::Integration::ClassMethods
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/contrib/integration.rb#22
  def compatible?; end

  # source://datadog//lib/datadog/appsec/contrib/integration.rb#18
  def register_as(name, options = T.unsafe(nil)); end
end

# source://datadog//lib/datadog/appsec/contrib/integration.rb#10
class Datadog::AppSec::Contrib::Integration::RegisteredIntegration < ::Struct
  # Returns the value of attribute klass
  #
  # @return [Object] the current value of klass
  #
  # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
  def klass; end

  # Sets the attribute klass
  #
  # @param value [Object] the value to set the attribute klass to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
  def klass=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
  def name=(_); end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  #
  # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
  def options=(_); end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
    def [](*_arg0); end

    # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
    def inspect; end

    # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
    def keyword_init?; end

    # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
    def members; end

    # source://datadog//lib/datadog/appsec/contrib/integration.rb#10
    def new(*_arg0); end
  end
end

# source://datadog//lib/datadog/appsec/contrib/rack/ext.rb#6
module Datadog::AppSec::Contrib::Rack; end

# Rack integration constants
#
# source://datadog//lib/datadog/appsec/contrib/rack/ext.rb#8
module Datadog::AppSec::Contrib::Rack::Ext; end

# source://datadog//lib/datadog/appsec/contrib/rack/ext.rb#9
Datadog::AppSec::Contrib::Rack::Ext::COLLECTABLE_REQUEST_HEADERS = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/contrib/rack/ext.rb#23
Datadog::AppSec::Contrib::Rack::Ext::IDENTITY_COLLECTABLE_REQUEST_HEADERS = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#13
module Datadog::AppSec::Contrib::Rack::Gateway; end

# Gateway Request argument. Normalized extration of data from Rack::Request
#
# source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#13
class Datadog::AppSec::Contrib::Rack::Gateway::Request < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [Request] a new instance of Request
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#16
  def initialize(env); end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#90
  def client_ip; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#65
  def cookies; end

  # Returns the value of attribute env.
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#14
  def env; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#81
  def form_hash; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#57
  def fullpath; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#42
  def headers; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#69
  def host; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#38
  def method; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#61
  def path; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#25
  def query; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#77
  def remote_addr; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#21
  def request; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#53
  def url; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/request.rb#73
  def user_agent; end
end

# Gateway Response argument.
#
# source://datadog//lib/datadog/appsec/contrib/rack/gateway/response.rb#11
class Datadog::AppSec::Contrib::Rack::Gateway::Response < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [Response] a new instance of Response
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/response.rb#14
  def initialize(body, status, headers, context:); end

  # Returns the value of attribute body.
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/response.rb#12
  def body; end

  # Returns the value of attribute context.
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/response.rb#12
  def context; end

  # Returns the value of attribute headers.
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/response.rb#12
  def headers; end

  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/response.rb#22
  def response; end

  # Returns the value of attribute status.
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/gateway/response.rb#12
  def status; end
end

# Watcher for Rack gateway events
#
# source://datadog//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#15
module Datadog::AppSec::Contrib::Rack::Gateway::Watcher
  class << self
    # source://datadog//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#17
    def watch; end

    # source://datadog//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#26
    def watch_request(gateway = T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#86
    def watch_request_body(gateway = T.unsafe(nil)); end

    # NOTE: In the current state we unable to substibe twice to the same
    #       event within the same group. Ideally this code should live
    #       somewhere closer to identity related monitor.
    # WARNING: The Gateway is a subject of refactoring
    #
    # source://datadog//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#115
    def watch_request_finish(gateway = T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#59
    def watch_response(gateway = T.unsafe(nil)); end
  end
end

# Description of Rack integration
#
# source://datadog//lib/datadog/appsec/contrib/rack/integration.rb#14
class Datadog::AppSec::Contrib::Rack::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://datadog//lib/datadog/appsec/contrib/rack/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rack/integration.rb#33
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rack/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rack/integration.rb#25
    def loaded?; end

    # source://datadog//lib/datadog/appsec/contrib/rack/integration.rb#21
    def version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/rack/integration.rb#17
Datadog::AppSec::Contrib::Rack::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher for Rack integration
#
# source://datadog//lib/datadog/appsec/contrib/rack/patcher.rb#11
module Datadog::AppSec::Contrib::Rack::Patcher
  private

  # source://datadog//lib/datadog/appsec/contrib/rack/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/appsec/contrib/rack/patcher.rb#14
  def patched?; end

  # source://datadog//lib/datadog/appsec/contrib/rack/patcher.rb#18
  def target_version; end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/rack/patcher.rb#22
    def patch; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rack/patcher.rb#14
    def patched?; end

    # source://datadog//lib/datadog/appsec/contrib/rack/patcher.rb#18
    def target_version; end
  end
end

# Rack request body middleware for AppSec
# This should be inserted just below Rack::JSONBodyParser or
# legacy Rack::PostBodyContentTypeParser from rack-contrib
#
# source://datadog//lib/datadog/appsec/contrib/rack/request_body_middleware.rb#14
class Datadog::AppSec::Contrib::Rack::RequestBodyMiddleware
  # @return [RequestBodyMiddleware] a new instance of RequestBodyMiddleware
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/request_body_middleware.rb#15
  def initialize(app, opt = T.unsafe(nil)); end

  # source://datadog//lib/datadog/appsec/contrib/rack/request_body_middleware.rb#19
  def call(env); end
end

# Topmost Rack middleware for AppSec
# This should be inserted just below Datadog::Tracing::Contrib::Rack::TraceMiddleware
#
# source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#34
class Datadog::AppSec::Contrib::Rack::RequestMiddleware
  # @return [RequestMiddleware] a new instance of RequestMiddleware
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#35
  def initialize(app, opt = T.unsafe(nil)); end

  # source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#43
  def call(env); end

  private

  # source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#130
  def active_context(env); end

  # source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#142
  def active_span; end

  # source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#134
  def active_trace; end

  # standard:disable Metrics/MethodLength
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#151
  def add_appsec_tags(context); end

  # standard:disable Metrics/MethodLength
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#183
  def add_request_tags(context, env); end

  # standard:enable Metrics/MethodLength
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#207
  def oneshot_tags_sent?; end

  # source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#211
  def to_rack_header(header); end
end

# source://datadog//lib/datadog/appsec/contrib/rack/request_middleware.rb#21
Datadog::AppSec::Contrib::Rack::WAF_VENDOR_HEADERS_TAGS = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/contrib/rails/framework.rb#6
module Datadog::AppSec::Contrib::Rails; end

# Rails specific framework tie
#
# source://datadog//lib/datadog/appsec/contrib/rails/framework.rb#8
module Datadog::AppSec::Contrib::Rails::Framework
  class << self
    # source://datadog//lib/datadog/appsec/contrib/rails/framework.rb#9
    def setup; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/rails/gateway/watcher.rb#12
module Datadog::AppSec::Contrib::Rails::Gateway; end

# Gateway Request argument. Normalized extration of data from ActionDispatch::Request
#
# source://datadog//lib/datadog/appsec/contrib/rails/gateway/request.rb#11
class Datadog::AppSec::Contrib::Rails::Gateway::Request < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [Request] a new instance of Request
  #
  # source://datadog//lib/datadog/appsec/contrib/rails/gateway/request.rb#14
  def initialize(request); end

  # source://datadog//lib/datadog/appsec/contrib/rails/gateway/request.rb#19
  def env; end

  # source://datadog//lib/datadog/appsec/contrib/rails/gateway/request.rb#23
  def headers; end

  # source://datadog//lib/datadog/appsec/contrib/rails/gateway/request.rb#27
  def host; end

  # source://datadog//lib/datadog/appsec/contrib/rails/gateway/request.rb#39
  def parsed_body; end

  # source://datadog//lib/datadog/appsec/contrib/rails/gateway/request.rb#35
  def remote_addr; end

  # Returns the value of attribute request.
  #
  # source://datadog//lib/datadog/appsec/contrib/rails/gateway/request.rb#12
  def request; end

  # source://datadog//lib/datadog/appsec/contrib/rails/gateway/request.rb#55
  def route_params; end

  # source://datadog//lib/datadog/appsec/contrib/rails/gateway/request.rb#31
  def user_agent; end
end

# Watcher for Rails gateway events
#
# source://datadog//lib/datadog/appsec/contrib/rails/gateway/watcher.rb#14
module Datadog::AppSec::Contrib::Rails::Gateway::Watcher
  class << self
    # source://datadog//lib/datadog/appsec/contrib/rails/gateway/watcher.rb#16
    def watch; end

    # source://datadog//lib/datadog/appsec/contrib/rails/gateway/watcher.rb#23
    def watch_request_action(gateway = T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/contrib/rails/gateway/watcher.rb#49
    def watch_response_body_json(gateway = T.unsafe(nil)); end
  end
end

# Description of Rails integration
#
# source://datadog//lib/datadog/appsec/contrib/rails/integration.rb#13
class Datadog::AppSec::Contrib::Rails::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://datadog//lib/datadog/appsec/contrib/rails/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rails/integration.rb#32
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rails/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rails/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/appsec/contrib/rails/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/rails/integration.rb#16
Datadog::AppSec::Contrib::Rails::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher for AppSec on Rails
#
# source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#22
module Datadog::AppSec::Contrib::Rails::Patcher
  private

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#64
  def add_middleware(app); end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#120
  def after_initialize(app); end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#54
  def before_initialize(app); end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#76
  def include_middleware?(middleware, app); end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#110
  def inspect_middlewares(app); end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#38
  def patch; end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#129
  def patch_action_controller; end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#114
  def patch_after_initialize; end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#48
  def patch_before_initialize; end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#30
  def patched?; end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#148
  def report_routes_via_telemetry(routes); end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#164
  def setup_security; end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#142
  def subscribe_to_routes_loaded; end

  # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#34
  def target_version; end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#64
    def add_middleware(app); end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#120
    def after_initialize(app); end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#54
    def before_initialize(app); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#76
    def include_middleware?(middleware, app); end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#110
    def inspect_middlewares(app); end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#38
    def patch; end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#129
    def patch_action_controller; end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#114
    def patch_after_initialize; end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#48
    def patch_before_initialize; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#30
    def patched?; end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#148
    def report_routes_via_telemetry(routes); end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#164
    def setup_security; end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#142
    def subscribe_to_routes_loaded; end

    # source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#34
    def target_version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#26
Datadog::AppSec::Contrib::Rails::Patcher::AFTER_INITIALIZE_ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#25
Datadog::AppSec::Contrib::Rails::Patcher::BEFORE_INITIALIZE_ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#23
Datadog::AppSec::Contrib::Rails::Patcher::GUARD_ACTION_CONTROLLER_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/appsec/contrib/rails/patcher.rb#24
Datadog::AppSec::Contrib::Rails::Patcher::GUARD_ROUTES_REPORTING_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/appsec/contrib/rails/patches/render_to_body_patch.rb#10
module Datadog::AppSec::Contrib::Rails::Patches; end

# Hook into ActionController::Instrumentation#process_action, which encompasses action filters
#
# source://datadog//lib/datadog/appsec/contrib/rails/patches/process_action_patch.rb#9
module Datadog::AppSec::Contrib::Rails::Patches::ProcessActionPatch
  # source://datadog//lib/datadog/appsec/contrib/rails/patches/process_action_patch.rb#10
  def process_action(*args); end
end

# A patch targeting `AbstractController::Rendering#render_to_body`
# method to capture JSON response body right before it is serialized.
#
# source://datadog//lib/datadog/appsec/contrib/rails/patches/render_to_body_patch.rb#13
module Datadog::AppSec::Contrib::Rails::Patches::RenderToBodyPatch
  # source://datadog//lib/datadog/appsec/contrib/rails/patches/render_to_body_patch.rb#14
  def render_to_body(options = T.unsafe(nil)); end
end

# Rack middleware for AppSec on Rails
#
# source://datadog//lib/datadog/appsec/contrib/rails/request_middleware.rb#8
class Datadog::AppSec::Contrib::Rails::RequestMiddleware
  # @return [RequestMiddleware] a new instance of RequestMiddleware
  #
  # source://datadog//lib/datadog/appsec/contrib/rails/request_middleware.rb#9
  def initialize(app, opt = T.unsafe(nil)); end

  # source://datadog//lib/datadog/appsec/contrib/rails/request_middleware.rb#13
  def call(env); end
end

# source://datadog//lib/datadog/appsec/contrib/rest_client/patcher.rb#6
module Datadog::AppSec::Contrib::RestClient; end

# This class defines properties of rest-client AppSec integration
#
# source://datadog//lib/datadog/appsec/contrib/rest_client/integration.rb#11
class Datadog::AppSec::Contrib::RestClient::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://datadog//lib/datadog/appsec/contrib/rest_client/integration.rb#38
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rest_client/integration.rb#34
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rest_client/integration.rb#30
    def compatible?; end

    # source://datadog//lib/datadog/appsec/contrib/rest_client/integration.rb#18
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rest_client/integration.rb#26
    def loaded?; end

    # source://datadog//lib/datadog/appsec/contrib/rest_client/integration.rb#22
    def version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/rest_client/integration.rb#14
Datadog::AppSec::Contrib::RestClient::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher for RestClient gem
#
# source://datadog//lib/datadog/appsec/contrib/rest_client/patcher.rb#8
module Datadog::AppSec::Contrib::RestClient::Patcher
  private

  # source://datadog//lib/datadog/appsec/contrib/rest_client/patcher.rb#19
  def patch; end

  # source://datadog//lib/datadog/appsec/contrib/rest_client/patcher.rb#11
  def patched?; end

  # source://datadog//lib/datadog/appsec/contrib/rest_client/patcher.rb#15
  def target_version; end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/rest_client/patcher.rb#19
    def patch; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/rest_client/patcher.rb#11
    def patched?; end

    # source://datadog//lib/datadog/appsec/contrib/rest_client/patcher.rb#15
    def target_version; end
  end
end

# Instrument Sinatra.
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/framework.rb#7
module Datadog::AppSec::Contrib::Sinatra; end

# Set tracer configuration at a late enough time
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#19
module Datadog::AppSec::Contrib::Sinatra::AppSecSetupPatch
  # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#20
  def setup_middleware(*args, &block); end
end

# Hook into builder before the middleware list gets frozen
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#28
module Datadog::AppSec::Contrib::Sinatra::DefaultMiddlewarePatch
  # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#29
  def setup_middleware(*args, &block); end
end

# Hook into Base#dispatch!, which encompasses route filters
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#52
module Datadog::AppSec::Contrib::Sinatra::DispatchPatch
  # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#53
  def dispatch!; end
end

# Sinatra framework code, used to essentially:
# - handle configuration entries which are specific to Datadog tracing
# - instrument parts of the framework when needed
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/framework.rb#11
module Datadog::AppSec::Contrib::Sinatra::Framework
  class << self
    # Configure Rack from Sinatra, but only if Rack has not been configured manually beforehand
    #
    # source://datadog//lib/datadog/appsec/contrib/sinatra/framework.rb#13
    def setup; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#12
module Datadog::AppSec::Contrib::Sinatra::Gateway; end

# Gateway Request argument. Normalized extration of data from Rack::Request
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/gateway/request.rb#11
class Datadog::AppSec::Contrib::Sinatra::Gateway::Request < ::Datadog::AppSec::Contrib::Rack::Gateway::Request; end

# Gateway Route Params argument.
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/gateway/route_params.rb#11
class Datadog::AppSec::Contrib::Sinatra::Gateway::RouteParams < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [RouteParams] a new instance of RouteParams
  #
  # source://datadog//lib/datadog/appsec/contrib/sinatra/gateway/route_params.rb#14
  def initialize(params); end

  # Returns the value of attribute params.
  #
  # source://datadog//lib/datadog/appsec/contrib/sinatra/gateway/route_params.rb#12
  def params; end
end

# Watcher for Sinatra gateway events
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#14
module Datadog::AppSec::Contrib::Sinatra::Gateway::Watcher
  class << self
    # source://datadog//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#16
    def watch; end

    # source://datadog//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#24
    def watch_request_dispatch(gateway = T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#51
    def watch_request_routed(gateway = T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#76
    def watch_response_body_json(gateway = T.unsafe(nil)); end
  end
end

# Description of Sinatra integration
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/integration.rb#13
class Datadog::AppSec::Contrib::Sinatra::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://datadog//lib/datadog/appsec/contrib/sinatra/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/sinatra/integration.rb#32
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/sinatra/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/sinatra/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/appsec/contrib/sinatra/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/sinatra/integration.rb#16
Datadog::AppSec::Contrib::Sinatra::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher for AppSec on Sinatra
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#102
module Datadog::AppSec::Contrib::Sinatra::Patcher
  private

  # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#113
  def patch; end

  # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#125
  def patch_json?; end

  # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#105
  def patched?; end

  # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#109
  def target_version; end

  class << self
    # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#113
    def patch; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#125
    def patch_json?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#105
    def patched?; end

    # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#109
    def target_version; end
  end
end

# source://datadog//lib/datadog/appsec/contrib/sinatra/patches/json_patch.rb#10
module Datadog::AppSec::Contrib::Sinatra::Patches; end

# A patch targeting `Sinatra::JSON#json` method to capture JSON response
# body right before it is serialized.
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/patches/json_patch.rb#13
module Datadog::AppSec::Contrib::Sinatra::Patches::JsonPatch
  # source://datadog//lib/datadog/appsec/contrib/sinatra/patches/json_patch.rb#14
  def json(object, options = T.unsafe(nil)); end
end

# Rack middleware for AppSec on Sinatra
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/request_middleware.rb#8
class Datadog::AppSec::Contrib::Sinatra::RequestMiddleware
  # @return [RequestMiddleware] a new instance of RequestMiddleware
  #
  # source://datadog//lib/datadog/appsec/contrib/sinatra/request_middleware.rb#9
  def initialize(app, opt = T.unsafe(nil)); end

  # source://datadog//lib/datadog/appsec/contrib/sinatra/request_middleware.rb#13
  def call(env); end
end

# Hook into Base#route_eval, which
# path params are returned by pattern.params in process_route, then
# merged with normal params, so we get both
#
# source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#73
module Datadog::AppSec::Contrib::Sinatra::RoutePatch
  # source://datadog//lib/datadog/appsec/contrib/sinatra/patcher.rb#74
  def process_route(*_arg0); end
end

# AppSec event
#
# source://datadog//lib/datadog/appsec/event.rb#11
module Datadog::AppSec::Event
  class << self
    # source://datadog//lib/datadog/appsec/event.rb#53
    def record(context, request: T.unsafe(nil), response: T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/event.rb#43
    def tag(context, waf_result); end

    private

    # NOTE: Handling of Encoding::UndefinedConversionError is added as a quick fix to
    #       the issue between Ruby encoded strings and libddwaf produced events and now
    #       is under investigation.
    #
    # source://datadog//lib/datadog/appsec/event.rb#129
    def json_parse(value); end

    # source://datadog//lib/datadog/appsec/event.rb#79
    def request_tags(request); end

    # source://datadog//lib/datadog/appsec/event.rb#93
    def response_tags(response); end

    # source://datadog//lib/datadog/appsec/event.rb#101
    def waf_tags(security_events); end
  end
end

# source://datadog//lib/datadog/appsec/event.rb#14
Datadog::AppSec::Event::ALLOWED_REQUEST_HEADERS = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/event.rb#35
Datadog::AppSec::Event::ALLOWED_RESPONSE_HEADERS = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/event.rb#12
Datadog::AppSec::Event::ATTRIBUTES_SCHEMA_KEY_PREFIX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/event.rb#13
Datadog::AppSec::Event::ATTRIBUTES_SCHEMA_MAX_COMPRESSED_SIZE = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/appsec/ext.rb#5
module Datadog::AppSec::Ext; end

# source://datadog//lib/datadog/appsec/ext.rb#14
Datadog::AppSec::Ext::ACTIVE_CONTEXT_KEY = T.let(T.unsafe(nil), Symbol)

# source://datadog//lib/datadog/appsec/ext.rb#13
Datadog::AppSec::Ext::CONTEXT_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/ext.rb#15
Datadog::AppSec::Ext::EXPLOIT_PREVENTION_EVENT_CATEGORY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/ext.rb#12
Datadog::AppSec::Ext::INTERRUPT = T.let(T.unsafe(nil), Symbol)

# source://datadog//lib/datadog/appsec/ext.rb#10
Datadog::AppSec::Ext::PRODUCT_BIT = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/appsec/ext.rb#7
Datadog::AppSec::Ext::RASP_LFI = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/ext.rb#6
Datadog::AppSec::Ext::RASP_SQLI = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/ext.rb#8
Datadog::AppSec::Ext::RASP_SSRF = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/ext.rb#17
Datadog::AppSec::Ext::TAG_APPSEC_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/ext.rb#18
Datadog::AppSec::Ext::TAG_METASTRUCT_STACK_TRACE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/ext.rb#20
Datadog::AppSec::Ext::TELEMETRY_METRICS_NAMESPACE = T.let(T.unsafe(nil), String)

# Extends Datadog tracing with AppSec features
#
# source://datadog//lib/datadog/appsec/extensions.rb#9
module Datadog::AppSec::Extensions
  class << self
    # Inject AppSec into global objects.
    #
    # source://datadog//lib/datadog/appsec/extensions.rb#11
    def activate!; end
  end
end

# Instrumentation for AppSec
#
# source://datadog//lib/datadog/appsec/instrumentation/gateway/middleware.rb#5
module Datadog::AppSec::Instrumentation
  class << self
    # NOTE: This left as-is and will be depricated soon.
    #
    # source://datadog//lib/datadog/appsec/instrumentation/gateway.rb#54
    def gateway; end
  end
end

# Instrumentation gateway implementation
#
# source://datadog//lib/datadog/appsec/instrumentation/gateway/middleware.rb#6
class Datadog::AppSec::Instrumentation::Gateway
  # @return [Gateway] a new instance of Gateway
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway.rb#11
  def initialize; end

  # NOTE: Be careful with pushed names because every pushed event name
  #       is recorded in order to provide an ability to any subscriber
  #       to check wether an arbitrary event had happened.
  #
  # WARNING: If we start pushing generated names we should consider
  #          limiting the storage of pushed names.
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway.rb#22
  def push(name, env, &block); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway.rb#48
  def pushed?(name); end

  # source://datadog//lib/datadog/appsec/instrumentation/gateway.rb#44
  def watch(name, key, &block); end
end

# Base class for Gateway Arguments
#
# source://datadog//lib/datadog/appsec/instrumentation/gateway/argument.rb#8
class Datadog::AppSec::Instrumentation::Gateway::Argument; end

# This class is used to pass arbitrary data to the event system with an
# option to tie it to a context.
#
# NOTE: This class is a subject of elimination and will be removed when
#       the event system is refactored.
#
# source://datadog//lib/datadog/appsec/instrumentation/gateway/argument.rb#30
class Datadog::AppSec::Instrumentation::Gateway::DataContainer < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [DataContainer] a new instance of DataContainer
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway/argument.rb#33
  def initialize(data, context:); end

  # Returns the value of attribute context.
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway/argument.rb#31
  def context; end

  # Returns the value of attribute data.
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway/argument.rb#31
  def data; end
end

# NOTE: This class extracted as-is and will be deprecated
# Instrumentation gateway middleware
#
# source://datadog//lib/datadog/appsec/instrumentation/gateway/middleware.rb#9
class Datadog::AppSec::Instrumentation::Gateway::Middleware
  # @return [Middleware] a new instance of Middleware
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway/middleware.rb#12
  def initialize(key, &block); end

  # Returns the value of attribute block.
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway/middleware.rb#10
  def block; end

  # source://datadog//lib/datadog/appsec/instrumentation/gateway/middleware.rb#17
  def call(stack, env); end

  # Returns the value of attribute key.
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway/middleware.rb#10
  def key; end
end

# Gateway User argument
# NOTE: This class is a subject of elimination and will be removed when
#       the event system is refactored.
#
# source://datadog//lib/datadog/appsec/instrumentation/gateway/argument.rb#13
class Datadog::AppSec::Instrumentation::Gateway::User < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [User] a new instance of User
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway/argument.rb#16
  def initialize(id = T.unsafe(nil), login = T.unsafe(nil), session_id = T.unsafe(nil)); end

  # Returns the value of attribute id.
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway/argument.rb#14
  def id; end

  # Returns the value of attribute login.
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway/argument.rb#14
  def login; end

  # Returns the value of attribute session_id.
  #
  # source://datadog//lib/datadog/appsec/instrumentation/gateway/argument.rb#14
  def session_id; end
end

# This namespace contains classes related to metrics collection and exportation.
#
# source://datadog//lib/datadog/appsec/metrics.rb#6
module Datadog::AppSec::Metrics; end

# A class responsible for collecting WAF and RASP call metrics.
#
# source://datadog//lib/datadog/appsec/metrics/collector.rb#7
class Datadog::AppSec::Metrics::Collector
  # @return [Collector] a new instance of Collector
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#21
  def initialize; end

  # Returns the value of attribute rasp.
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#19
  def rasp; end

  # source://datadog//lib/datadog/appsec/metrics/collector.rb#44
  def record_rasp(result); end

  # source://datadog//lib/datadog/appsec/metrics/collector.rb#32
  def record_waf(result); end

  # Returns the value of attribute waf.
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#19
  def waf; end
end

# source://datadog//lib/datadog/appsec/metrics/collector.rb#8
class Datadog::AppSec::Metrics::Collector::Store < ::Struct
  # Returns the value of attribute duration_ext_ns
  #
  # @return [Object] the current value of duration_ext_ns
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def duration_ext_ns; end

  # Sets the attribute duration_ext_ns
  #
  # @param value [Object] the value to set the attribute duration_ext_ns to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def duration_ext_ns=(_); end

  # Returns the value of attribute duration_ns
  #
  # @return [Object] the current value of duration_ns
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def duration_ns; end

  # Sets the attribute duration_ns
  #
  # @param value [Object] the value to set the attribute duration_ns to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def duration_ns=(_); end

  # Returns the value of attribute errors
  #
  # @return [Object] the current value of errors
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def errors; end

  # Sets the attribute errors
  #
  # @param value [Object] the value to set the attribute errors to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def errors=(_); end

  # Returns the value of attribute evals
  #
  # @return [Object] the current value of evals
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def evals; end

  # Sets the attribute evals
  #
  # @param value [Object] the value to set the attribute evals to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def evals=(_); end

  # Returns the value of attribute inputs_truncated
  #
  # @return [Object] the current value of inputs_truncated
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def inputs_truncated; end

  # Sets the attribute inputs_truncated
  #
  # @param value [Object] the value to set the attribute inputs_truncated to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def inputs_truncated=(_); end

  # Returns the value of attribute matches
  #
  # @return [Object] the current value of matches
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def matches; end

  # Sets the attribute matches
  #
  # @param value [Object] the value to set the attribute matches to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def matches=(_); end

  # Returns the value of attribute timeouts
  #
  # @return [Object] the current value of timeouts
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def timeouts; end

  # Sets the attribute timeouts
  #
  # @param value [Object] the value to set the attribute timeouts to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
  def timeouts=(_); end

  class << self
    # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
    def [](*_arg0); end

    # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
    def inspect; end

    # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
    def keyword_init?; end

    # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
    def members; end

    # source://datadog//lib/datadog/appsec/metrics/collector.rb#8
    def new(*_arg0); end
  end
end

# A class responsible for exporting WAF and RASP call metrics.
#
# source://datadog//lib/datadog/appsec/metrics/exporter.rb#7
module Datadog::AppSec::Metrics::Exporter
  private

  # private
  #
  # source://datadog//lib/datadog/appsec/metrics/exporter.rb#29
  def convert_ns_to_us(value); end

  # source://datadog//lib/datadog/appsec/metrics/exporter.rb#18
  def export_rasp_metrics(metrics, span); end

  # source://datadog//lib/datadog/appsec/metrics/exporter.rb#10
  def export_waf_metrics(metrics, span); end

  class << self
    # private
    #
    # source://datadog//lib/datadog/appsec/metrics/exporter.rb#29
    def convert_ns_to_us(value); end

    # source://datadog//lib/datadog/appsec/metrics/exporter.rb#18
    def export_rasp_metrics(metrics, span); end

    # source://datadog//lib/datadog/appsec/metrics/exporter.rb#10
    def export_waf_metrics(metrics, span); end
  end
end

# A class responsible for reporting WAF and RASP telemetry metrics.
#
# source://datadog//lib/datadog/appsec/metrics/telemetry.rb#7
module Datadog::AppSec::Metrics::Telemetry
  private

  # source://datadog//lib/datadog/appsec/metrics/telemetry.rb#10
  def report_rasp(type, result); end

  class << self
    # source://datadog//lib/datadog/appsec/metrics/telemetry.rb#10
    def report_rasp(type, result); end
  end
end

# A class responsible for exporting WAF request metrics via Telemetry.
#
# source://datadog//lib/datadog/appsec/metrics/telemetry_exporter.rb#7
module Datadog::AppSec::Metrics::TelemetryExporter
  private

  # source://datadog//lib/datadog/appsec/metrics/telemetry_exporter.rb#10
  def export_waf_request_metrics(metrics, context); end

  class << self
    # source://datadog//lib/datadog/appsec/metrics/telemetry_exporter.rb#10
    def export_waf_request_metrics(metrics, context); end
  end
end

# Monitor for internal AppSec Events
#
# source://datadog//lib/datadog/appsec/monitor/gateway/watcher.rb#9
module Datadog::AppSec::Monitor; end

# source://datadog//lib/datadog/appsec/monitor/gateway/watcher.rb#10
module Datadog::AppSec::Monitor::Gateway; end

# Watcher for Apssec internal events
#
# source://datadog//lib/datadog/appsec/monitor/gateway/watcher.rb#12
module Datadog::AppSec::Monitor::Gateway::Watcher
  class << self
    # source://datadog//lib/datadog/appsec/monitor/gateway/watcher.rb#19
    def watch; end

    # source://datadog//lib/datadog/appsec/monitor/gateway/watcher.rb#26
    def watch_user_id(gateway = T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/monitor/gateway/watcher.rb#57
    def watch_user_login(gateway = T.unsafe(nil)); end
  end
end

# source://datadog//lib/datadog/appsec/monitor/gateway/watcher.rb#13
Datadog::AppSec::Monitor::Gateway::Watcher::ARBITRARY_VALUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/monitor/gateway/watcher.rb#15
Datadog::AppSec::Monitor::Gateway::Watcher::EVENT_LOGIN_FAILURE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/monitor/gateway/watcher.rb#14
Datadog::AppSec::Monitor::Gateway::Watcher::EVENT_LOGIN_SUCCESS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/monitor/gateway/watcher.rb#16
Datadog::AppSec::Monitor::Gateway::Watcher::WATCHED_LOGIN_EVENTS = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/processor/rule_loader.rb#7
class Datadog::AppSec::Processor; end

# RuleLoader utility modules
# that load appsec rules and data from  settings
#
# source://datadog//lib/datadog/appsec/processor/rule_loader.rb#10
module Datadog::AppSec::Processor::RuleLoader
  class << self
    # source://datadog//lib/datadog/appsec/processor/rule_loader.rb#42
    def load_data(ip_denylist: T.unsafe(nil), user_id_denylist: T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/processor/rule_loader.rb#50
    def load_exclusions(ip_passlist: T.unsafe(nil)); end

    # source://datadog//lib/datadog/appsec/processor/rule_loader.rb#12
    def load_rules(ruleset:, telemetry:); end

    private

    # source://datadog//lib/datadog/appsec/processor/rule_loader.rb#58
    def denylist_data(id, denylist); end

    # source://datadog//lib/datadog/appsec/processor/rule_loader.rb#66
    def passlist_exclusions(ip_passlist); end
  end
end

# Per-thread rate limiter based on token bucket rate limiter.
#
# Since AppSec marks sampling to keep on a security event, this limits
# the flood of egress traces involving AppSec
#
# source://datadog//lib/datadog/appsec/rate_limiter.rb#11
class Datadog::AppSec::RateLimiter
  # @return [RateLimiter] a new instance of RateLimiter
  #
  # source://datadog//lib/datadog/appsec/rate_limiter.rb#34
  def initialize(rate); end

  # source://datadog//lib/datadog/appsec/rate_limiter.rb#38
  def limit; end

  class << self
    # reset a rate limiter: used for testing
    #
    # source://datadog//lib/datadog/appsec/rate_limiter.rb#23
    def reset!; end

    # source://datadog//lib/datadog/appsec/rate_limiter.rb#15
    def thread_local; end

    private

    # source://datadog//lib/datadog/appsec/rate_limiter.rb#29
    def trace_rate_limit; end
  end
end

# source://datadog//lib/datadog/appsec/rate_limiter.rb#12
Datadog::AppSec::RateLimiter::THREAD_KEY = T.let(T.unsafe(nil), Symbol)

# Remote
#
# source://datadog//lib/datadog/appsec/remote.rb#9
module Datadog::AppSec::Remote
  class << self
    # source://datadog//lib/datadog/appsec/remote.rb#63
    def capabilities; end

    # source://datadog//lib/datadog/appsec/remote.rb#67
    def products; end

    # source://datadog//lib/datadog/appsec/remote.rb#71
    def receivers(telemetry); end

    private

    # @raise [ReadError]
    #
    # source://datadog//lib/datadog/appsec/remote.rb#107
    def parse_content(content); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/appsec/remote.rb#103
    def remote_features_enabled?; end
  end
end

# source://datadog//lib/datadog/appsec/remote.rb#12
class Datadog::AppSec::Remote::NoRulesError < ::StandardError; end

# source://datadog//lib/datadog/appsec/remote.rb#10
class Datadog::AppSec::Remote::ReadError < ::StandardError; end

# AppSec response
#
# source://datadog//lib/datadog/appsec/response.rb#9
class Datadog::AppSec::Response
  # @return [Response] a new instance of Response
  #
  # source://datadog//lib/datadog/appsec/response.rb#12
  def initialize(status:, headers: T.unsafe(nil), body: T.unsafe(nil)); end

  # Returns the value of attribute body.
  #
  # source://datadog//lib/datadog/appsec/response.rb#10
  def body; end

  # Returns the value of attribute headers.
  #
  # source://datadog//lib/datadog/appsec/response.rb#10
  def headers; end

  # Returns the value of attribute status.
  #
  # source://datadog//lib/datadog/appsec/response.rb#10
  def status; end

  # source://datadog//lib/datadog/appsec/response.rb#18
  def to_rack; end

  class << self
    # source://datadog//lib/datadog/appsec/response.rb#23
    def from_interrupt_params(interrupt_params, http_accept_header); end

    private

    # source://datadog//lib/datadog/appsec/response.rb#31
    def block_response(interrupt_params, http_accept_header); end

    # source://datadog//lib/datadog/appsec/response.rb#85
    def content(content_type); end

    # source://datadog//lib/datadog/appsec/response.rb#67
    def content_type(http_accept_header); end

    # source://datadog//lib/datadog/appsec/response.rb#44
    def redirect_response(interrupt_params); end
  end
end

# SampleRate basic sample rate
#
# source://datadog//lib/datadog/appsec/sample_rate.rb#6
class Datadog::AppSec::SampleRate
  # @return [SampleRate] a new instance of SampleRate
  #
  # source://datadog//lib/datadog/appsec/sample_rate.rb#9
  def initialize(rate); end

  # Returns the value of attribute rate.
  #
  # source://datadog//lib/datadog/appsec/sample_rate.rb#7
  def rate; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/sample_rate.rb#13
  def sample?; end
end

# A namespace for secutiry library we use to detect and prevent threats.
#
# source://datadog//lib/datadog/appsec/security_engine/engine.rb#5
module Datadog::AppSec::SecurityEngine; end

# SecurityEngine::Engine creates WAF builder and manages its configuration.
# It also rebuilds WAF handle from the WAF builder when configuration changes.
#
# source://datadog//lib/datadog/appsec/security_engine/engine.rb#8
class Datadog::AppSec::SecurityEngine::Engine
  # @return [Engine] a new instance of Engine
  #
  # source://datadog//lib/datadog/appsec/security_engine/engine.rb#23
  def initialize(appsec_settings:, telemetry:); end

  # source://datadog//lib/datadog/appsec/security_engine/engine.rb#56
  def add_or_update_config(config, path:); end

  # source://datadog//lib/datadog/appsec/security_engine/engine.rb#52
  def new_runner; end

  # source://datadog//lib/datadog/appsec/security_engine/engine.rb#101
  def reconfigure!; end

  # source://datadog//lib/datadog/appsec/security_engine/engine.rb#84
  def remove_config_at_path(path); end

  private

  # source://datadog//lib/datadog/appsec/security_engine/engine.rb#117
  def load_default_config(telemetry:); end

  # @raise [ArgumentError]
  #
  # source://datadog//lib/datadog/appsec/security_engine/engine.rb#132
  def report_configuration_diagnostics(diagnostics, action:, telemetry:); end
end

# source://datadog//lib/datadog/appsec/security_engine/engine.rb#9
Datadog::AppSec::SecurityEngine::Engine::DEFAULT_RULES_CONFIG_PATH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/security_engine/engine.rb#11
Datadog::AppSec::SecurityEngine::Engine::DIAGNOSTICS_CONFIG_KEYS = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/appsec/security_engine/engine.rb#10
Datadog::AppSec::SecurityEngine::Engine::TELEMETRY_ACTIONS = T.let(T.unsafe(nil), Array)

# A namespace for value-objects representing the result of WAF check.
#
# source://datadog//lib/datadog/appsec/security_engine/result.rb#7
module Datadog::AppSec::SecurityEngine::Result; end

# A generic result without indication of its type.
#
# source://datadog//lib/datadog/appsec/security_engine/result.rb#9
class Datadog::AppSec::SecurityEngine::Result::Base
  # @return [Base] a new instance of Base
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#12
  def initialize(events:, actions:, attributes:, duration_ns:, duration_ext_ns:, timeout:, keep:, input_truncated:); end

  # Returns the value of attribute actions.
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#10
  def actions; end

  # Returns the value of attribute attributes.
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#10
  def attributes; end

  # Returns the value of attribute duration_ext_ns.
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#10
  def duration_ext_ns; end

  # Returns the value of attribute duration_ns.
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#10
  def duration_ns; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#40
  def error?; end

  # Returns the value of attribute events.
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#10
  def events; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#32
  def input_truncated?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#28
  def keep?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#36
  def match?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#24
  def timeout?; end
end

# A result that indicates an internal security library error
#
# source://datadog//lib/datadog/appsec/security_engine/result.rb#68
class Datadog::AppSec::SecurityEngine::Result::Error
  # @return [Error] a new instance of Error
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#71
  def initialize(duration_ext_ns:, input_truncated:); end

  # Returns the value of attribute actions.
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#69
  def actions; end

  # Returns the value of attribute attributes.
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#69
  def attributes; end

  # Returns the value of attribute duration_ext_ns.
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#69
  def duration_ext_ns; end

  # Returns the value of attribute duration_ns.
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#69
  def duration_ns; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#95
  def error?; end

  # Returns the value of attribute events.
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#69
  def events; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#87
  def input_truncated?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#79
  def keep?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#91
  def match?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#83
  def timeout?; end
end

# A result that indicates a security rule match
#
# source://datadog//lib/datadog/appsec/security_engine/result.rb#46
class Datadog::AppSec::SecurityEngine::Result::Match < ::Datadog::AppSec::SecurityEngine::Result::Base
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#51
  def error?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#47
  def match?; end
end

# A result that indicates a successful security rules check without a match
#
# source://datadog//lib/datadog/appsec/security_engine/result.rb#57
class Datadog::AppSec::SecurityEngine::Result::Ok < ::Datadog::AppSec::SecurityEngine::Result::Base
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#62
  def error?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_engine/result.rb#58
  def match?; end
end

# A class that check input via security engine (WAF) and respond with result.
#
# source://datadog//lib/datadog/appsec/security_engine/runner.rb#9
class Datadog::AppSec::SecurityEngine::Runner
  # @return [Runner] a new instance of Runner
  #
  # source://datadog//lib/datadog/appsec/security_engine/runner.rb#14
  def initialize(handle_ref, ruleset_version:); end

  # source://datadog//lib/datadog/appsec/security_engine/runner.rb#71
  def finalize!; end

  # Returns the value of attribute ruleset_version.
  #
  # source://datadog//lib/datadog/appsec/security_engine/runner.rb#12
  def ruleset_version; end

  # source://datadog//lib/datadog/appsec/security_engine/runner.rb#23
  def run(persistent_data, ephemeral_data, timeout = T.unsafe(nil)); end

  # source://datadog//lib/datadog/appsec/security_engine/runner.rb#67
  def waf_addresses; end

  # source://datadog//lib/datadog/appsec/security_engine/runner.rb#63
  def waf_context; end

  private

  # source://datadog//lib/datadog/appsec/security_engine/runner.rb#96
  def report_execution(result); end

  # source://datadog//lib/datadog/appsec/security_engine/runner.rb#79
  def try_run(persistent_data, ephemeral_data, timeout); end
end

# source://datadog//lib/datadog/appsec/security_engine/runner.rb#10
Datadog::AppSec::SecurityEngine::Runner::SUCCESSFUL_EXECUTION_CODES = T.let(T.unsafe(nil), Array)

# A class that represents a security event of any kind. It could be an event
# representing an attack or fingerprinting results as attributes or an API
# security check with extracted schema.
#
# source://datadog//lib/datadog/appsec/security_event.rb#8
class Datadog::AppSec::SecurityEvent
  # @return [SecurityEvent] a new instance of SecurityEvent
  #
  # source://datadog//lib/datadog/appsec/security_event.rb#14
  def initialize(waf_result, trace:, span:); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_event.rb#30
  def fingerprint?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_event.rb#20
  def keep?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/security_event.rb#24
  def schema?; end

  # Returns the value of attribute span.
  #
  # source://datadog//lib/datadog/appsec/security_event.rb#12
  def span; end

  # Returns the value of attribute trace.
  #
  # source://datadog//lib/datadog/appsec/security_event.rb#12
  def trace; end

  # Returns the value of attribute waf_result.
  #
  # source://datadog//lib/datadog/appsec/security_event.rb#12
  def waf_result; end
end

# source://datadog//lib/datadog/appsec/security_event.rb#10
Datadog::AppSec::SecurityEvent::FINGERPRINT_KEY_PREFIX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/security_event.rb#9
Datadog::AppSec::SecurityEvent::SCHEMA_KEY_PREFIX = T.let(T.unsafe(nil), String)

# This class is used for referencing an object that might be marked
# for finalization in another thread.
#
# References to the object are counted, and objects marked for finalization
# can be safely finalized when their reference count reaches zero.
#
# source://datadog//lib/datadog/appsec/thread_safe_ref.rb#10
class Datadog::AppSec::ThreadSafeRef
  # @return [ThreadSafeRef] a new instance of ThreadSafeRef
  #
  # source://datadog//lib/datadog/appsec/thread_safe_ref.rb#11
  def initialize(initial_obj, finalizer: T.unsafe(nil)); end

  # source://datadog//lib/datadog/appsec/thread_safe_ref.rb#20
  def acquire; end

  # source://datadog//lib/datadog/appsec/thread_safe_ref.rb#40
  def current=(obj); end

  # source://datadog//lib/datadog/appsec/thread_safe_ref.rb#28
  def release(obj); end

  private

  # source://datadog//lib/datadog/appsec/thread_safe_ref.rb#50
  def finalize(obj); end
end

# This class is used to mark trace as manual keep and tag it as ASM product.
#
# source://datadog//lib/datadog/appsec/trace_keeper.rb#6
module Datadog::AppSec::TraceKeeper
  class << self
    # source://datadog//lib/datadog/appsec/trace_keeper.rb#7
    def keep!(trace); end
  end
end

# Utilities for AppSec
#
# source://datadog//lib/datadog/appsec/utils.rb#6
module Datadog::AppSec::Utils; end

# HTTP utilities
#
# source://datadog//lib/datadog/appsec/utils/http/media_type.rb#6
module Datadog::AppSec::Utils::HTTP; end

# Implementation of media range for content negotiation
#
# source://datadog//lib/datadog/appsec/utils/http/media_range.rb#10
class Datadog::AppSec::Utils::HTTP::MediaRange
  # @raise [ParseError]
  # @return [MediaRange] a new instance of MediaRange
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#94
  def initialize(media_range); end

  # Compare two MediaRange for ordering
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#141
  def <=>(other); end

  # Compare with a MediaType for match
  #
  # returns true if the MediaType is accepted by this MediaRange
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#170
  def ===(other); end

  # Returns the value of attribute accept_ext.
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#92
  def accept_ext; end

  # Returns the value of attribute parameters.
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#92
  def parameters; end

  # Returns the value of attribute quality.
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#92
  def quality; end

  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#178
  def specificity; end

  # Returns the value of attribute subtype.
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#92
  def subtype; end

  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#188
  def to_s; end

  # Returns the value of attribute type.
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#92
  def type; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_range.rb#182
  def wildcard?(field = T.unsafe(nil)); end
end

# See: https://www.rfc-editor.org/rfc/rfc7231#section-5.3.2
#
# source://datadog//lib/datadog/appsec/utils/http/media_range.rb#34
Datadog::AppSec::Utils::HTTP::MediaRange::ACCEPT_EXT_RE = T.let(T.unsafe(nil), Regexp)

# See: https://www.rfc-editor.org/rfc/rfc7231#section-5.3.2
#
# source://datadog//lib/datadog/appsec/utils/http/media_range.rb#54
Datadog::AppSec::Utils::HTTP::MediaRange::MEDIA_RANGE_RE = T.let(T.unsafe(nil), Regexp)

# See: https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1
#
# source://datadog//lib/datadog/appsec/utils/http/media_range.rb#21
Datadog::AppSec::Utils::HTTP::MediaRange::PARAMETER_RE = T.let(T.unsafe(nil), Regexp)

# source://datadog//lib/datadog/appsec/utils/http/media_range.rb#11
class Datadog::AppSec::Utils::HTTP::MediaRange::ParseError < ::StandardError; end

# See: https://www.rfc-editor.org/rfc/rfc7231#section-5.3.1
#
# source://datadog//lib/datadog/appsec/utils/http/media_range.rb#47
Datadog::AppSec::Utils::HTTP::MediaRange::QVALUE_RE = T.let(T.unsafe(nil), Regexp)

# See: https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6
#
# source://datadog//lib/datadog/appsec/utils/http/media_range.rb#18
Datadog::AppSec::Utils::HTTP::MediaRange::TOKEN_RE = T.let(T.unsafe(nil), Regexp)

# source://datadog//lib/datadog/appsec/utils/http/media_range.rb#14
Datadog::AppSec::Utils::HTTP::MediaRange::WILDCARD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/appsec/utils/http/media_range.rb#15
Datadog::AppSec::Utils::HTTP::MediaRange::WILDCARD_RE = T.let(T.unsafe(nil), String)

# Implementation of media type for content negotiation
#
# See:
# - https://www.rfc-editor.org/rfc/rfc7231#section-5.3.1
# - https://www.rfc-editor.org/rfc/rfc7231#section-5.3.2
#
# source://datadog//lib/datadog/appsec/utils/http/media_type.rb#12
class Datadog::AppSec::Utils::HTTP::MediaType
  # @raise [ParseError]
  # @return [MediaType] a new instance of MediaType
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_type.rb#49
  def initialize(media_type); end

  # Returns the value of attribute parameters.
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_type.rb#47
  def parameters; end

  # Returns the value of attribute subtype.
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_type.rb#47
  def subtype; end

  # source://datadog//lib/datadog/appsec/utils/http/media_type.rb#76
  def to_s; end

  # Returns the value of attribute type.
  #
  # source://datadog//lib/datadog/appsec/utils/http/media_type.rb#47
  def type; end
end

# See: https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1
#
# source://datadog//lib/datadog/appsec/utils/http/media_type.rb#35
Datadog::AppSec::Utils::HTTP::MediaType::MEDIA_TYPE_RE = T.let(T.unsafe(nil), Regexp)

# See: https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1
#
# source://datadog//lib/datadog/appsec/utils/http/media_type.rb#22
Datadog::AppSec::Utils::HTTP::MediaType::PARAMETER_RE = T.let(T.unsafe(nil), Regexp)

# source://datadog//lib/datadog/appsec/utils/http/media_type.rb#13
class Datadog::AppSec::Utils::HTTP::MediaType::ParseError < ::StandardError; end

# See: https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6
#
# source://datadog//lib/datadog/appsec/utils/http/media_type.rb#19
Datadog::AppSec::Utils::HTTP::MediaType::TOKEN_RE = T.let(T.unsafe(nil), Regexp)

# source://datadog//lib/datadog/appsec/utils/http/media_type.rb#16
Datadog::AppSec::Utils::HTTP::MediaType::WILDCARD = T.let(T.unsafe(nil), String)

# A module for coercing arbitrary objects into hashes.
#
# source://datadog//lib/datadog/appsec/utils/hash_coercion.rb#7
module Datadog::AppSec::Utils::HashCoercion
  class << self
    # A best effort to coerce an object to a hash with methods known to various
    # frameworks with a fallback to standard library.
    #
    # @param object [Object] The object to coerce.
    # @return [Hash, nil] The coerced `Hash` or `nil` if the object is not coercible.
    #
    # source://datadog//lib/datadog/appsec/utils/hash_coercion.rb#13
    def coerce(object); end
  end
end

# source://datadog//lib/datadog/auto_instrument.rb#15
module Datadog::AutoInstrument; end

# Flag to determine if Auto Instrumentation was used
#
# source://datadog//lib/datadog/auto_instrument.rb#17
Datadog::AutoInstrument::LOADED = T.let(T.unsafe(nil), TrueClass)

# Common, lower level, internal code used (or usable) by two or more
# products. It is a dependency of each product. Contrast with Datadog::Kit
# for higher-level features.
#
# source://datadog//lib/datadog/core/deprecations.rb#4
module Datadog::Core
  extend ::Datadog::Core::Deprecations
end

# source://datadog//lib/datadog/core/buffer/random.rb#5
module Datadog::Core::Buffer; end

# Buffer that stores objects, has a maximum size, and
# can be safely used concurrently with CRuby.
#
# Because singular +Array+ operations are thread-safe in CRuby,
# we can implement the buffer without an explicit lock,
# while making the compromise of allowing the buffer to go
# over its maximum limit under extreme circumstances.
#
# On the following scenario:
# * 4.5 million spans/second.
# * Pushed into a single CRubyTraceBuffer from 1000 threads.
#
# This implementation allocates less memory and is faster
# than {Datadog::Core::Buffer::ThreadSafe}.
#
# @see https://github.com/ruby-concurrency/concurrent-ruby/blob/c1114a0c6891d9634f019f1f9fe58dcae8658964/lib/concurrent-ruby/concurrent/array.rb#L23-L27
# @see spec/datadog/benchmark/buffer_benchmark_spec.rb Buffer benchmarks
#
# source://datadog//lib/datadog/core/buffer/cruby.rb#25
class Datadog::Core::Buffer::CRuby < ::Datadog::Core::Buffer::Random
  # Add a new ``item`` in the local queue. This method doesn't block the execution
  # even if the buffer is full. In that case, a random item is discarded.
  #
  # source://datadog//lib/datadog/core/buffer/cruby.rb#32
  def replace!(item); end
end

# A very large number to allow us to effectively
# drop all items when invoking `slice!(i, FIXNUM_MAX)`.
#
# source://datadog//lib/datadog/core/buffer/cruby.rb#28
Datadog::Core::Buffer::CRuby::FIXNUM_MAX = T.let(T.unsafe(nil), Integer)

# Buffer that stores objects. The buffer has a maximum size and when
# the buffer is full, a random object is discarded.
#
# source://datadog//lib/datadog/core/buffer/random.rb#11
class Datadog::Core::Buffer::Random
  # @return [Random] a new instance of Random
  #
  # source://datadog//lib/datadog/core/buffer/random.rb#12
  def initialize(max_size); end

  # Closes this buffer, preventing further pushing.
  # Draining is still allowed.
  #
  # source://datadog//lib/datadog/core/buffer/random.rb#79
  def close; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/buffer/random.rb#83
  def closed?; end

  # A bulk push alternative to +#push+. Use this method if
  # pushing more than one item for efficiency.
  #
  # source://datadog//lib/datadog/core/buffer/random.rb#33
  def concat(items); end

  # Return if the buffer is empty.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/buffer/random.rb#73
  def empty?; end

  # Return the current number of stored items.
  #
  # source://datadog//lib/datadog/core/buffer/random.rb#68
  def length; end

  # Stored items are returned and the local buffer is reset.
  #
  # source://datadog//lib/datadog/core/buffer/random.rb#63
  def pop; end

  # Add a new ``item`` in the local queue. This method doesn't block the execution
  # even if the buffer is full.
  #
  # When the buffer is full, we try to ensure that we are fairly choosing newly
  # pushed items by randomly inserting them into the buffer slots. This discards
  # old items randomly while trying to ensure that recent items are still captured.
  #
  # source://datadog//lib/datadog/core/buffer/random.rb#24
  def push(item); end

  # source://datadog//lib/datadog/core/buffer/random.rb#46
  def unshift(*items); end

  protected

  # source://datadog//lib/datadog/core/buffer/random.rb#126
  def add!(item); end

  # source://datadog//lib/datadog/core/buffer/random.rb#122
  def add_all!(items); end

  # source://datadog//lib/datadog/core/buffer/random.rb#142
  def drain!; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/buffer/random.rb#118
  def full?; end

  # Segment items into two segments: underflow and overflow.
  # Underflow are items that will fit into buffer.
  # Overflow are items that will exceed capacity, after underflow is added.
  # Returns each array, and nil if there is no underflow/overflow.
  #
  # source://datadog//lib/datadog/core/buffer/random.rb#93
  def overflow_segments(items); end

  # source://datadog//lib/datadog/core/buffer/random.rb#130
  def replace!(item); end
end

# Buffer that stores objects, has a maximum size, and
# can be safely used concurrently on any environment.
#
# This implementation uses a {Mutex} around public methods, incurring
# overhead in order to ensure thread-safety.
#
# This is implementation is recommended for non-CRuby environments.
# If using CRuby, {Datadog::Core::Buffer::CRuby} is a faster implementation with minimal compromise.
#
# source://datadog//lib/datadog/core/buffer/thread_safe.rb#16
class Datadog::Core::Buffer::ThreadSafe < ::Datadog::Core::Buffer::Random
  # @return [ThreadSafe] a new instance of ThreadSafe
  #
  # source://datadog//lib/datadog/core/buffer/thread_safe.rb#17
  def initialize(max_size); end

  # source://datadog//lib/datadog/core/buffer/thread_safe.rb#48
  def close; end

  # source://datadog//lib/datadog/core/buffer/thread_safe.rb#29
  def concat(items); end

  # Return if the buffer is empty.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/buffer/thread_safe.rb#39
  def empty?; end

  # Return the current number of stored items.
  #
  # source://datadog//lib/datadog/core/buffer/thread_safe.rb#34
  def length; end

  # Stored items are returned and the local buffer is reset.
  #
  # source://datadog//lib/datadog/core/buffer/thread_safe.rb#44
  def pop; end

  # Add a new ``item`` in the local queue. This method doesn't block the execution
  # even if the buffer is full. In that case, a random item is discarded.
  #
  # source://datadog//lib/datadog/core/buffer/thread_safe.rb#25
  def push(item); end

  # source://datadog//lib/datadog/core/buffer/thread_safe.rb#52
  def synchronize(&block); end
end

# Chunks list of elements into batches
#
# source://datadog//lib/datadog/core/chunker.rb#6
module Datadog::Core::Chunker
  private

  # Chunks a list into batches of at most +max_chunk_size+ elements each.
  #
  # An exception can occur if a single element is too large. That single
  # element will be returned in its own chunk. You have to verify by yourself
  # when such elements are returned.
  #
  # @param list [Enumerable] list of elements
  # @param max_chunk_size [Numeric] maximum acceptable chunk size
  # @return [Enumerable] lazy list of chunks
  #
  # source://datadog//lib/datadog/core/chunker.rb#18
  def chunk_by_size(list, max_chunk_size); end

  class << self
    # Chunks a list into batches of at most +max_chunk_size+ elements each.
    #
    # An exception can occur if a single element is too large. That single
    # element will be returned in its own chunk. You have to verify by yourself
    # when such elements are returned.
    #
    # @param list [Enumerable] list of elements
    # @param max_chunk_size [Numeric] maximum acceptable chunk size
    # @return [Enumerable] lazy list of chunks
    #
    # source://datadog//lib/datadog/core/chunker.rb#18
    def chunk_by_size(list, max_chunk_size); end
  end
end

# Configuration provides a unique access point for configurations
#
# source://datadog//lib/datadog/core/configuration/supported_configurations.rb#8
module Datadog::Core::Configuration
  # source://datadog//lib/datadog/core/configuration.rb#175
  def config_init_logger; end

  # source://datadog//lib/datadog/core/configuration.rb#52
  def configuration; end

  # Sets the attribute configuration
  #
  # @param value the value to set the attribute configuration to.
  #
  # source://datadog//lib/datadog/core/configuration.rb#40
  def configuration=(_arg0); end

  # Get configuration changes applied only to a specific Ruby object, via {.configure_onto}.
  # An example of an object with specific configuration:
  #
  # ```
  # client = Net::HTTP.new(host, port)
  # Datadog.configure_onto(client, service_name: 'api-requests', split_by_domain: true)
  # config = Datadog.configuration_for(client)
  # config[:service_name] # => 'api-requests'
  # config[:split_by_domain] # => true
  # ```
  #
  # @param option [Object] an option to retrieve from the object configuration
  # @param target [Object] the object to receive configuration options
  #
  # source://datadog//lib/datadog/core/configuration.rb#148
  def configuration_for(target, option = T.unsafe(nil)); end

  # Apply global configuration changes to `Datadog`. An example of a {.configure} call:
  #
  # ```
  # Datadog.configure do |c|
  #   c.service = 'my-service'
  #   c.env = 'staging'
  #   # c.diagnostics.debug = true # Enables debug output
  # end
  # ```
  #
  # See {Datadog::Core::Configuration::Settings} for all available options, defaults, and
  # available environment variables for configuration.
  #
  # Only permits access to global configuration settings; others will raise an error.
  # If you wish to configure a setting for a specific Datadog component (e.g. Tracing),
  # use the corresponding `Datadog::COMPONENT.configure` method instead.
  #
  # Because many configuration changes require restarting internal components,
  # invoking {.configure} is the only safe way to change `Datadog` configuration.
  #
  # Successive calls to {.configure} maintain the previous configuration values:
  # configuration is additive between {.configure} calls.
  #
  # The yielded configuration `c` comes pre-populated from environment variables, if
  # any are applicable.
  #
  # @yieldparam c [Datadog::Core::Configuration::Settings] the mutable configuration object
  #
  # source://datadog//lib/datadog/core/configuration.rb#83
  def configure; end

  # Apply configuration changes only to a specific Ruby object.
  #
  # Certain integrations or Datadog features may use these
  # settings to customize behavior for this object.
  #
  # An example of a {.configure_onto} call:
  #
  # ```
  # client = Net::HTTP.new(host, port)
  # Datadog.configure_onto(client, service_name: 'api-requests', split_by_domain: true)
  # ```
  #
  # In this example, it will configure the `client` object with custom options
  # `service_name: 'api-requests', split_by_domain: true`. The `Net::HTTP` integration
  # will then use these customized options when the `client` is used, whereas other
  # clients will use the `service_name: 'http-requests'` configuration provided to the
  # `Datadog.configure` call block.
  #
  # {.configure_onto} is used to separate cases where spans generated by certain objects
  # require exceptional options.
  #
  # The configuration keyword arguments provided should match well known options defined
  # in the integration or feature that would use them.
  #
  # For example, for `Datadog.configure_onto(redis_client, **opts)`, `opts` can be
  # any of the options in the Redis {Datadog::Tracing::Contrib::Redis::Configuration::Settings} class.
  #
  # @param opts [Hash] keyword arguments respective to the integration this object belongs to
  # @param target [Object] the object to receive configuration options
  #
  # source://datadog//lib/datadog/core/configuration.rb#130
  def configure_onto(target, **opts); end

  # Internal {Datadog::Statsd} metrics collection.
  #
  # The list of metrics collected can be found in {Datadog::Core::Diagnostics::Ext::Health::Metrics}.
  #
  # source://datadog//lib/datadog/core/configuration.rb#159
  def health_metrics; end

  # source://datadog//lib/datadog/core/configuration.rb#163
  def logger; end

  # Gracefully shuts down all components.
  #
  # Components will still respond to method calls as usual,
  # but might not internally perform their work after shutdown.
  #
  # This avoids errors being raised across the host application
  # during shutdown, while allowing for graceful decommission of resources.
  #
  # Components won't be automatically reinitialized after a shutdown.
  #
  # source://datadog//lib/datadog/core/configuration.rb#188
  def shutdown!; end

  protected

  # source://datadog//lib/datadog/core/configuration.rb#196
  def components(allow_initialization: T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/core/configuration.rb#258
  def build_components(settings); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration.rb#253
  def components?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration.rb#249
  def configuration?; end

  # Called from our at_exit hook whenever there was a pending Interrupt exception (e.g. typically due to ctrl+c)
  # to print a nice message whenever we're taking a bit longer than usual to finish the process.
  #
  # source://datadog//lib/datadog/core/configuration.rb#310
  def handle_interrupt_shutdown!; end

  # source://datadog//lib/datadog/core/configuration.rb#282
  def logger_without_components; end

  # source://datadog//lib/datadog/core/configuration.rb#293
  def logger_without_configuration; end

  # source://datadog//lib/datadog/core/configuration.rb#264
  def replace_components!(settings, old); end

  # Gracefully shuts down Datadog components and disposes of component references,
  # allowing execution to start anew.
  #
  # In contrast with +#shutdown!+, components will be automatically
  # reinitialized after a reset.
  #
  # Used internally to ensure a clean environment between test runs.
  #
  # source://datadog//lib/datadog/core/configuration.rb#218
  def reset!; end

  # source://datadog//lib/datadog/core/configuration.rb#230
  def safely_synchronize; end
end

# source://datadog//lib/datadog/core/configuration/supported_configurations.rb#311
Datadog::Core::Configuration::ALIASES = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/core/configuration/supported_configurations.rb#325
Datadog::Core::Configuration::ALIAS_TO_CANONICAL = T.let(T.unsafe(nil), Hash)

# Immutable container for the resulting settings
#
# source://datadog//lib/datadog/core/configuration/agent_settings.rb#9
class Datadog::Core::Configuration::AgentSettings
  # @return [AgentSettings] a new instance of AgentSettings
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings.rb#17
  def initialize(adapter: T.unsafe(nil), ssl: T.unsafe(nil), hostname: T.unsafe(nil), port: T.unsafe(nil), uds_path: T.unsafe(nil), timeout_seconds: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/configuration/agent_settings.rb#40
  def ==(other); end

  # Returns the value of attribute adapter.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings.rb#15
  def adapter; end

  # Returns the value of attribute hostname.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings.rb#15
  def hostname; end

  # Returns the value of attribute port.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings.rb#15
  def port; end

  # Returns the value of attribute ssl.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings.rb#15
  def ssl; end

  # Returns the value of attribute timeout_seconds.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings.rb#15
  def timeout_seconds; end

  # Returns the value of attribute uds_path.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings.rb#15
  def uds_path; end

  # source://datadog//lib/datadog/core/configuration/agent_settings.rb#27
  def url; end
end

# IPv6 regular expression from
# https://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
# Does not match IPv4 addresses.
#
# source://datadog//lib/datadog/core/configuration/agent_settings.rb#13
Datadog::Core::Configuration::AgentSettings::IPV6_REGEXP = T.let(T.unsafe(nil), Regexp)

# This class unifies all the different ways that users can configure how we talk to the agent.
#
# It has quite a lot of complexity, but this complexity just reflects the actual complexity we have around our
# configuration today. E.g., this is just all of the complexity regarding agent settings gathered together in a
# single place. As we deprecate more and more of the different ways that these things can be configured,
# this class will reflect that simplification as well.
#
# Whenever there is a conflict (different configurations are provided in different orders), it MUST warn the users
# about it and pick a value based on the following priority: code > environment variable > defaults.
#
# source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#22
class Datadog::Core::Configuration::AgentSettingsResolver
  # @return [AgentSettingsResolver] a new instance of AgentSettingsResolver
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#33
  def initialize(settings, logger: T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#49
  def adapter; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#38
  def call; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#249
  def can_use_uds?; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#57
  def configured_hostname; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#76
  def configured_port; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#95
  def configured_ssl; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#110
  def configured_timeout_seconds; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#126
  def configured_uds_path; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#168
  def hostname; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#308
  def http_scheme?(uri); end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#304
  def log_warning(message); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#29
  def logger; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#227
  def mixed_http_and_uds; end

  # Expected to return nil (not false!) when it's not http
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#313
  def parsed_http_url; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#256
  def parsed_url; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#141
  def parsed_url_ssl?; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#186
  def parsed_url_uds_path; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#281
  def pick_from(*configurations_in_priority_order); end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#172
  def port; end

  # Returns the value of attribute settings.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#29
  def settings; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#220
  def should_use_uds?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#160
  def ssl?; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#176
  def timeout_seconds; end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#147
  def try_parsing_as_integer(value:, friendly_name:); end

  # We only use the default unix socket if it is already present.
  # This is by design, as we still want to use the default host:port if no unix socket is present.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#208
  def uds_fallback; end

  # Unix socket path in the file system
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#200
  def uds_path; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#317
  def unix_scheme?(uri); end

  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#293
  def warn_if_configuration_mismatch(detected_configurations_in_priority_order); end

  class << self
    # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#23
    def call(settings, logger: T.unsafe(nil)); end
  end
end

# Represents a given configuration value and where we got it from
#
# source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#322
class Datadog::Core::Configuration::AgentSettingsResolver::DetectedConfiguration
  # @return [DetectedConfiguration] a new instance of DetectedConfiguration
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#325
  def initialize(friendly_name:, value:); end

  # Returns the value of attribute friendly_name.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#323
  def friendly_name; end

  # Returns the value of attribute value.
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#323
  def value; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/agent_settings_resolver.rb#331
  def value?; end
end

# Agent settings resolver for agentless operations (currently, telemetry
# in agentless mode).
#
# The terminology gets a little confusing here, but transports communicate
# with servers which are - for most components in the tracer - the
# (local) agent. Hence, "agent settings" to refer to where the server
# is located. Telemetry supports sending to the local agent but also
# implements agentless mode where it sends directly to Datadog intake
# endpoints. The agentless mode is configured using different settings,
# and this class produces AgentSettings instances when in agentless mode.
#
# Agentless settings resolver uses the following configuration sources:
#
# 1. url_override constructor parameter, if provided
# 2. Built-in default host/port/TLS settings for the backend
#    intake endpoint
#
# The agentless resolver does NOT use agent settings (since it is
# for agentless operation), specifically it ignores:
#
# - c.agent.host
# - DD_AGENT_HOST
# - c.agent.port
# - DD_AGENT_PORT
#
# However, agentless resolver does respect the timeout specified via
# c.agent.timeout_seconds or DD_TRACE_AGENT_TIMEOUT_SECONDS.
#
# source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#39
class Datadog::Core::Configuration::AgentlessSettingsResolver < ::Datadog::Core::Configuration::AgentSettingsResolver
  # @return [AgentlessSettingsResolver] a new instance of AgentlessSettingsResolver
  #
  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#62
  def initialize(settings, host_prefix:, url_override: T.unsafe(nil), url_override_source: T.unsafe(nil), logger: T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#144
  def can_use_uds?; end

  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#82
  def configured_hostname; end

  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#92
  def configured_port; end

  # Note that this method can return nil
  #
  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#114
  def configured_ssl; end

  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#138
  def configured_uds_path; end

  # Returns the value of attribute host_prefix.
  #
  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#57
  def host_prefix; end

  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#74
  def hostname; end

  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#134
  def mixed_http_and_uds; end

  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#152
  def parsed_url; end

  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#120
  def port; end

  # Note that this method should always return true or false
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#99
  def ssl?; end

  # Returns the value of attribute url_override.
  #
  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#57
  def url_override; end

  # Returns the value of attribute url_override_source.
  #
  # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#57
  def url_override_source; end

  class << self
    # To avoid coupling this class to telemetry, the URL override is
    # taken here as a parameter instead of being read out of
    # c.telemetry.agentless_url_override. For the same reason, the
    # +url_override_source+ parameter should be set to the string
    # "c.telemetry.agentless_url_override".
    #
    # source://datadog//lib/datadog/core/configuration/agentless_settings_resolver.rb#45
    def call(settings, host_prefix:, url_override: T.unsafe(nil), url_override_source: T.unsafe(nil), logger: T.unsafe(nil)); end
  end
end

# Basic configuration behavior
#
# source://datadog//lib/datadog/core/configuration/base.rb#10
module Datadog::Core::Configuration::Base
  include ::Datadog::Core::Configuration::Options::InstanceMethods
  include ::Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Base::InstanceMethods

  mixes_in_class_methods ::Datadog::Core::Configuration::Options::ClassMethods
  mixes_in_class_methods ::Datadog::Core::Configuration::Base::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/core/configuration/base.rb#11
    def included(base); end
  end
end

# Class methods for configuration
#
# source://datadog//lib/datadog/core/configuration/base.rb#20
module Datadog::Core::Configuration::Base::ClassMethods
  protected

  # Allows subgroupings of settings to be defined.
  # e.g. `settings :foo { option :bar }` --> `config.foo.bar`
  #
  # @param name [Symbol] option name. Methods will be created based on this name.
  #
  # source://datadog//lib/datadog/core/configuration/base.rb#26
  def settings(name, &block); end

  private

  # source://datadog//lib/datadog/core/configuration/base.rb#43
  def new_settings_class(name, &block); end
end

# Instance methods for configuration
#
# source://datadog//lib/datadog/core/configuration/base.rb#53
module Datadog::Core::Configuration::Base::InstanceMethods
  # source://datadog//lib/datadog/core/configuration/base.rb#54
  def initialize(options = T.unsafe(nil)); end

  # @yield [_self]
  # @yieldparam _self [Datadog::Core::Configuration::Base::InstanceMethods] the object that the method was called on
  #
  # source://datadog//lib/datadog/core/configuration/base.rb#58
  def configure(opts = T.unsafe(nil)); end

  # Retrieves a nested option from a list of symbols
  #
  # @raise [ArgumentError]
  #
  # source://datadog//lib/datadog/core/configuration/base.rb#76
  def dig(*options); end

  # source://datadog//lib/datadog/core/configuration/base.rb#84
  def reset!; end

  # source://datadog//lib/datadog/core/configuration/base.rb#71
  def to_h; end
end

# We use a separate lock when reading the @components, so that they continue to be accessible during reconfiguration.
# This was needed because we ran into several issues where we still needed to read the old
# components while the COMPONENTS_WRITE_LOCK was being held (see https://github.com/DataDog/dd-trace-rb/pull/1387
# and https://github.com/DataDog/dd-trace-rb/pull/1373#issuecomment-799593022 ).
#
# Technically on MRI we could get away without this lock, but on non-MRI Rubies, we may run into issues because
# we fall into the "UnsafeDCLFactory" case of https://shipilev.net/blog/2014/safe-public-construction/ .
# Specifically, on JRuby reads from the @components do NOT have volatile semantics, and on TruffleRuby they do
# BUT just as an implementation detail, see https://github.com/jruby/jruby/wiki/Concurrency-in-jruby#volatility and
# https://github.com/DataDog/dd-trace-rb/pull/1329#issuecomment-776750377 .
# Concurrency is hard.
#
# source://datadog//lib/datadog/core/configuration.rb#37
Datadog::Core::Configuration::COMPONENTS_READ_LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# Used to ensure that @components initialization/reconfiguration is performed one-at-a-time, by a single thread.
#
# This is important because components can end up being accessed from multiple application threads (for instance on
# a threaded webserver), and we don't want their initialization to clash (for instance, starting two profilers...).
#
# Note that a Mutex **IS NOT** reentrant: the same thread cannot grab the same Mutex more than once.
# This means below we are careful not to nest calls to methods that would trigger initialization and grab the lock.
#
# Every method that directly or indirectly mutates @components should be holding the lock (through
# #safely_synchronize) while doing so.
#
# source://datadog//lib/datadog/core/configuration.rb#23
Datadog::Core::Configuration::COMPONENTS_WRITE_LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# Global components for the trace library.
#
# source://datadog//lib/datadog/core/configuration/components.rb#27
class Datadog::Core::Configuration::Components
  # @return [Components] a new instance of Components
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#95
  def initialize(settings); end

  # Returns the value of attribute agent_info.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def agent_info; end

  # Returns the value of attribute appsec.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def appsec; end

  # Returns the value of attribute crashtracker.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def crashtracker; end

  # Returns the value of attribute dynamic_instrumentation.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def dynamic_instrumentation; end

  # Returns the value of attribute error_tracking.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def error_tracking; end

  # Returns the value of attribute health_metrics.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def health_metrics; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def logger; end

  # Returns the value of attribute profiler.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def profiler; end

  # Hot-swaps with a new sampler.
  # This operation acquires the Components lock to ensure
  # there is no concurrent modification of the sampler.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#138
  def reconfigure_sampler(settings = T.unsafe(nil)); end

  # Returns the value of attribute remote.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def remote; end

  # Returns the value of attribute runtime_metrics.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def runtime_metrics; end

  # Returns the value of attribute settings.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def settings; end

  # Shuts down all the components in use.
  # If it has another instance to compare to, it will compare
  # and avoid tearing down parts still in use.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#178
  def shutdown!(replacement = T.unsafe(nil)); end

  # Starts up components
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#144
  def startup!(settings, old_state: T.unsafe(nil)); end

  # Returns the current state of various components.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#231
  def state; end

  # Returns the value of attribute telemetry.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def telemetry; end

  # Returns the value of attribute tracer.
  #
  # source://datadog//lib/datadog/core/configuration/components.rb#80
  def tracer; end

  class << self
    # source://datadog//lib/datadog/core/configuration/components.rb#68
    def build_crashtracker(settings, agent_settings, logger:); end

    # source://datadog//lib/datadog/core/configuration/components.rb#29
    def build_health_metrics(settings, logger, telemetry); end

    # source://datadog//lib/datadog/core/configuration/components.rb#37
    def build_logger(settings); end

    # source://datadog//lib/datadog/core/configuration/components.rb#44
    def build_runtime_metrics(settings, logger, telemetry); end

    # source://datadog//lib/datadog/core/configuration/components.rb#53
    def build_runtime_metrics_worker(settings, logger, telemetry); end

    # source://datadog//lib/datadog/core/configuration/components.rb#64
    def build_telemetry(settings, agent_settings, logger); end
  end
end

# Stores the state of component tree when replacing the tree.
#
# source://datadog//lib/datadog/core/configuration/components_state.rb#7
class Datadog::Core::Configuration::ComponentsState
  # @return [ComponentsState] a new instance of ComponentsState
  #
  # source://datadog//lib/datadog/core/configuration/components_state.rb#8
  def initialize(telemetry_enabled:, remote_started:); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/components_state.rb#17
  def remote_started?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/components_state.rb#13
  def telemetry_enabled?; end
end

# source://datadog//lib/datadog/core/configuration/config_helper.rb#9
class Datadog::Core::Configuration::ConfigHelper
  # @return [ConfigHelper] a new instance of ConfigHelper
  #
  # source://datadog//lib/datadog/core/configuration/config_helper.rb#10
  def initialize(source_env: T.unsafe(nil), supported_configurations: T.unsafe(nil), aliases: T.unsafe(nil), alias_to_canonical: T.unsafe(nil), raise_on_unknown_env_var: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/configuration/config_helper.rb#24
  def [](name); end

  # @raise [KeyError]
  #
  # source://datadog//lib/datadog/core/configuration/config_helper.rb#28
  def fetch(name, default_value = T.unsafe(nil)); end

  # Returns the environment variable value if the environment variable is a supported Datadog configuration (starts with DD_ or OTEL_)
  # or if it is not a Datadog configuration. Otherwise, it returns nil.
  #
  # @param default_value [String, nil] Default value to return if the environment variable is not set
  # @param name [String] Environment variable name
  # @param source_env [Hash[String, String]] Environment variables to use
  # @raise [RuntimeError] if the configuration is not supported
  # @return [String, nil] The environment variable value
  #
  # source://datadog//lib/datadog/core/configuration/config_helper.rb#55
  def get_environment_variable(name, default_value = T.unsafe(nil), source_env: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/config_helper.rb#43
  def has_key?(name); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/config_helper.rb#44
  def include?(name); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/config_helper.rb#39
  def key?(name); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/config_helper.rb#45
  def member?(name); end

  # Only used in error message creation. Match get_environment_variable logic to return the resolved environment variable name.
  #
  # source://datadog//lib/datadog/core/configuration/config_helper.rb#83
  def resolve_env(name, source_env: T.unsafe(nil)); end
end

# Anchor object that represents an undefined default value.
# This is necessary because `nil` is a valid default value.
#
# source://datadog//lib/datadog/core/configuration/config_helper.rb#95
Datadog::Core::Configuration::ConfigHelper::UNSET = T.let(T.unsafe(nil), Object)

# source://datadog//lib/datadog/core/configuration/supported_configurations.rb#322
Datadog::Core::Configuration::DEPRECATIONS = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/core/configuration/deprecations.rb#10
module Datadog::Core::Configuration::Deprecations
  class << self
    # source://datadog//lib/datadog/core/configuration/deprecations.rb#13
    def log_deprecations_from_all_sources(logger, deprecations: T.unsafe(nil), alias_to_canonical: T.unsafe(nil)); end

    private

    # source://datadog//lib/datadog/core/configuration/deprecations.rb#23
    def log_deprecated_environment_variables(logger, source_env, source_name, deprecations, alias_to_canonical); end
  end
end

# source://datadog//lib/datadog/core/configuration/deprecations.rb#11
Datadog::Core::Configuration::Deprecations::LOG_DEPRECATIONS_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# Constants for configuration settings
# e.g. Env vars, default values, enums, etc...
#
# source://datadog//lib/datadog/core/configuration/ext.rb#8
module Datadog::Core::Configuration::Ext; end

# source://datadog//lib/datadog/core/configuration/ext.rb#20
module Datadog::Core::Configuration::Ext::APM; end

# source://datadog//lib/datadog/core/configuration/ext.rb#21
Datadog::Core::Configuration::Ext::APM::ENV_TRACING_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/configuration/ext.rb#24
module Datadog::Core::Configuration::Ext::Agent; end

# source://datadog//lib/datadog/core/configuration/ext.rb#25
Datadog::Core::Configuration::Ext::Agent::ENV_DEFAULT_HOST = T.let(T.unsafe(nil), String)

# Some env vars have "trace" in them, but they apply to all products
#
# source://datadog//lib/datadog/core/configuration/ext.rb#27
Datadog::Core::Configuration::Ext::Agent::ENV_DEFAULT_PORT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/configuration/ext.rb#28
Datadog::Core::Configuration::Ext::Agent::ENV_DEFAULT_TIMEOUT_SECONDS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/configuration/ext.rb#29
Datadog::Core::Configuration::Ext::Agent::ENV_DEFAULT_URL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/configuration/ext.rb#31
module Datadog::Core::Configuration::Ext::Agent::HTTP; end

# source://datadog//lib/datadog/core/configuration/ext.rb#32
Datadog::Core::Configuration::Ext::Agent::HTTP::ADAPTER = T.let(T.unsafe(nil), Symbol)

# source://datadog//lib/datadog/core/configuration/ext.rb#33
Datadog::Core::Configuration::Ext::Agent::HTTP::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/configuration/ext.rb#34
Datadog::Core::Configuration::Ext::Agent::HTTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/core/configuration/ext.rb#36
Datadog::Core::Configuration::Ext::Agent::HTTP::DEFAULT_TIMEOUT_SECONDS = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/core/configuration/ext.rb#35
Datadog::Core::Configuration::Ext::Agent::HTTP::DEFAULT_USE_SSL = T.let(T.unsafe(nil), FalseClass)

# source://datadog//lib/datadog/core/configuration/ext.rb#40
module Datadog::Core::Configuration::Ext::Agent::UnixSocket; end

# source://datadog//lib/datadog/core/configuration/ext.rb#41
Datadog::Core::Configuration::Ext::Agent::UnixSocket::ADAPTER = T.let(T.unsafe(nil), Symbol)

# source://datadog//lib/datadog/core/configuration/ext.rb#42
Datadog::Core::Configuration::Ext::Agent::UnixSocket::DEFAULT_PATH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/configuration/ext.rb#43
Datadog::Core::Configuration::Ext::Agent::UnixSocket::DEFAULT_TIMEOUT_SECONDS = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/core/configuration/ext.rb#10
module Datadog::Core::Configuration::Ext::Diagnostics; end

# source://datadog//lib/datadog/core/configuration/ext.rb#11
Datadog::Core::Configuration::Ext::Diagnostics::ENV_DEBUG_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/configuration/ext.rb#12
Datadog::Core::Configuration::Ext::Diagnostics::ENV_HEALTH_METRICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/configuration/ext.rb#13
Datadog::Core::Configuration::Ext::Diagnostics::ENV_STARTUP_LOGS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/configuration/ext.rb#16
module Datadog::Core::Configuration::Ext::Metrics; end

# source://datadog//lib/datadog/core/configuration/ext.rb#17
Datadog::Core::Configuration::Ext::Metrics::ENV_DEFAULT_PORT = T.let(T.unsafe(nil), String)

# Represents an instance of an integration configuration option
#
# source://datadog//lib/datadog/core/configuration/option.rb#11
class Datadog::Core::Configuration::Option
  # @return [Option] a new instance of Option
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#66
  def initialize(definition, context); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#176
  def default_precedence?; end

  # source://datadog//lib/datadog/core/configuration/option.rb#168
  def default_value; end

  # The definition object that matches this option.
  #
  # @return [Configuration::OptionDefinition]
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#18
  def definition; end

  # source://datadog//lib/datadog/core/configuration/option.rb#137
  def get; end

  # Returns the value of attribute precedence_set.
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#18
  def precedence_set; end

  # source://datadog//lib/datadog/core/configuration/option.rb#151
  def reset; end

  # Overrides the current value for this option if the `precedence` is equal or higher than
  # the previously set value.
  # The first call to `#set` will always store the value regardless of precedence.
  #
  # @param precedence [Precedence] from what precedence order this new value comes from
  # @param value [Object] the new value to be associated with this option
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#86
  def set(value, precedence: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/configuration/option.rb#108
  def unset(precedence); end

  private

  # source://datadog//lib/datadog/core/configuration/option.rb#182
  def coerce_env_variable(value); end

  # source://datadog//lib/datadog/core/configuration/option.rb#300
  def context_eval(&block); end

  # source://datadog//lib/datadog/core/configuration/option.rb#296
  def context_exec(*args, &block); end

  # source://datadog//lib/datadog/core/configuration/option.rb#344
  def get_value_from(source_env, source_name); end

  # source://datadog//lib/datadog/core/configuration/option.rb#329
  def get_value_from_env; end

  # Directly manipulates the current value and currently set precedence.
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#283
  def internal_set(value, precedence); end

  # source://datadog//lib/datadog/core/configuration/option.rb#313
  def set_customer_stable_config_value; end

  # source://datadog//lib/datadog/core/configuration/option.rb#304
  def set_default_value; end

  # source://datadog//lib/datadog/core/configuration/option.rb#308
  def set_env_value; end

  # source://datadog//lib/datadog/core/configuration/option.rb#321
  def set_fleet_stable_config_value; end

  # source://datadog//lib/datadog/core/configuration/option.rb#256
  def validate(type, value); end

  # source://datadog//lib/datadog/core/configuration/option.rb#226
  def validate_type(value); end
end

# For errors caused by illegal option declarations
#
# source://datadog//lib/datadog/core/configuration/option.rb#223
class Datadog::Core::Configuration::Option::InvalidDefinitionError < ::StandardError; end

# Option setting precedence.
#
# source://datadog//lib/datadog/core/configuration/option.rb#21
module Datadog::Core::Configuration::Option::Precedence; end

# Configuration that comes from default values
#
# source://datadog//lib/datadog/core/configuration/option.rb#60
Datadog::Core::Configuration::Option::Precedence::DEFAULT = T.let(T.unsafe(nil), Datadog::Core::Configuration::Option::Precedence::Value)

# Configuration provided via environment variable
#
# source://datadog//lib/datadog/core/configuration/option.rb#54
Datadog::Core::Configuration::Option::Precedence::ENVIRONMENT = T.let(T.unsafe(nil), Datadog::Core::Configuration::Option::Precedence::Value)

# Configuration provided by fleet managed stable config
#
# source://datadog//lib/datadog/core/configuration/option.rb#51
Datadog::Core::Configuration::Option::Precedence::FLEET_STABLE = T.let(T.unsafe(nil), Datadog::Core::Configuration::Option::Precedence::Value)

# All precedences, sorted from highest to lowest
#
# source://datadog//lib/datadog/core/configuration/option.rb#63
Datadog::Core::Configuration::Option::Precedence::LIST = T.let(T.unsafe(nil), Array)

# Configuration provided by local stable config file
#
# source://datadog//lib/datadog/core/configuration/option.rb#57
Datadog::Core::Configuration::Option::Precedence::LOCAL_STABLE = T.let(T.unsafe(nil), Datadog::Core::Configuration::Option::Precedence::Value)

# Configuration provided in Ruby code, in this same process
#
# source://datadog//lib/datadog/core/configuration/option.rb#48
Datadog::Core::Configuration::Option::Precedence::PROGRAMMATIC = T.let(T.unsafe(nil), Datadog::Core::Configuration::Option::Precedence::Value)

# Remote configuration provided through the Datadog app.
#
# source://datadog//lib/datadog/core/configuration/option.rb#45
Datadog::Core::Configuration::Option::Precedence::REMOTE_CONFIGURATION = T.let(T.unsafe(nil), Datadog::Core::Configuration::Option::Precedence::Value)

# Represents an Option precedence level.
# Each precedence has a `numeric` value; higher values means higher precedence.
# `name` is for inspection purposes only.
#
# source://datadog//lib/datadog/core/configuration/option.rb#26
class Datadog::Core::Configuration::Option::Precedence::Value
  include ::Comparable

  # @return [Value] a new instance of Value
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#31
  def initialize(numeric, name, origin); end

  # source://datadog//lib/datadog/core/configuration/option.rb#37
  def <=>(other); end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#29
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#29
  def name=(_arg0); end

  # Returns the value of attribute numeric.
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#29
  def numeric; end

  # Sets the attribute numeric
  #
  # @param value the value to set the attribute numeric to.
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#29
  def numeric=(_arg0); end

  # Returns the value of attribute origin.
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#29
  def origin; end

  # Sets the attribute origin
  #
  # @param value the value to set the attribute origin to.
  #
  # source://datadog//lib/datadog/core/configuration/option.rb#29
  def origin=(_arg0); end
end

# Anchor object that represents a value that is not set.
# This is necessary because `nil` is a valid value to be set.
#
# source://datadog//lib/datadog/core/configuration/option.rb#363
Datadog::Core::Configuration::Option::UNSET = T.let(T.unsafe(nil), Object)

# Represents a definition for an integration configuration option
#
# source://datadog//lib/datadog/core/configuration/option_definition.rb#9
class Datadog::Core::Configuration::OptionDefinition
  # @return [OptionDefinition] a new instance of OptionDefinition
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#24
  def initialize(name, meta, &block); end

  # Returns the value of attribute after_set.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#12
  def after_set; end

  # Creates a new Option, bound to the context provided.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#38
  def build(context); end

  # Returns the value of attribute default.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#12
  def default; end

  # Returns the value of attribute default_proc.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#12
  def default_proc; end

  # Returns the value of attribute env.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#12
  def env; end

  # Returns the value of attribute env_parser.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#12
  def env_parser; end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#12
  def name; end

  # Returns the value of attribute resetter.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#12
  def resetter; end

  # Returns the value of attribute setter.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#12
  def setter; end

  # Returns the value of attribute type.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#12
  def type; end

  # Returns the value of attribute type_options.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#12
  def type_options; end
end

# Acts as DSL for building OptionDefinitions
#
# source://datadog//lib/datadog/core/configuration/option_definition.rb#44
class Datadog::Core::Configuration::OptionDefinition::Builder
  # @return [Builder] a new instance of Builder
  # @yield [_self]
  # @yieldparam _self [Datadog::Core::Configuration::OptionDefinition::Builder] the object that the method was called on
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#50
  def initialize(name, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/configuration/option_definition.rb#93
  def after_set(&block); end

  # For applying options for OptionDefinition
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#113
  def apply_options!(options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/configuration/option_definition.rb#81
  def default(value = T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/core/configuration/option_definition.rb#85
  def default_proc(&block); end

  # standard:disable Style/TrivialAccessors
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#71
  def env(value); end

  # Invoked when the option is first read, and {#env} is defined.
  # The block provided is only invoked if the environment variable is present (not-nil).
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#77
  def env_parser(&block); end

  # source://datadog//lib/datadog/core/configuration/option_definition.rb#89
  def helper(name, *_args, &block); end

  # Returns the value of attribute helpers.
  #
  # source://datadog//lib/datadog/core/configuration/option_definition.rb#47
  def helpers; end

  # source://datadog//lib/datadog/core/configuration/option_definition.rb#130
  def meta; end

  # source://datadog//lib/datadog/core/configuration/option_definition.rb#97
  def resetter(&block); end

  # source://datadog//lib/datadog/core/configuration/option_definition.rb#101
  def setter(&block); end

  # source://datadog//lib/datadog/core/configuration/option_definition.rb#126
  def to_definition; end

  # source://datadog//lib/datadog/core/configuration/option_definition.rb#105
  def type(value, nilable: T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/core/configuration/option_definition.rb#146
  def validate_options!; end
end

# source://datadog//lib/datadog/core/configuration/option_definition.rb#45
class Datadog::Core::Configuration::OptionDefinition::Builder::InvalidOptionError < ::StandardError; end

# source://datadog//lib/datadog/core/configuration/option_definition.rb#10
Datadog::Core::Configuration::OptionDefinition::IDENTITY = T.let(T.unsafe(nil), Proc)

# Behavior for a configuration object that has options
#
# source://datadog//lib/datadog/core/configuration/options.rb#10
module Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Options::InstanceMethods

  mixes_in_class_methods ::Datadog::Core::Configuration::Options::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/core/configuration/options.rb#11
    def included(base); end
  end
end

# Class behavior for a configuration object with options
#
# source://datadog//lib/datadog/core/configuration/options.rb#18
module Datadog::Core::Configuration::Options::ClassMethods
  # source://datadog//lib/datadog/core/configuration/options.rb#19
  def options; end

  protected

  # source://datadog//lib/datadog/core/configuration/options.rb#26
  def option(name, meta = T.unsafe(nil), &block); end

  private

  # source://datadog//lib/datadog/core/configuration/options.rb#41
  def default_helpers(name); end

  # source://datadog//lib/datadog/core/configuration/options.rb#59
  def define_helpers(helpers); end
end

# Instance behavior for a configuration object with options
#
# source://datadog//lib/datadog/core/configuration/options.rb#70
module Datadog::Core::Configuration::Options::InstanceMethods
  # source://datadog//lib/datadog/core/configuration/options.rb#83
  def get_option(name); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/options.rb#92
  def option_defined?(name); end

  # source://datadog//lib/datadog/core/configuration/options.rb#71
  def options; end

  # source://datadog//lib/datadog/core/configuration/options.rb#102
  def options_hash; end

  # source://datadog//lib/datadog/core/configuration/options.rb#87
  def reset_option(name); end

  # source://datadog//lib/datadog/core/configuration/options.rb#108
  def reset_options!; end

  # source://datadog//lib/datadog/core/configuration/options.rb#75
  def set_option(name, value, precedence: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/configuration/options.rb#79
  def unset_option(name, precedence: T.unsafe(nil)); end

  # Is this option's value the default fallback value?
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/configuration/options.rb#97
  def using_default?(name); end

  private

  # @raise [InvalidOptionError]
  #
  # source://datadog//lib/datadog/core/configuration/options.rb#125
  def assert_valid_option!(name); end

  # Ensure option DSL is loaded
  #
  # source://datadog//lib/datadog/core/configuration/options.rb#115
  def resolve_option(name); end
end

# source://datadog//lib/datadog/core/configuration/options.rb#130
class Datadog::Core::Configuration::Options::InvalidOptionError < ::StandardError; end

# source://datadog//lib/datadog/core/configuration/supported_configurations.rb#9
Datadog::Core::Configuration::SUPPORTED_CONFIGURATIONS = T.let(T.unsafe(nil), Hash)

# Global configuration settings for the Datadog library.
# standard:disable Metrics/BlockLength
#
# source://datadog//lib/datadog/core/configuration/settings.rb#22
class Datadog::Core::Configuration::Settings
  include ::Datadog::Core::Configuration::Base
  include ::Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Options::InstanceMethods
  include ::Datadog::Core::Configuration::Base::InstanceMethods
  extend ::Datadog::Core::Configuration::Options::ClassMethods
  extend ::Datadog::Core::Configuration::Base::ClassMethods
  extend ::Datadog::Tracing::Configuration::Settings
  extend ::Datadog::AppSec::Configuration::Settings
  extend ::Datadog::DI::Configuration::Settings
  extend ::Datadog::ErrorTracking::Configuration::Settings

  # @return [Settings] a new instance of Settings
  #
  # source://datadog//lib/datadog/core/configuration/settings.rb#26
  def initialize(*_); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#54
  def agent; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#54
  def agent=(value); end

  # Datadog API key.
  #
  # For internal use only.
  #
  # @return [String, nil]
  #
  # source://datadog//lib/datadog/core/configuration/settings.rb#104
  def api_key; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#104
  def api_key=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#1008
  def apm; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#1008
  def apm=(value); end

  # source://datadog//lib/datadog/appsec.rb#50
  def appsec; end

  # source://datadog//lib/datadog/appsec.rb#50
  def appsec=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#997
  def crashtracking; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#997
  def crashtracking=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#114
  def diagnostics; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#114
  def diagnostics=(value); end

  # source://datadog//lib/datadog/di.rb#19
  def dynamic_instrumentation; end

  # source://datadog//lib/datadog/di.rb#19
  def dynamic_instrumentation=(value); end

  # The `env` tag in Datadog. Use it to separate out your staging, development, and production environments.
  #
  # @return [String, nil]
  # @see https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging
  #
  # source://datadog//lib/datadog/core/configuration/settings.rb#166
  def env; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#166
  def env=(value); end

  # source://datadog//lib/datadog/error_tracking.rb#16
  def error_tracking; end

  # source://datadog//lib/datadog/error_tracking.rb#16
  def error_tracking=(value); end

  # The monotonic clock time provider used by Datadog. This option is internal and is used by `datadog-ci`
  # gem to avoid traces' durations being skewed by timecop.
  #
  # It must respect the interface of [Datadog::Core::Utils::Time#get_time] method.
  #
  # For [Timecop](https://rubygems.org/gems/timecop), for example,
  # `->(unit = :float_second) { ::Process.clock_gettime_without_mock(::Process::CLOCK_MONOTONIC, unit) }`
  # allows Datadog features to use the real monotonic time when time is frozen with
  # `Timecop.mock_process_clock = true`.
  #
  # @return [Proc<Numeric>]
  #
  # source://datadog//lib/datadog/core/configuration/settings.rb#760
  def get_time_provider; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#760
  def get_time_provider=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#175
  def health_metrics; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#175
  def health_metrics=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#200
  def logger; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#200
  def logger=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#223
  def profiling; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#223
  def profiling=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#941
  def remote; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#941
  def remote=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#596
  def runtime_metrics; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#596
  def runtime_metrics=(value); end

  # The `service` tag in Datadog. Use it to group related traces into a service.
  #
  # @return [String]
  # @see https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging
  #
  # source://datadog//lib/datadog/core/configuration/settings.rb#621
  def service; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#621
  def service=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#621
  def service_without_fallback; end

  # The Datadog site host to send data to.
  # By default, data is sent to the Datadog US site: `app.datadoghq.com`.
  #
  # If your organization is on another site, you must update this value to the new site.
  #
  # For internal use only.
  #
  # @return [String, nil]
  # @see https://docs.datadoghq.com/agent/troubleshooting/site/
  #
  # source://datadog//lib/datadog/core/configuration/settings.rb#648
  def site; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#648
  def site=(value); end

  # Default tags
  #
  # These tags are used by all Datadog products, when applicable.
  # e.g. trace spans, profiles, etc.
  #
  # @return [Hash<String,String>]
  #
  # source://datadog//lib/datadog/core/configuration/settings.rb#659
  def tags; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#659
  def tags=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#787
  def telemetry; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#787
  def telemetry=(value); end

  # The time provider used by Datadog. It must respect the interface of [Time](https://ruby-doc.org/core-3.0.1/Time.html).
  #
  # When testing, it can be helpful to use a different time provider.
  #
  # For [Timecop](https://rubygems.org/gems/timecop), for example, `->{ Time.now_without_mock_time }`
  # allows Datadog features to use the real wall time when time is frozen.
  #
  # @return [Proc<Time>]
  #
  # source://datadog//lib/datadog/core/configuration/settings.rb#731
  def time_now_provider; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#731
  def time_now_provider=(value); end

  # source://datadog//lib/datadog/core/configuration/settings.rb#1032
  def tracing; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#1032
  def tracing=(value); end

  # The `version` tag in Datadog. Use it to enable [Deployment Tracking](https://docs.datadoghq.com/tracing/deployment_tracking/).
  #
  # @return [String, nil]
  # @see https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging
  #
  # source://datadog//lib/datadog/core/configuration/settings.rb#779
  def version; end

  # source://datadog//lib/datadog/core/configuration/settings.rb#779
  def version=(value); end
end

# Import config from config files (fleet automation)
#
# source://datadog//lib/datadog/core/configuration/stable_config.rb#9
module Datadog::Core::Configuration::StableConfig
  class << self
    # source://datadog//lib/datadog/core/configuration/stable_config.rb#20
    def configuration; end

    # source://datadog//lib/datadog/core/configuration/stable_config.rb#12
    def extract_configuration; end

    # source://datadog//lib/datadog/core/configuration/stable_config.rb#24
    def log_result(logger); end
  end
end

class Datadog::Core::Configuration::StableConfig::Configurator
  # source://datadog//lib/datadog/core.rb#18
  def get; end
end

# source://datadog//lib/datadog/core/configuration/stable_config.rb#10
Datadog::Core::Configuration::StableConfig::LOG_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

module Datadog::Core::Configuration::StableConfig::Testing
  class << self
    # source://datadog//lib/datadog/core.rb#18
    def with_fleet_path(_arg0, _arg1); end

    # source://datadog//lib/datadog/core.rb#18
    def with_local_path(_arg0, _arg1); end
  end
end

class Datadog::Core::Configuration::StableConfigLoggedResult; end

# source://datadog//lib/datadog/core/contrib/rails/utils.rb#5
module Datadog::Core::Contrib; end

# source://datadog//lib/datadog/core/contrib/rails/utils.rb#6
module Datadog::Core::Contrib::Rails; end

# common utilities for Rails
#
# source://datadog//lib/datadog/core/contrib/rails/utils.rb#8
module Datadog::Core::Contrib::Rails::Utils
  class << self
    # source://datadog//lib/datadog/core/contrib/rails/utils.rb#9
    def app_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/contrib/rails/utils.rb#17
    def railtie_supported?; end
  end
end

# source://datadog//lib/datadog/core/crashtracking/tag_builder.rb#8
module Datadog::Core::Crashtracking; end

# Used to report Ruby VM crashes.
#
# NOTE: The crashtracker native state is a singleton;
# so even if you create multiple instances of `Crashtracking::Component` and start them,
# it only works as "last writer wins". Same for stop -- there's only one state, so calling stop
# on it will stop the crash tracker, regardless of which instance started it.
#
# Methods prefixed with _native_ are implemented in `crashtracker.c`
#
# source://datadog//lib/datadog/core/crashtracking/component.rb#20
class Datadog::Core::Crashtracking::Component
  # @return [Component] a new instance of Component
  #
  # source://datadog//lib/datadog/core/crashtracking/component.rb#48
  def initialize(tags:, agent_base_url:, ld_library_path:, path_to_crashtracking_receiver_binary:, logger:); end

  # source://datadog//lib/datadog/core/crashtracking/component.rb#56
  def start; end

  # source://datadog//lib/datadog/core/crashtracking/component.rb#77
  def stop; end

  # source://datadog//lib/datadog/core/crashtracking/component.rb#71
  def update_on_fork(settings: T.unsafe(nil)); end

  private

  # Returns the value of attribute agent_base_url.
  #
  # source://datadog//lib/datadog/core/crashtracking/component.rb#86
  def agent_base_url; end

  # Returns the value of attribute ld_library_path.
  #
  # source://datadog//lib/datadog/core/crashtracking/component.rb#86
  def ld_library_path; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/crashtracking/component.rb#86
  def logger; end

  # Returns the value of attribute path_to_crashtracking_receiver_binary.
  #
  # source://datadog//lib/datadog/core/crashtracking/component.rb#86
  def path_to_crashtracking_receiver_binary; end

  # source://datadog//lib/datadog/core/crashtracking/component.rb#88
  def start_or_update_on_fork(action:, tags:); end

  # Returns the value of attribute tags.
  #
  # source://datadog//lib/datadog/core/crashtracking/component.rb#86
  def tags; end

  class << self
    # source://datadog//lib/datadog/core.rb#18
    def _native_start_or_update_on_fork(*_arg0); end

    # source://datadog//lib/datadog/core.rb#18
    def _native_stop; end

    # source://datadog//lib/datadog/core/crashtracking/component.rb#23
    def build(settings, agent_settings, logger:); end
  end
end

# source://datadog//lib/datadog/core/crashtracking/component.rb#21
Datadog::Core::Crashtracking::Component::ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# This module builds a hash of tags
#
# source://datadog//lib/datadog/core/crashtracking/tag_builder.rb#10
module Datadog::Core::Crashtracking::TagBuilder
  class << self
    # source://datadog//lib/datadog/core/crashtracking/tag_builder.rb#11
    def call(settings); end
  end
end

# Used to access ddsketch APIs.
# APIs in this class are implemented as native code.
class Datadog::Core::DDSketch
  # source://datadog//lib/datadog/core.rb#18
  def add(_arg0); end

  # source://datadog//lib/datadog/core.rb#18
  def add_with_count(_arg0, _arg1); end

  # source://datadog//lib/datadog/core.rb#18
  def count; end

  # source://datadog//lib/datadog/core.rb#18
  def encode; end
end

# Contains behavior for handling deprecated functions in the codebase.
#
# source://datadog//lib/datadog/core/deprecations.rb#6
module Datadog::Core::Deprecations
  # Records the occurrence of a deprecated operation in this library.
  #
  # Currently, these operations are logged to `Datadog.logger` at `warn` level.
  #
  # `disallowed_next_major` adds a message informing that the deprecated operation
  # won't be allowed in the next major release.
  #
  # @param disallowed_next_major [Boolean] whether this deprecation will be enforced in the next major release.
  # @param key [Object] A unique key for the deprecation. Only the first message with the same key will be logged.
  # @yieldreturn [String] a String with the lazily evaluated deprecation message.
  #
  # source://datadog//lib/datadog/core/deprecations.rb#17
  def log_deprecation(disallowed_next_major: T.unsafe(nil), key: T.unsafe(nil), logger: T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/core/deprecations.rb#44
  def deprecation_logged!(key); end

  # Determines whether a deprecation message should be logged.
  #
  # Internal use only.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/deprecations.rb#37
  def log_deprecation?(key); end

  # Tracks what deprecation warnings have already been logged
  #
  # Internal use only.
  #
  # source://datadog//lib/datadog/core/deprecations.rb#53
  def logged_deprecations; end
end

# source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#9
module Datadog::Core::Diagnostics; end

# Collects environment information for Core diagnostic logging
#
# source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#60
module Datadog::Core::Diagnostics::EnvironmentCollector
  class << self
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#62
    def collect_config!; end

    # @return [String] current time in ISO8601 format
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#81
    def date; end

    # @return [String] configured application version
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#119
    def dd_version; end

    # @return [Boolean, nil] debug mode enabled in configuration
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#124
    def debug; end

    # @return [String] configured application environment
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#109
    def env; end

    # @return [Boolean, nil] health metrics enabled in configuration
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#156
    def health_metrics_enabled; end

    # @return [String] "ruby"
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#97
    def lang; end

    # Supported Ruby language version.
    # Will be distinct from VM version for non-MRI environments.
    #
    # @return [String]
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#104
    def lang_version; end

    # Best portable guess of OS information.
    #
    # @return [String] platform string
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#87
    def os_name; end

    # @return [Boolean, nil] runtime metrics enabled in configuration
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#137
    def runtime_metrics_enabled; end

    # @return [String] configured application service name
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#114
    def service; end

    # @return [Hash, nil] concatenated list of global tracer tags configured
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#129
    def tags; end

    # @return [String] datadog version
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#92
    def version; end

    # Ruby VM name and version.
    # Examples: "ruby-2.7.1", "jruby-9.2.11.1", "truffleruby-20.1.0"
    #
    # @return [String, nil]
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#144
    def vm; end

    private

    # Outputs "k1:v1,k2:v2,..."
    #
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#163
    def hash_serializer(h); end
  end
end

# Collects and logs Core diagnostic information
#
# source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#45
module Datadog::Core::Diagnostics::EnvironmentLogger
  extend ::Datadog::Core::Diagnostics::EnvironmentLogging

  class << self
    # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#48
    def collect_and_log!(extra_fields = T.unsafe(nil)); end
  end
end

# Base class for EnvironmentLoggers - should allow for easy reporting by users to Datadog support.
#
# The EnvironmentLogger should not pollute the logs in a development environment.
#
# source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#13
module Datadog::Core::Diagnostics::EnvironmentLogging
  # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#14
  def log_configuration!(prefix, data); end

  # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#18
  def log_debug!(prefix, data); end

  # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#22
  def log_error!(prefix, type, error); end

  protected

  # Are we logging the environment data?
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#33
  def log?; end

  # source://datadog//lib/datadog/core/diagnostics/environment_logger.rb#28
  def logger; end
end

# Health-related diagnostics
#
# source://datadog//lib/datadog/core/diagnostics/health.rb#10
module Datadog::Core::Diagnostics::Health; end

# Health metrics for diagnostics
#
# source://datadog//lib/datadog/core/diagnostics/health.rb#12
class Datadog::Core::Diagnostics::Health::Metrics < ::Datadog::Core::Metrics::Client
  extend ::Datadog::Tracing::Diagnostics::Health::Metrics

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def api_errors(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def api_requests(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def api_responses(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def error_context_overflow(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def error_instrumentation_patch(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def error_span_finish(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def error_unfinished_spans(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def instrumentation_patched(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def queue_accepted(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def queue_accepted_lengths(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def queue_dropped(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def queue_length(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def queue_max_length(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def queue_spans(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def sampling_service_cache_length(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def traces_filtered(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def transport_chunked(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def transport_trace_too_large(*args, &block); end

  # source://datadog//lib/datadog/core/diagnostics/health.rb#14
  def writer_cpu_time(*args, &block); end
end

# Encoding module that encodes data for the AgentTransport
#
# source://datadog//lib/datadog/core/encoding.rb#9
module Datadog::Core::Encoding; end

# Encoder interface that provides the logic to encode traces and service
#
# @abstract
#
# source://datadog//lib/datadog/core/encoding.rb#12
module Datadog::Core::Encoding::Encoder
  # :nocov:
  #
  # @raise [NotImplementedError]
  #
  # source://datadog//lib/datadog/core/encoding.rb#14
  def content_type; end

  # Deserializes a value serialized with {#encode}.
  # This method is used for debugging purposes.
  #
  # @raise [NotImplementedError]
  #
  # source://datadog//lib/datadog/core/encoding.rb#30
  def decode(_); end

  # Serializes a single trace into a String suitable for network transmission.
  #
  # @raise [NotImplementedError]
  #
  # source://datadog//lib/datadog/core/encoding.rb#24
  def encode(_); end

  # Concatenates a list of elements previously encoded by +#encode+.
  #
  # @raise [NotImplementedError]
  #
  # source://datadog//lib/datadog/core/encoding.rb#19
  def join(encoded_elements); end
end

# Encoder for the JSON format
#
# source://datadog//lib/datadog/core/encoding.rb#37
module Datadog::Core::Encoding::JSONEncoder
  extend ::Datadog::Core::Encoding::Encoder

  private

  # source://datadog//lib/datadog/core/encoding.rb#44
  def content_type; end

  # source://datadog//lib/datadog/core/encoding.rb#52
  def decode(obj); end

  # source://datadog//lib/datadog/core/encoding.rb#48
  def encode(obj); end

  # source://datadog//lib/datadog/core/encoding.rb#56
  def join(encoded_data); end

  class << self
    # source://datadog//lib/datadog/core/encoding.rb#44
    def content_type; end

    # source://datadog//lib/datadog/core/encoding.rb#52
    def decode(obj); end

    # source://datadog//lib/datadog/core/encoding.rb#48
    def encode(obj); end

    # source://datadog//lib/datadog/core/encoding.rb#56
    def join(encoded_data); end
  end
end

# source://datadog//lib/datadog/core/encoding.rb#40
Datadog::Core::Encoding::JSONEncoder::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Encoder for the Msgpack format
#
# source://datadog//lib/datadog/core/encoding.rb#62
module Datadog::Core::Encoding::MsgpackEncoder
  extend ::Datadog::Core::Encoding::Encoder

  private

  # source://datadog//lib/datadog/core/encoding.rb#69
  def content_type; end

  # source://datadog//lib/datadog/core/encoding.rb#77
  def decode(obj); end

  # source://datadog//lib/datadog/core/encoding.rb#73
  def encode(obj); end

  # source://datadog//lib/datadog/core/encoding.rb#81
  def join(encoded_data); end

  class << self
    # source://datadog//lib/datadog/core/encoding.rb#69
    def content_type; end

    # source://datadog//lib/datadog/core/encoding.rb#77
    def decode(obj); end

    # source://datadog//lib/datadog/core/encoding.rb#73
    def encode(obj); end

    # source://datadog//lib/datadog/core/encoding.rb#81
    def join(encoded_data); end
  end
end

# source://datadog//lib/datadog/core/encoding.rb#67
Datadog::Core::Encoding::MsgpackEncoder::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Namespace for handling application environment
#
# source://datadog//lib/datadog/core/environment/execution.rb#7
module Datadog::Core::Environment; end

# Retrieves the agent's `/info` endpoint data.
# This data can be used to determine the capabilities of the local Datadog agent.
#
# @example Example response payload
#   {
#   "version" : "7.57.2",
#   "git_commit" : "38ba0c7",
#   "endpoints" : [ "/v0.4/traces", "/v0.4/services", "/v0.7/traces", "/v0.7/config" ],
#   "client_drop_p0s" : true,
#   "span_meta_structs" : true,
#   "long_running_spans" : true,
#   "evp_proxy_allowed_headers" : [ "Content-Type", "Accept-Encoding", "Content-Encoding", "User-Agent" ],
#   "config" : {
#   "default_env" : "none",
#   "target_tps" : 10,
#   "max_eps" : 200,
#   "receiver_port" : 8126,
#   "receiver_socket" : "/var/run/datadog/apm.socket",
#   "connection_limit" : 0,
#   "receiver_timeout" : 0,
#   "max_request_bytes" : 26214400,
#   "statsd_port" : 8125,
#   "analyzed_spans_by_service" : { },
#   "obfuscation" : {
#   "elastic_search" : true,
#   "mongo" : true,
#   "sql_exec_plan" : false,
#   "sql_exec_plan_normalize" : false,
#   "http" : {
#   "remove_query_string" : false,
#   "remove_path_digits" : false
#   },
#   "remove_stack_traces" : false,
#   "redis" : {
#   "Enabled" : true,
#   "RemoveAllArgs" : false
#   },
#   "memcached" : {
#   "Enabled" : true,
#   "KeepCommand" : false
#   }
#   }
#   },
#   "peer_tags" : null
#   }
# @see https://github.com/DataDog/datadog-agent/blob/f07df0a3c1fca0c83b5a15f553bd994091b0c8ac/pkg/trace/api/info.go#L20
#
# source://datadog//lib/datadog/core/environment/agent_info.rb#53
class Datadog::Core::Environment::AgentInfo
  # @return [AgentInfo] a new instance of AgentInfo
  #
  # source://datadog//lib/datadog/core/environment/agent_info.rb#56
  def initialize(agent_settings, logger: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/environment/agent_info.rb#72
  def ==(other); end

  # Returns the value of attribute agent_settings.
  #
  # source://datadog//lib/datadog/core/environment/agent_info.rb#54
  def agent_settings; end

  # Fetches the information from the agent.
  #
  # @return [Datadog::Core::Remote::Transport::HTTP::Negotiation::Response] the response from the agent
  # @return [nil] if an error occurred while fetching the information
  #
  # source://datadog//lib/datadog/core/environment/agent_info.rb#65
  def fetch; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/environment/agent_info.rb#54
  def logger; end
end

# Reads information from Linux cgroups.
# This information is used to extract information
# about the current Linux container identity.
#
# @see https://man7.org/linux/man-pages/man7/cgroups.7.html
#
# source://datadog//lib/datadog/core/environment/cgroup.rb#12
module Datadog::Core::Environment::Cgroup
  private

  # source://datadog//lib/datadog/core/environment/cgroup.rb#24
  def descriptors(process = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/environment/cgroup.rb#41
  def parse(line); end

  class << self
    # source://datadog//lib/datadog/core/environment/cgroup.rb#24
    def descriptors(process = T.unsafe(nil)); end

    # source://datadog//lib/datadog/core/environment/cgroup.rb#41
    def parse(line); end
  end
end

# source://datadog//lib/datadog/core/environment/cgroup.rb#15
class Datadog::Core::Environment::Cgroup::Descriptor < ::Struct
  # Returns the value of attribute controllers
  #
  # @return [Object] the current value of controllers
  #
  # source://datadog//lib/datadog/core/environment/cgroup.rb#15
  def controllers; end

  # Sets the attribute controllers
  #
  # @param value [Object] the value to set the attribute controllers to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/environment/cgroup.rb#15
  def controllers=(_); end

  # Returns the value of attribute groups
  #
  # @return [Object] the current value of groups
  #
  # source://datadog//lib/datadog/core/environment/cgroup.rb#15
  def groups; end

  # Sets the attribute groups
  #
  # @param value [Object] the value to set the attribute groups to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/environment/cgroup.rb#15
  def groups=(_); end

  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  #
  # source://datadog//lib/datadog/core/environment/cgroup.rb#15
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/environment/cgroup.rb#15
  def id=(_); end

  # Returns the value of attribute path
  #
  # @return [Object] the current value of path
  #
  # source://datadog//lib/datadog/core/environment/cgroup.rb#15
  def path; end

  # Sets the attribute path
  #
  # @param value [Object] the value to set the attribute path to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/environment/cgroup.rb#15
  def path=(_); end

  class << self
    # source://datadog//lib/datadog/core/environment/cgroup.rb#15
    def [](*_arg0); end

    # source://datadog//lib/datadog/core/environment/cgroup.rb#15
    def inspect; end

    # source://datadog//lib/datadog/core/environment/cgroup.rb#15
    def keyword_init?; end

    # source://datadog//lib/datadog/core/environment/cgroup.rb#15
    def members; end

    # source://datadog//lib/datadog/core/environment/cgroup.rb#15
    def new(*_arg0); end
  end
end

# source://datadog//lib/datadog/core/environment/cgroup.rb#13
Datadog::Core::Environment::Cgroup::LINE_REGEX = T.let(T.unsafe(nil), Regexp)

# Retrieves number of classes from runtime
#
# source://datadog//lib/datadog/core/environment/class_count.rb#7
module Datadog::Core::Environment::ClassCount
  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/class_count.rb#12
    def available?; end

    # source://datadog//lib/datadog/core/environment/class_count.rb#8
    def value; end
  end
end

# For container environments
#
# source://datadog//lib/datadog/core/environment/container.rb#9
module Datadog::Core::Environment::Container
  private

  # source://datadog//lib/datadog/core/environment/container.rb#30
  def container_id; end

  # source://datadog//lib/datadog/core/environment/container.rb#38
  def descriptor; end

  # source://datadog//lib/datadog/core/environment/container.rb#26
  def platform; end

  # source://datadog//lib/datadog/core/environment/container.rb#34
  def task_uid; end

  class << self
    # source://datadog//lib/datadog/core/environment/container.rb#30
    def container_id; end

    # source://datadog//lib/datadog/core/environment/container.rb#38
    def descriptor; end

    # source://datadog//lib/datadog/core/environment/container.rb#26
    def platform; end

    # source://datadog//lib/datadog/core/environment/container.rb#34
    def task_uid; end
  end
end

# source://datadog//lib/datadog/core/environment/container.rb#11
Datadog::Core::Environment::Container::CONTAINER_PATTERN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/container.rb#15
Datadog::Core::Environment::Container::CONTAINER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://datadog//lib/datadog/core/environment/container.rb#18
class Datadog::Core::Environment::Container::Descriptor < ::Struct
  # Returns the value of attribute container_id
  #
  # @return [Object] the current value of container_id
  #
  # source://datadog//lib/datadog/core/environment/container.rb#18
  def container_id; end

  # Sets the attribute container_id
  #
  # @param value [Object] the value to set the attribute container_id to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/environment/container.rb#18
  def container_id=(_); end

  # Returns the value of attribute platform
  #
  # @return [Object] the current value of platform
  #
  # source://datadog//lib/datadog/core/environment/container.rb#18
  def platform; end

  # Sets the attribute platform
  #
  # @param value [Object] the value to set the attribute platform to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/environment/container.rb#18
  def platform=(_); end

  # Returns the value of attribute task_uid
  #
  # @return [Object] the current value of task_uid
  #
  # source://datadog//lib/datadog/core/environment/container.rb#18
  def task_uid; end

  # Sets the attribute task_uid
  #
  # @param value [Object] the value to set the attribute task_uid to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/environment/container.rb#18
  def task_uid=(_); end

  class << self
    # source://datadog//lib/datadog/core/environment/container.rb#18
    def [](*_arg0); end

    # source://datadog//lib/datadog/core/environment/container.rb#18
    def inspect; end

    # source://datadog//lib/datadog/core/environment/container.rb#18
    def keyword_init?; end

    # source://datadog//lib/datadog/core/environment/container.rb#18
    def members; end

    # source://datadog//lib/datadog/core/environment/container.rb#18
    def new(*_arg0); end
  end
end

# source://datadog//lib/datadog/core/environment/container.rb#16
Datadog::Core::Environment::Container::FARGATE_14_CONTAINER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://datadog//lib/datadog/core/environment/container.rb#13
Datadog::Core::Environment::Container::PLATFORM_REGEX = T.let(T.unsafe(nil), Regexp)

# source://datadog//lib/datadog/core/environment/container.rb#14
Datadog::Core::Environment::Container::POD_REGEX = T.let(T.unsafe(nil), Regexp)

# source://datadog//lib/datadog/core/environment/container.rb#10
Datadog::Core::Environment::Container::UUID_PATTERN = T.let(T.unsafe(nil), String)

# Provides information about the execution environment on the current process.
#
# source://datadog//lib/datadog/core/environment/execution.rb#9
module Datadog::Core::Environment::Execution
  class << self
    # Is this process running in a development environment?
    # This can be used to make decisions about when to enable
    # background systems like worker threads or telemetry.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/execution.rb#14
    def development?; end

    # WebMock stores the reference to `Net::HTTP` with constant `OriginalNetHTTP`, and when WebMock enables,
    # the adapter swaps `Net::HTTP` reference to its mock object, @webMockNetHTTP.
    #
    # Hence, we can detect by
    #   1. Checking if `Net::HTTP` is referring to mock object
    #   => ::Net::HTTP.equal?(::WebMock::HttpLibAdapters::NetHttpAdapter.instance_variable_get(:@webMockNetHTTP))
    #
    #   2. Checking if `Net::HTTP` is referring to the original one
    #   => ::Net::HTTP.equal?(::WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetHTTP)
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/execution.rb#27
    def webmock_enabled?; end

    private

    # Check if we are running from `bin/cucumber` or `cucumber/rake/task`.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/execution.rb#70
    def cucumber?; end

    # Check if Minitest is present and installed to run.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/execution.rb#58
    def minitest?; end

    # If this is a Rails application, use different heuristics to detect
    # whether this is a development environment or not.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/execution.rb#76
    def rails_development?; end

    # By default, every Rails application has three environments: `development`, `test`, and `production`.
    # This has been the case since Rails 3.0.0:
    # https://github.com/rails/rails/blob/3e48484ff16ea07ffe5db232bf43c14992e273c1/railties/doc/guides/getting_started_with_rails/getting_started_with_rails.txt#L144
    #
    # Instead of checking for "not production", we instead check for "development" and "test" because
    # it's common to have a custom "staging" environment, and such environment normally want to run as close
    # to production as possible.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/execution.rb#96
    def rails_env_development?; end

    # Is this process running inside on a Readevalprint loop?
    # DEV: REPLs always set the program name to the exact REPL name.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/execution.rb#42
    def repl?; end

    # RSpec always runs using the `rspec` file https://github.com/rspec/rspec-core/blob/main/exe/rspec
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/execution.rb#50
    def rspec?; end

    # Is this process running a test?
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/execution.rb#36
    def test?; end
  end
end

# source://datadog//lib/datadog/core/environment/ext.rb#9
module Datadog::Core::Environment::Ext; end

# e.g for CRuby '3.0.1', for JRuby '9.2.19.0', for TruffleRuby '21.1.0'
#
# source://datadog//lib/datadog/core/environment/ext.rb#11
Datadog::Core::Environment::Ext::ENGINE_VERSION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#18
Datadog::Core::Environment::Ext::ENV_API_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#19
Datadog::Core::Environment::Ext::ENV_ENVIRONMENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#20
Datadog::Core::Environment::Ext::ENV_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#21
Datadog::Core::Environment::Ext::ENV_SITE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#22
Datadog::Core::Environment::Ext::ENV_TAGS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#23
Datadog::Core::Environment::Ext::ENV_VERSION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#24
Datadog::Core::Environment::Ext::FALLBACK_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#41
Datadog::Core::Environment::Ext::GEM_DATADOG_VERSION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#31
Datadog::Core::Environment::Ext::LANG = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#32
Datadog::Core::Environment::Ext::LANG_ENGINE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#33
Datadog::Core::Environment::Ext::LANG_INTERPRETER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#34
Datadog::Core::Environment::Ext::LANG_PLATFORM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#35
Datadog::Core::Environment::Ext::LANG_VERSION = T.let(T.unsafe(nil), String)

# e.g. 'ruby', 'jruby', 'truffleruby'
#
# source://datadog//lib/datadog/core/environment/ext.rb#36
Datadog::Core::Environment::Ext::RUBY_ENGINE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#37
Datadog::Core::Environment::Ext::TAG_ENV = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#38
Datadog::Core::Environment::Ext::TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/environment/ext.rb#39
Datadog::Core::Environment::Ext::TAG_VERSION = T.let(T.unsafe(nil), String)

# Retrieves garbage collection statistics
#
# source://datadog//lib/datadog/core/environment/gc.rb#7
module Datadog::Core::Environment::GC
  private

  # source://datadog//lib/datadog/core/environment/gc.rb#14
  def available?; end

  # source://datadog//lib/datadog/core/environment/gc.rb#10
  def stat; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/gc.rb#14
    def available?; end

    # source://datadog//lib/datadog/core/environment/gc.rb#10
    def stat; end
  end
end

# Retrieves git repository information from environment variables
#
# source://datadog//lib/datadog/core/environment/git.rb#11
module Datadog::Core::Environment::Git
  class << self
    # source://datadog//lib/datadog/core/environment/git.rb#18
    def git_commit_sha; end

    # source://datadog//lib/datadog/core/environment/git.rb#12
    def git_repository_url; end
  end
end

# For runtime identity
#
# source://datadog//lib/datadog/core/environment/identity.rb#13
module Datadog::Core::Environment::Identity
  extend ::Datadog::Core::Utils::Forking

  private

  # Returns datadog gem version, rubygems-style
  #
  # source://datadog//lib/datadog/core/environment/identity.rb#53
  def gem_datadog_version; end

  # Returns tracer version, comforming to https://semver.org/spec/v2.0.0.html
  #
  # source://datadog//lib/datadog/core/environment/identity.rb#58
  def gem_datadog_version_semver2; end

  # Retrieves number of classes from runtime
  #
  # source://datadog//lib/datadog/core/environment/identity.rb#19
  def id; end

  # source://datadog//lib/datadog/core/environment/identity.rb#32
  def lang; end

  # source://datadog//lib/datadog/core/environment/identity.rb#36
  def lang_engine; end

  # source://datadog//lib/datadog/core/environment/identity.rb#40
  def lang_interpreter; end

  # source://datadog//lib/datadog/core/environment/identity.rb#44
  def lang_platform; end

  # source://datadog//lib/datadog/core/environment/identity.rb#48
  def lang_version; end

  # source://datadog//lib/datadog/core/environment/identity.rb#28
  def pid; end

  class << self
    # Returns datadog gem version, rubygems-style
    #
    # source://datadog//lib/datadog/core/environment/identity.rb#53
    def gem_datadog_version; end

    # Returns tracer version, comforming to https://semver.org/spec/v2.0.0.html
    #
    # source://datadog//lib/datadog/core/environment/identity.rb#58
    def gem_datadog_version_semver2; end

    # Retrieves number of classes from runtime
    #
    # source://datadog//lib/datadog/core/environment/identity.rb#19
    def id; end

    # source://datadog//lib/datadog/core/environment/identity.rb#32
    def lang; end

    # source://datadog//lib/datadog/core/environment/identity.rb#36
    def lang_engine; end

    # source://datadog//lib/datadog/core/environment/identity.rb#40
    def lang_interpreter; end

    # source://datadog//lib/datadog/core/environment/identity.rb#44
    def lang_platform; end

    # source://datadog//lib/datadog/core/environment/identity.rb#48
    def lang_version; end

    # source://datadog//lib/datadog/core/environment/identity.rb#28
    def pid; end
  end
end

# For gathering information about the platform
#
# source://datadog//lib/datadog/core/environment/platform.rb#11
module Datadog::Core::Environment::Platform
  private

  # @return [String] ISA of host; `uname -m`
  #
  # source://datadog//lib/datadog/core/environment/platform.rb#15
  def architecture; end

  # @return [String] name of host; `uname -n`
  #
  # source://datadog//lib/datadog/core/environment/platform.rb#20
  def hostname; end

  # System name, normally `Linux` or `Darwin` (but 'Mac OS X' on JRuby);
  #
  # @return [String] name of kernel; `uname -s`.
  #
  # source://datadog//lib/datadog/core/environment/platform.rb#26
  def kernel_name; end

  # @return [String] kernel release; `uname -r`
  #
  # source://datadog//lib/datadog/core/environment/platform.rb#31
  def kernel_release; end

  # @return [String] kernel version; `uname -v`
  #
  # source://datadog//lib/datadog/core/environment/platform.rb#40
  def kernel_version; end

  class << self
    # @return [String] ISA of host; `uname -m`
    #
    # source://datadog//lib/datadog/core/environment/platform.rb#15
    def architecture; end

    # @return [String] name of host; `uname -n`
    #
    # source://datadog//lib/datadog/core/environment/platform.rb#20
    def hostname; end

    # System name, normally `Linux` or `Darwin` (but 'Mac OS X' on JRuby);
    #
    # @return [String] name of kernel; `uname -s`.
    #
    # source://datadog//lib/datadog/core/environment/platform.rb#26
    def kernel_name; end

    # @return [String] kernel release; `uname -r`
    #
    # source://datadog//lib/datadog/core/environment/platform.rb#31
    def kernel_release; end

    # @return [String] kernel version; `uname -v`
    #
    # source://datadog//lib/datadog/core/environment/platform.rb#40
    def kernel_version; end
  end
end

# For runtime identity
#
# source://datadog//lib/datadog/core/environment/socket.rb#10
module Datadog::Core::Environment::Socket
  extend ::Datadog::Core::Utils::Forking

  private

  # source://datadog//lib/datadog/core/environment/socket.rb#15
  def hostname; end

  class << self
    # source://datadog//lib/datadog/core/environment/socket.rb#15
    def hostname; end
  end
end

# Retrieves number of threads from runtime
#
# source://datadog//lib/datadog/core/environment/thread_count.rb#7
module Datadog::Core::Environment::ThreadCount
  private

  # source://datadog//lib/datadog/core/environment/thread_count.rb#14
  def available?; end

  # source://datadog//lib/datadog/core/environment/thread_count.rb#10
  def value; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/thread_count.rb#14
    def available?; end

    # source://datadog//lib/datadog/core/environment/thread_count.rb#10
    def value; end
  end
end

# Reports Ruby VM cache performance statistics.
# This currently encompasses cache invalidation counters and is CRuby-specific.
#
# JRuby emulates some CRuby global cache statistics, but they are synthetic and don't
# provide actionable performance information in the same way CRuby does.
# TruffleRuby does not have a global runtime cache invalidation cache.
#
# @see http://archive.today/2021.09.10-205702/https://medium.com/graalvm/precise-method-and-constant-invalidation-in-truffleruby-4dd56c6bac1a
# @see https://github.com/jruby/jruby/issues/4384#issuecomment-267069314
#
# source://datadog//lib/datadog/core/environment/vm_cache.rb#15
module Datadog::Core::Environment::VMCache
  private

  # source://datadog//lib/datadog/core/environment/vm_cache.rb#58
  def available?; end

  # Introduced in Ruby 3.2 to match an improved cache implementation.
  #
  # @see https://bugs.ruby-lang.org/issues/18589
  #
  # source://datadog//lib/datadog/core/environment/vm_cache.rb#47
  def constant_cache_invalidations; end

  # Introduced in Ruby 3.2 to match an improved cache implementation.
  #
  # @see https://bugs.ruby-lang.org/issues/18589
  #
  # source://datadog//lib/datadog/core/environment/vm_cache.rb#54
  def constant_cache_misses; end

  # Global constant cache "generation" counter.
  #
  # Whenever a constant creation busts the global constant cache
  # this value is incremented. This has a measurable performance impact
  # and thus show be avoided after application warm up.
  #
  # This was removed in Ruby 3.2.
  #
  # @see https://github.com/ruby/ruby/blob/master/doc/NEWS/NEWS-3.2.0.md#implementation-improvements
  #
  # source://datadog//lib/datadog/core/environment/vm_cache.rb#26
  def global_constant_state; end

  # Global method cache "generation" counter.
  #
  # Whenever a method creation busts the global method cache
  # this value is incremented. This has a measurable performance impact
  # and thus show be avoided after application warm up.
  #
  # Since Ruby 3.0, the method class is kept on a per-class basis,
  # largely mitigating global method cache busting. `global_method_state`
  # is thus not available since Ruby 3.0.
  #
  # @see https://bugs.ruby-lang.org/issues/16614
  #
  # source://datadog//lib/datadog/core/environment/vm_cache.rb#40
  def global_method_state; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/vm_cache.rb#58
    def available?; end

    # Introduced in Ruby 3.2 to match an improved cache implementation.
    #
    # @see https://bugs.ruby-lang.org/issues/18589
    #
    # source://datadog//lib/datadog/core/environment/vm_cache.rb#47
    def constant_cache_invalidations; end

    # Introduced in Ruby 3.2 to match an improved cache implementation.
    #
    # @see https://bugs.ruby-lang.org/issues/18589
    #
    # source://datadog//lib/datadog/core/environment/vm_cache.rb#54
    def constant_cache_misses; end

    # Global constant cache "generation" counter.
    #
    # Whenever a constant creation busts the global constant cache
    # this value is incremented. This has a measurable performance impact
    # and thus show be avoided after application warm up.
    #
    # This was removed in Ruby 3.2.
    #
    # @see https://github.com/ruby/ruby/blob/master/doc/NEWS/NEWS-3.2.0.md#implementation-improvements
    #
    # source://datadog//lib/datadog/core/environment/vm_cache.rb#26
    def global_constant_state; end

    # Global method cache "generation" counter.
    #
    # Whenever a method creation busts the global method cache
    # this value is incremented. This has a measurable performance impact
    # and thus show be avoided after application warm up.
    #
    # Since Ruby 3.0, the method class is kept on a per-class basis,
    # largely mitigating global method cache busting. `global_method_state`
    # is thus not available since Ruby 3.0.
    #
    # @see https://bugs.ruby-lang.org/issues/16614
    #
    # source://datadog//lib/datadog/core/environment/vm_cache.rb#40
    def global_method_state; end
  end
end

# Defines helper methods for environment
#
# source://datadog//lib/datadog/core/environment/variable_helpers.rb#9
module Datadog::Core::Environment::VariableHelpers
  extend ::Datadog::Core::Environment::VariableHelpers

  # Reads an environment variable as a Boolean.
  #
  # @param default [Boolean] the default value if the keys in `var` are not present in the environment
  # @param deprecation_warning [Boolean] when `var` is a list, record a deprecation log when
  #   the first key in `var` is not used.
  # @param var [String] environment variable
  # @param var [Array<String>] list of environment variables
  # @return [Boolean] if the environment value is the string `true` or `1`
  # @return [default] if the environment value is not found
  #
  # source://datadog//lib/datadog/core/environment/variable_helpers.rb#21
  def env_to_bool(var, default = T.unsafe(nil), deprecation_warning: T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/core/environment/variable_helpers.rb#34
  def decode_array(var, deprecation_warning); end
end

# Reports YJIT primitive runtime statistics.
#
# source://datadog//lib/datadog/core/environment/yjit.rb#7
module Datadog::Core::Environment::YJIT
  private

  # source://datadog//lib/datadog/core/environment/yjit.rb#61
  def available?; end

  # Code GC count
  #
  # source://datadog//lib/datadog/core/environment/yjit.rb#36
  def code_gc_count; end

  # Size of memory region allocated for JIT code
  #
  # source://datadog//lib/datadog/core/environment/yjit.rb#41
  def code_region_size; end

  # GCed code size
  #
  # source://datadog//lib/datadog/core/environment/yjit.rb#26
  def freed_code_size; end

  # GCed pages
  #
  # source://datadog//lib/datadog/core/environment/yjit.rb#21
  def freed_page_count; end

  # Inline code size
  #
  # source://datadog//lib/datadog/core/environment/yjit.rb#11
  def inline_code_size; end

  # Live pages
  #
  # source://datadog//lib/datadog/core/environment/yjit.rb#31
  def live_page_count; end

  # Total number of object shapes
  #
  # source://datadog//lib/datadog/core/environment/yjit.rb#46
  def object_shape_count; end

  # Outlined code size
  #
  # source://datadog//lib/datadog/core/environment/yjit.rb#16
  def outlined_code_size; end

  # Ratio of YJIT-executed instructions
  #
  # source://datadog//lib/datadog/core/environment/yjit.rb#56
  def ratio_in_yjit; end

  # Size of memory Rust allocated for metadata
  #
  # source://datadog//lib/datadog/core/environment/yjit.rb#51
  def yjit_alloc_size; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#61
    def available?; end

    # Code GC count
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#36
    def code_gc_count; end

    # Size of memory region allocated for JIT code
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#41
    def code_region_size; end

    # GCed code size
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#26
    def freed_code_size; end

    # GCed pages
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#21
    def freed_page_count; end

    # Inline code size
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#11
    def inline_code_size; end

    # Live pages
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#31
    def live_page_count; end

    # Total number of object shapes
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#46
    def object_shape_count; end

    # Outlined code size
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#16
    def outlined_code_size; end

    # Ratio of YJIT-executed instructions
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#56
    def ratio_in_yjit; end

    # Size of memory Rust allocated for metadata
    #
    # source://datadog//lib/datadog/core/environment/yjit.rb#51
    def yjit_alloc_size; end
  end
end

# Error is a value-object responsible for sanitizing/encapsulating error data
#
# source://datadog//lib/datadog/core/error.rb#8
class Datadog::Core::Error
  # @return [Error] a new instance of Error
  #
  # source://datadog//lib/datadog/core/error.rb#93
  def initialize(type = T.unsafe(nil), message = T.unsafe(nil), backtrace = T.unsafe(nil)); end

  # Returns the value of attribute backtrace.
  #
  # source://datadog//lib/datadog/core/error.rb#9
  def backtrace; end

  # Returns the value of attribute message.
  #
  # source://datadog//lib/datadog/core/error.rb#9
  def message; end

  # Returns the value of attribute type.
  #
  # source://datadog//lib/datadog/core/error.rb#9
  def type; end

  class << self
    # source://datadog//lib/datadog/core/error.rb#12
    def build_from(value); end

    private

    # Outputs the following format for exceptions:
    #
    # ```
    # error_spec.rb:55:in `wrapper': wrapper layer (RuntimeError)
    # 	from error_spec.rb:40:in `wrapper'
    # 	from error_spec.rb:61:in `caller'
    #   ...
    # ```
    #
    # source://datadog//lib/datadog/core/error.rb#66
    def backtrace_for(ex, backtrace); end

    # Returns a stack trace with nested error causes and details.
    #
    # This manually implements Ruby >= 2.6 error output for two reasons:
    #
    # 1. It is not available in Ruby < 2.6.
    # 2. It's measurably faster to manually implement it in Ruby.
    #
    # This method mimics the exact output of
    # `ex.full_message(highlight: false, order: :top)`
    # but it's around 3x faster in our benchmark test
    # at `error_spec.rb`.
    #
    # source://datadog//lib/datadog/core/error.rb#41
    def full_backtrace(ex); end
  end
end

# Used to decorate Datadog module with additional behavior
#
# source://datadog//lib/datadog/core/extensions.rb#10
module Datadog::Core::Extensions
  class << self
    # @private
    #
    # source://datadog//lib/datadog/core/extensions.rb#11
    def extended(base); end
  end
end

# source://datadog//lib/datadog/core/git/ext.rb#5
module Datadog::Core::Git; end

# Defines constants for Git tags
#
# source://datadog//lib/datadog/core/git/ext.rb#7
module Datadog::Core::Git::Ext; end

# source://datadog//lib/datadog/core/git/ext.rb#12
Datadog::Core::Git::Ext::ENV_COMMIT_SHA = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/git/ext.rb#11
Datadog::Core::Git::Ext::ENV_REPOSITORY_URL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/git/ext.rb#9
Datadog::Core::Git::Ext::TAG_COMMIT_SHA = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/git/ext.rb#8
Datadog::Core::Git::Ext::TAG_REPOSITORY_URL = T.let(T.unsafe(nil), String)

# A header collection implementation that looks up headers in a Hash.
#
# source://datadog//lib/datadog/core/header_collection.rb#30
class Datadog::Core::HashHeaderCollection < ::Datadog::Core::HeaderCollection
  # @return [HashHeaderCollection] a new instance of HashHeaderCollection
  #
  # source://datadog//lib/datadog/core/header_collection.rb#31
  def initialize(hash); end

  # source://datadog//lib/datadog/core/header_collection.rb#38
  def get(header_name); end
end

# A some-what abstract class representing a collection of headers.
#
# Use the `HeaderCollection.from_hash` function to create a header collection from a `Hash`.
# Another option is to use `HashHeaderCollection` directly.
#
# source://datadog//lib/datadog/core/header_collection.rb#9
class Datadog::Core::HeaderCollection
  # Gets a single value of the header with the given name, case insensitive.
  #
  # @param header_name [String] Name of the header to get the value of.
  #
  # source://datadog//lib/datadog/core/header_collection.rb#15
  def get(header_name); end

  class << self
    # Create a header collection that retrieves headers from the given Hash.
    #
    # This can be useful for testing or other trivial use cases.
    #
    # @param hash [Hash] Hash with the headers.
    #
    # source://datadog//lib/datadog/core/header_collection.rb#24
    def from_hash(hash); end
  end
end

# source://datadog//lib/datadog/core.rb#16
Datadog::Core::LIBDATADOG_API_FAILURE = T.let(T.unsafe(nil), T.untyped)

# A custom logger with minor enhancements:
# - progname defaults to datadog to clearly identify Datadog dd-trace-rb related messages
# - adds last caller stack-trace info to know where the message comes from
#
# source://datadog//lib/datadog/core/logger.rb#11
class Datadog::Core::Logger < ::Logger
  # @return [Logger] a new instance of Logger
  #
  # source://datadog//lib/datadog/core/logger.rb#14
  def initialize(*args, &block); end

  # source://datadog//lib/datadog/core/logger.rb#20
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/core/logger.rb#42
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
end

# source://datadog//lib/datadog/core/logger.rb#12
Datadog::Core::Logger::PREFIX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/logging/ext.rb#5
module Datadog::Core::Logging; end

# source://datadog//lib/datadog/core/logging/ext.rb#6
module Datadog::Core::Logging::Ext; end

# The technology from which the log originated.
#
# @see https://docs.datadoghq.com/api/latest/logs/#send-logs
#
# source://datadog//lib/datadog/core/logging/ext.rb#9
Datadog::Core::Logging::Ext::DD_SOURCE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/metrics/ext.rb#5
module Datadog::Core::Metrics; end

# Acts as client for sending metrics (via Statsd)
# Wraps a Statsd client with default tags and additional configuration.
#
# source://datadog//lib/datadog/core/metrics/client.rb#19
class Datadog::Core::Metrics::Client
  include ::Datadog::Core::Metrics::Options
  extend ::Datadog::Core::Metrics::Options
  extend ::Datadog::Core::Metrics::Helpers

  # @return [Client] a new instance of Client
  #
  # source://datadog//lib/datadog/core/metrics/client.rb#26
  def initialize(telemetry:, logger: T.unsafe(nil), statsd: T.unsafe(nil), enabled: T.unsafe(nil), **_); end

  # source://datadog//lib/datadog/core/metrics/client.rb#175
  def close; end

  # source://datadog//lib/datadog/core/metrics/client.rb#86
  def configure(options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/metrics/client.rb#95
  def count(stat, value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/core/metrics/client.rb#56
  def default_hostname; end

  # source://datadog//lib/datadog/core/metrics/client.rb#60
  def default_port; end

  # source://datadog//lib/datadog/core/metrics/client.rb#64
  def default_statsd_client; end

  # source://datadog//lib/datadog/core/metrics/client.rb#109
  def distribution(stat, value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/core/metrics/client.rb#52
  def enabled=(enabled); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/metrics/client.rb#48
  def enabled?; end

  # source://datadog//lib/datadog/core/metrics/client.rb#136
  def gauge(stat, value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/core/metrics/client.rb#123
  def increment(stat, options = T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/metrics/client.rb#24
  def logger; end

  # source://datadog//lib/datadog/core/metrics/client.rb#171
  def send_metrics(metrics); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/metrics/client.rb#91
  def send_stats?; end

  # Returns the value of attribute statsd.
  #
  # source://datadog//lib/datadog/core/metrics/client.rb#24
  def statsd; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/metrics/client.rb#39
  def supported?; end

  # Returns the value of attribute telemetry.
  #
  # source://datadog//lib/datadog/core/metrics/client.rb#24
  def telemetry; end

  # source://datadog//lib/datadog/core/metrics/client.rb#150
  def time(stat, options = T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/core/metrics/client.rb#181
  def dogstatsd_version; end

  # source://datadog//lib/datadog/core/metrics/client.rb#195
  def ignored_statsd_warning; end
end

# source://datadog//lib/datadog/core/metrics/client.rb#192
Datadog::Core::Metrics::Client::IGNORED_STATSD_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://datadog//lib/datadog/core/metrics/ext.rb#7
module Datadog::Core::Metrics::Ext; end

# source://datadog//lib/datadog/core/metrics/ext.rb#8
Datadog::Core::Metrics::Ext::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/metrics/ext.rb#9
Datadog::Core::Metrics::Ext::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/core/metrics/ext.rb#11
Datadog::Core::Metrics::Ext::TAG_LANG = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/metrics/ext.rb#12
Datadog::Core::Metrics::Ext::TAG_LANG_INTERPRETER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/metrics/ext.rb#13
Datadog::Core::Metrics::Ext::TAG_LANG_VERSION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/metrics/ext.rb#14
Datadog::Core::Metrics::Ext::TAG_TRACER_VERSION = T.let(T.unsafe(nil), String)

# For defining and adding helpers to metrics
#
# source://datadog//lib/datadog/core/metrics/helpers.rb#7
module Datadog::Core::Metrics::Helpers
  # source://datadog//lib/datadog/core/metrics/helpers.rb#15
  def count(name, stat); end

  # source://datadog//lib/datadog/core/metrics/helpers.rb#15
  def distribution(name, stat); end

  # source://datadog//lib/datadog/core/metrics/helpers.rb#15
  def gauge(name, stat); end

  # source://datadog//lib/datadog/core/metrics/helpers.rb#15
  def increment(name, stat); end

  # source://datadog//lib/datadog/core/metrics/helpers.rb#15
  def time(name, stat); end
end

# source://datadog//lib/datadog/core/metrics/logging.rb#9
module Datadog::Core::Metrics::Logging; end

# Surrogate for Datadog::Statsd to log elsewhere
#
# source://datadog//lib/datadog/core/metrics/logging.rb#11
class Datadog::Core::Metrics::Logging::Adapter
  # @return [Adapter] a new instance of Adapter
  #
  # source://datadog//lib/datadog/core/metrics/logging.rb#14
  def initialize(logger = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/metrics/logging.rb#25
  def count(stat, value, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/metrics/logging.rb#29
  def distribution(stat, value, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/metrics/logging.rb#37
  def gauge(stat, value, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/metrics/logging.rb#33
  def increment(stat, options = T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/metrics/logging.rb#12
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://datadog//lib/datadog/core/metrics/logging.rb#12
  def logger=(_arg0); end
end

# source://datadog//lib/datadog/core/metrics/metric.rb#6
class Datadog::Core::Metrics::Metric < ::Struct
  # @return [Metric] a new instance of Metric
  #
  # source://datadog//lib/datadog/core/metrics/metric.rb#7
  def initialize(*args); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://datadog//lib/datadog/core/metrics/metric.rb#6
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/metrics/metric.rb#6
  def name=(_); end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  #
  # source://datadog//lib/datadog/core/metrics/metric.rb#6
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/metrics/metric.rb#6
  def options=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  #
  # source://datadog//lib/datadog/core/metrics/metric.rb#6
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/metrics/metric.rb#6
  def type=(_); end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  #
  # source://datadog//lib/datadog/core/metrics/metric.rb#6
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/metrics/metric.rb#6
  def value=(_); end

  class << self
    # source://datadog//lib/datadog/core/metrics/metric.rb#6
    def [](*_arg0); end

    # source://datadog//lib/datadog/core/metrics/metric.rb#6
    def inspect; end

    # source://datadog//lib/datadog/core/metrics/metric.rb#6
    def keyword_init?; end

    # source://datadog//lib/datadog/core/metrics/metric.rb#6
    def members; end

    # source://datadog//lib/datadog/core/metrics/metric.rb#6
    def new(*_arg0); end
  end
end

# For defining and adding default options to metrics
#
# source://datadog//lib/datadog/core/metrics/options.rb#11
module Datadog::Core::Metrics::Options
  # source://datadog//lib/datadog/core/metrics/options.rb#36
  def default_metric_options; end

  # source://datadog//lib/datadog/core/metrics/options.rb#23
  def metric_options(options = T.unsafe(nil)); end
end

# source://datadog//lib/datadog/core/metrics/options.rb#12
Datadog::Core::Metrics::Options::DEFAULT = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/core/metrics/options.rb#13
Datadog::Core::Metrics::Options::DEFAULT_TAGS = T.let(T.unsafe(nil), Array)

# A {Datadog::Core::Pin} sets metadata on a particular object.
#
# This is useful if you want the object to reflect
# customized behavior or attributes, like an eigenclass.
#
# source://datadog//lib/datadog/core/pin.rb#9
class Datadog::Core::Pin
  # @return [Pin] a new instance of Pin
  #
  # source://datadog//lib/datadog/core/pin.rb#27
  def initialize(**options); end

  # source://datadog//lib/datadog/core/pin.rb#31
  def [](name); end

  # source://datadog//lib/datadog/core/pin.rb#35
  def []=(name, value); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/pin.rb#39
  def key?(name); end

  # source://datadog//lib/datadog/core/pin.rb#44
  def onto(obj); end

  # source://datadog//lib/datadog/core/pin.rb#61
  def to_s; end

  private

  # Returns the value of attribute options.
  #
  # source://datadog//lib/datadog/core/pin.rb#68
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://datadog//lib/datadog/core/pin.rb#68
  def options=(_arg0); end

  class << self
    # source://datadog//lib/datadog/core/pin.rb#10
    def get_from(obj); end

    # source://datadog//lib/datadog/core/pin.rb#16
    def set_on(obj, **options); end
  end
end

# Class used to store tracer metadata in a native file descriptor.
#
# source://datadog//lib/datadog/core/process_discovery/tracer_memfd.rb#5
module Datadog::Core::ProcessDiscovery
  private

  # source://datadog//lib/datadog/core.rb#18
  def _native_close_tracer_memfd(_arg0, _arg1); end

  # source://datadog//lib/datadog/core.rb#18
  def _native_store_tracer_metadata(*_arg0); end

  # source://datadog//lib/datadog/core.rb#18
  def _native_to_rb_int(_arg0); end

  class << self
    # source://datadog//lib/datadog/core.rb#18
    def _native_close_tracer_memfd(_arg0, _arg1); end

    # source://datadog//lib/datadog/core.rb#18
    def _native_store_tracer_metadata(*_arg0); end

    # source://datadog//lib/datadog/core.rb#18
    def _native_to_rb_int(_arg0); end

    # source://datadog//lib/datadog/core/process_discovery.rb#15
    def publish(settings); end

    # source://datadog//lib/datadog/core/process_discovery.rb#29
    def shutdown!; end

    private

    # source://datadog//lib/datadog/core/process_discovery.rb#53
    def apply_at_fork_patch; end

    # According to the RFC, runtime_id, service_name, service_env, service_version are optional.
    # In the C method exposed by ddcommon, memfd_create replaces empty strings by None for these fields.
    #
    # source://datadog//lib/datadog/core/process_discovery.rb#38
    def get_metadata(settings); end
  end
end

# source://datadog//lib/datadog/core/process_discovery.rb#12
Datadog::Core::ProcessDiscovery::ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://datadog//lib/datadog/core/process_discovery/tracer_memfd.rb#6
class Datadog::Core::ProcessDiscovery::TracerMemfd
  # source://datadog//lib/datadog/core/process_discovery/tracer_memfd.rb#7
  def shutdown!(logger); end
end

# Checks for rate limiting on a resource.
#
# source://datadog//lib/datadog/core/rate_limiter.rb#8
class Datadog::Core::RateLimiter
  # Checks if resource of specified size can be
  # conforms with the current limit.
  #
  # Implementations of this method are not guaranteed
  # to be side-effect free.
  #
  # @return [Boolean] whether a resource conforms with the current limit
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#16
  def allow?(size = T.unsafe(nil)); end

  # The effective rate limiting ratio based on
  # recent calls to `allow?`.
  #
  # @return [Float] recent allowance ratio
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#23
  def effective_rate; end
end

# Module to interact with core remote component
#
# source://datadog//lib/datadog/core/remote/ext.rb#5
module Datadog::Core::Remote
  class << self
    # source://datadog//lib/datadog/core/remote.rb#8
    def active_remote; end

    private

    # source://datadog//lib/datadog/core/remote.rb#14
    def components; end

    # source://datadog//lib/datadog/core/remote.rb#18
    def remote; end
  end
end

# Client communicates with the agent and sync remote configuration
#
# source://datadog//lib/datadog/core/remote/client/capabilities.rb#10
class Datadog::Core::Remote::Client
  # @return [Client] a new instance of Client
  #
  # source://datadog//lib/datadog/core/remote/client.rb#19
  def initialize(transport, capabilities, logger: T.unsafe(nil), repository: T.unsafe(nil)); end

  # Returns the value of attribute dispatcher.
  #
  # source://datadog//lib/datadog/core/remote/client.rb#17
  def dispatcher; end

  # Returns the value of attribute id.
  #
  # source://datadog//lib/datadog/core/remote/client.rb#17
  def id; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/remote/client.rb#17
  def logger; end

  # Returns the value of attribute repository.
  #
  # source://datadog//lib/datadog/core/remote/client.rb#17
  def repository; end

  # source://datadog//lib/datadog/core/remote/client.rb#29
  def sync; end

  # Returns the value of attribute transport.
  #
  # source://datadog//lib/datadog/core/remote/client.rb#17
  def transport; end

  private

  # source://datadog//lib/datadog/core/remote/client.rb#71
  def apply_config(paths, targets, contents); end

  # source://datadog//lib/datadog/core/remote/client.rb#198
  def gem_spec(name); end

  # source://datadog//lib/datadog/core/remote/client.rb#202
  def native_platform; end

  # standard:disable Metrics/MethodLength
  #
  # source://datadog//lib/datadog/core/remote/client.rb#123
  def payload; end

  # source://datadog//lib/datadog/core/remote/client.rb#42
  def process_response(response); end

  # source://datadog//lib/datadog/core/remote/client.rb#194
  def ruby_engine_version; end

  # source://datadog//lib/datadog/core/remote/client.rb#186
  def service_name; end

  # source://datadog//lib/datadog/core/remote/client.rb#190
  def tracer_version; end
end

# Capabilities
#
# source://datadog//lib/datadog/core/remote/client/capabilities.rb#12
class Datadog::Core::Remote::Client::Capabilities
  # @return [Capabilities] a new instance of Capabilities
  #
  # source://datadog//lib/datadog/core/remote/client/capabilities.rb#15
  def initialize(settings, telemetry); end

  # Returns the value of attribute base64_capabilities.
  #
  # source://datadog//lib/datadog/core/remote/client/capabilities.rb#13
  def base64_capabilities; end

  # Returns the value of attribute capabilities.
  #
  # source://datadog//lib/datadog/core/remote/client/capabilities.rb#13
  def capabilities; end

  # Returns the value of attribute products.
  #
  # source://datadog//lib/datadog/core/remote/client/capabilities.rb#13
  def products; end

  # Returns the value of attribute receivers.
  #
  # source://datadog//lib/datadog/core/remote/client/capabilities.rb#13
  def receivers; end

  private

  # source://datadog//lib/datadog/core/remote/client/capabilities.rb#58
  def capabilities_to_base64; end

  # source://datadog//lib/datadog/core/remote/client/capabilities.rb#28
  def register(settings); end

  # source://datadog//lib/datadog/core/remote/client/capabilities.rb#46
  def register_capabilities(capabilities); end

  # source://datadog//lib/datadog/core/remote/client/capabilities.rb#54
  def register_products(products); end

  # source://datadog//lib/datadog/core/remote/client/capabilities.rb#50
  def register_receivers(receivers); end
end

# source://datadog//lib/datadog/core/remote/client.rb#241
class Datadog::Core::Remote::Client::GemSpecificationFallback < ::Struct
  # source://datadog//lib/datadog/core/remote/client.rb#241
  def platform; end

  # source://datadog//lib/datadog/core/remote/client.rb#241
  def platform=(_); end

  # source://datadog//lib/datadog/core/remote/client.rb#241
  def version; end

  # source://datadog//lib/datadog/core/remote/client.rb#241
  def version=(_); end

  class << self
    # source://datadog//lib/datadog/core/remote/client.rb#241
    def [](*_arg0); end

    # source://datadog//lib/datadog/core/remote/client.rb#241
    def inspect; end

    # source://datadog//lib/datadog/core/remote/client.rb#241
    def keyword_init?; end

    # source://datadog//lib/datadog/core/remote/client.rb#241
    def members; end

    # source://datadog//lib/datadog/core/remote/client.rb#241
    def new(*_arg0); end
  end
end

# source://datadog//lib/datadog/core/remote/client.rb#15
class Datadog::Core::Remote::Client::SyncError < ::StandardError; end

# source://datadog//lib/datadog/core/remote/client.rb#13
class Datadog::Core::Remote::Client::TransportError < ::StandardError; end

# Configures the HTTP transport to communicate with the agent
# to fetch and sync the remote configuration
#
# source://datadog//lib/datadog/core/remote/component.rb#15
class Datadog::Core::Remote::Component
  # @return [Component] a new instance of Component
  #
  # source://datadog//lib/datadog/core/remote/component.rb#18
  def initialize(settings, capabilities, agent_settings, logger:); end

  # If the worker is not initialized, initialize it.
  #
  # Then, waits for one client sync to be executed if `kind` is `:once`.
  #
  # source://datadog//lib/datadog/core/remote/component.rb#82
  def barrier(_kind); end

  # Returns the value of attribute client.
  #
  # source://datadog//lib/datadog/core/remote/component.rb#16
  def client; end

  # Returns the value of attribute healthy.
  #
  # source://datadog//lib/datadog/core/remote/component.rb#16
  def healthy; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/remote/component.rb#16
  def logger; end

  # source://datadog//lib/datadog/core/remote/component.rb#87
  def shutdown!; end

  # Starts the Remote Configuration worker without waiting for first run
  #
  # source://datadog//lib/datadog/core/remote/component.rb#70
  def start; end

  # Is the Remote Configuration worker running?
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/remote/component.rb#75
  def started?; end

  class << self
    # Because the agent might not be available yet, we can't perform agent-specific checks yet, as they
    # would prevent remote configuration from ever running.
    #
    # Those checks are instead performed inside the worker loop.
    # This allows users to upgrade their agent while keeping their application running.
    #
    # source://datadog//lib/datadog/core/remote/component.rb#152
    def build(settings, agent_settings, logger:, telemetry:); end
  end
end

# Barrier provides a mechanism to fence execution until a condition happens
#
# source://datadog//lib/datadog/core/remote/component.rb#92
class Datadog::Core::Remote::Component::Barrier
  # @return [Barrier] a new instance of Barrier
  #
  # source://datadog//lib/datadog/core/remote/component.rb#93
  def initialize(timeout = T.unsafe(nil)); end

  # Release all current waiters
  #
  # source://datadog//lib/datadog/core/remote/component.rb#137
  def lift; end

  # Wait for first lift to happen, otherwise don't wait
  #
  # source://datadog//lib/datadog/core/remote/component.rb#102
  def wait_once(timeout = T.unsafe(nil)); end
end

# Configuration
#
# source://datadog//lib/datadog/core/remote/configuration/path.rb#6
class Datadog::Core::Remote::Configuration; end

# Content stores the information associated with a specific Configuration::Path
#
# source://datadog//lib/datadog/core/remote/configuration/content.rb#11
class Datadog::Core::Remote::Configuration::Content
  # @return [Content] a new instance of Content
  #
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#24
  def initialize(path:, data:); end

  # Sets this configuration as successfully applied.
  #
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#42
  def applied; end

  # Returns the value of attribute apply_error.
  #
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#21
  def apply_error; end

  # Returns the value of attribute apply_state.
  #
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#21
  def apply_state; end

  # Returns the value of attribute data.
  #
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#21
  def data; end

  # Sets this configuration as not successfully applied, with
  # a message describing the error.
  #
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#49
  def errored(error_message); end

  # Returns the value of attribute hashes.
  #
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#21
  def hashes; end

  # source://datadog//lib/datadog/core/remote/configuration/content.rb#33
  def hexdigest(type); end

  # source://datadog//lib/datadog/core/remote/configuration/content.rb#37
  def length; end

  # Returns the value of attribute path.
  #
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#21
  def path; end

  # Returns the value of attribute version.
  #
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#22
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#22
  def version=(_arg0); end

  private

  # source://datadog//lib/datadog/core/remote/configuration/content.rb#68
  def compute_and_store_hash(type); end

  class << self
    # source://datadog//lib/datadog/core/remote/configuration/content.rb#13
    def parse(hash); end

    private

    # source://datadog//lib/datadog/core/remote/configuration/content.rb#72
    def new(*_arg0); end
  end
end

# source://datadog//lib/datadog/core/remote/configuration/content.rb#54
module Datadog::Core::Remote::Configuration::Content::ApplyState; end

# Set when the configuration has been successfully applied.
#
# source://datadog//lib/datadog/core/remote/configuration/content.rb#60
Datadog::Core::Remote::Configuration::Content::ApplyState::ACKNOWLEDGED = T.let(T.unsafe(nil), Integer)

# Set when the configuration has been unsuccessfully applied.
#
# source://datadog//lib/datadog/core/remote/configuration/content.rb#63
Datadog::Core::Remote::Configuration::Content::ApplyState::ERROR = T.let(T.unsafe(nil), Integer)

# Default state of configurations.
# Set until the component consuming the configuration has acknowledged it was applied.
#
# source://datadog//lib/datadog/core/remote/configuration/content.rb#57
Datadog::Core::Remote::Configuration::Content::ApplyState::UNACKNOWLEDGED = T.let(T.unsafe(nil), Integer)

# ContentList stores a list of Conetnt instances
# It provides convinient methods for finding content base on Configuration::Path and Configuration::Target
#
# source://datadog//lib/datadog/core/remote/configuration/content.rb#77
class Datadog::Core::Remote::Configuration::ContentList < ::Array
  # source://datadog//lib/datadog/core/remote/configuration/content.rb#88
  def [](path); end

  # source://datadog//lib/datadog/core/remote/configuration/content.rb#92
  def []=(path, content); end

  # source://datadog//lib/datadog/core/remote/configuration/content.rb#96
  def delete(path); end

  # source://datadog//lib/datadog/core/remote/configuration/content.rb#84
  def find_content(path, target); end

  # source://datadog//lib/datadog/core/remote/configuration/content.rb#104
  def paths; end

  class << self
    # source://datadog//lib/datadog/core/remote/configuration/content.rb#79
    def parse(array); end
  end
end

# Stores and validates different cryptographic hash functions
#
# source://datadog//lib/datadog/core/remote/configuration/digest.rb#23
class Datadog::Core::Remote::Configuration::Digest
  # @return [Digest] a new instance of Digest
  #
  # source://datadog//lib/datadog/core/remote/configuration/digest.rb#50
  def initialize(type, hexdigest); end

  # source://datadog//lib/datadog/core/remote/configuration/digest.rb#55
  def check(content); end

  # Returns the value of attribute hexdigest.
  #
  # source://datadog//lib/datadog/core/remote/configuration/digest.rb#25
  def hexdigest; end

  # Returns the value of attribute type.
  #
  # source://datadog//lib/datadog/core/remote/configuration/digest.rb#25
  def type; end

  class << self
    # source://datadog//lib/datadog/core/remote/configuration/digest.rb#30
    def hexdigest(type, data); end
  end
end

# source://datadog//lib/datadog/core/remote/configuration/digest.rb#27
Datadog::Core::Remote::Configuration::Digest::DIGEST_CHUNK = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/core/remote/configuration/digest.rb#24
class Datadog::Core::Remote::Configuration::Digest::InvalidHashTypeError < ::StandardError; end

# Represent a list of Configuration::Digest
#
# source://datadog//lib/datadog/core/remote/configuration/digest.rb#10
class Datadog::Core::Remote::Configuration::DigestList < ::Array
  # source://datadog//lib/datadog/core/remote/configuration/digest.rb#17
  def check(content); end

  class << self
    # source://datadog//lib/datadog/core/remote/configuration/digest.rb#12
    def parse(hash); end
  end
end

# Path stores path information
#
# source://datadog//lib/datadog/core/remote/configuration/path.rb#8
class Datadog::Core::Remote::Configuration::Path
  # @return [Path] a new instance of Path
  #
  # source://datadog//lib/datadog/core/remote/configuration/path.rb#55
  def initialize(source:, product:, config_id:, name:, org_id: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/remote/configuration/path.rb#73
  def ==(other); end

  # Returns the value of attribute config_id.
  #
  # source://datadog//lib/datadog/core/remote/configuration/path.rb#53
  def config_id; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/remote/configuration/path.rb#83
  def eql?(other); end

  # source://datadog//lib/datadog/core/remote/configuration/path.rb#79
  def hash; end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/core/remote/configuration/path.rb#53
  def name; end

  # Returns the value of attribute org_id.
  #
  # source://datadog//lib/datadog/core/remote/configuration/path.rb#53
  def org_id; end

  # Returns the value of attribute product.
  #
  # source://datadog//lib/datadog/core/remote/configuration/path.rb#53
  def product; end

  # Returns the value of attribute source.
  #
  # source://datadog//lib/datadog/core/remote/configuration/path.rb#53
  def source; end

  # source://datadog//lib/datadog/core/remote/configuration/path.rb#65
  def to_s; end

  class << self
    # @raise [ParseError]
    #
    # source://datadog//lib/datadog/core/remote/configuration/path.rb#28
    def parse(path); end

    private

    # source://datadog//lib/datadog/core/remote/configuration/path.rb#63
    def new(*_arg0); end
  end
end

# source://datadog//lib/datadog/core/remote/configuration/path.rb#9
class Datadog::Core::Remote::Configuration::Path::ParseError < ::StandardError; end

# Repository
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#10
class Datadog::Core::Remote::Configuration::Repository
  # @return [Repository] a new instance of Repository
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#21
  def initialize; end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#32
  def [](path); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#44
  def commit(transaction); end

  # Returns the value of attribute contents.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#11
  def contents; end

  # Returns the value of attribute opaque_backend_state.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#11
  def opaque_backend_state; end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#28
  def paths; end

  # Returns the value of attribute root_version.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#11
  def root_version; end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#62
  def state; end

  # Returns the value of attribute targets_version.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#11
  def targets_version; end

  # @yield [_self, transaction]
  # @yieldparam _self [Datadog::Core::Remote::Configuration::Repository] the object that the method was called on
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#36
  def transaction; end
end

# source://datadog//lib/datadog/core/remote/configuration/repository.rb#231
module Datadog::Core::Remote::Configuration::Repository::Change; end

# Delete change
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#233
class Datadog::Core::Remote::Configuration::Repository::Change::Deleted
  # @return [Deleted] a new instance of Deleted
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#236
  def initialize(path, previous); end

  # Returns the value of attribute path.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#234
  def path; end

  # Returns the value of attribute previous.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#234
  def previous; end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#241
  def type; end
end

# Insert change
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#247
class Datadog::Core::Remote::Configuration::Repository::Change::Inserted
  # @return [Inserted] a new instance of Inserted
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#250
  def initialize(path, content); end

  # Returns the value of attribute content.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#248
  def content; end

  # Returns the value of attribute path.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#248
  def path; end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#255
  def type; end
end

# Update change
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#261
class Datadog::Core::Remote::Configuration::Repository::Change::Updated
  # @return [Updated] a new instance of Updated
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#264
  def initialize(path, content, previous); end

  # Returns the value of attribute content.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#262
  def content; end

  # Returns the value of attribute path.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#262
  def path; end

  # Returns the value of attribute previous.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#262
  def previous; end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#270
  def type; end
end

# Store list of Changes
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#277
class Datadog::Core::Remote::Configuration::Repository::ChangeSet < ::Array
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#282
  def add(path, previous, content); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#291
  def deleted(path, previous); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#295
  def inserted(path, content); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#278
  def paths; end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#299
  def updated(path, content, previous); end
end

# source://datadog//lib/datadog/core/remote/configuration/repository.rb#19
Datadog::Core::Remote::Configuration::Repository::INITIAL_TARGETS_VERSION = T.let(T.unsafe(nil), Integer)

# Operation
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#148
module Datadog::Core::Remote::Configuration::Repository::Operation; end

# Delete contents base on path
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#150
class Datadog::Core::Remote::Configuration::Repository::Operation::Delete
  # @return [Delete] a new instance of Delete
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#153
  def initialize(path); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#158
  def apply(repository); end

  # Returns the value of attribute path.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#151
  def path; end
end

# Insert content into the repository contents
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#168
class Datadog::Core::Remote::Configuration::Repository::Operation::Insert
  # @return [Insert] a new instance of Insert
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#171
  def initialize(path, target, content); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#178
  def apply(repository); end

  # Returns the value of attribute content.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#169
  def content; end

  # Returns the value of attribute path.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#169
  def path; end

  # Returns the value of attribute target.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#169
  def target; end
end

# Set repository metadata
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#210
class Datadog::Core::Remote::Configuration::Repository::Operation::Set
  # @return [Set] a new instance of Set
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#213
  def initialize(**options); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#219
  def apply(repository); end

  # Returns the value of attribute opaque_backend_state.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#211
  def opaque_backend_state; end

  # Returns the value of attribute targets_version.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#211
  def targets_version; end
end

# Update existimng repository's contents
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#189
class Datadog::Core::Remote::Configuration::Repository::Operation::Update
  # @return [Update] a new instance of Update
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#192
  def initialize(path, target, content); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#199
  def apply(repository); end

  # Returns the value of attribute content.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#190
  def content; end

  # Returns the value of attribute path.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#190
  def path; end

  # Returns the value of attribute target.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#190
  def target; end
end

# State store the repository state
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#67
class Datadog::Core::Remote::Configuration::Repository::State
  # @return [State] a new instance of State
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#77
  def initialize(repository); end

  # Returns the value of attribute cached_target_files.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#68
  def cached_target_files; end

  # Returns the value of attribute config_states.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#68
  def config_states; end

  # Returns the value of attribute error.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#68
  def error; end

  # Returns the value of attribute has_error.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#68
  def has_error; end

  # Returns the value of attribute opaque_backend_state.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#68
  def opaque_backend_state; end

  # Returns the value of attribute root_version.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#68
  def root_version; end

  # Returns the value of attribute targets_version.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#68
  def targets_version; end

  private

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#104
  def contents_to_cached_target_files(contents); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#90
  def contents_to_config_states(contents); end
end

# Encapsulates transaction operations
#
# source://datadog//lib/datadog/core/remote/configuration/repository.rb#123
class Datadog::Core::Remote::Configuration::Repository::Transaction
  # @return [Transaction] a new instance of Transaction
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#126
  def initialize; end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#130
  def delete(path); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#134
  def insert(path, target, content); end

  # Returns the value of attribute operations.
  #
  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#124
  def operations; end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#142
  def set(**options); end

  # source://datadog//lib/datadog/core/remote/configuration/repository.rb#138
  def update(path, target, content); end
end

# source://datadog//lib/datadog/core/remote/configuration/repository.rb#17
Datadog::Core::Remote::Configuration::Repository::UNVERIFIED_ROOT_VERSION = T.let(T.unsafe(nil), Integer)

# Target stores digest information
#
# source://datadog//lib/datadog/core/remote/configuration/target.rb#46
class Datadog::Core::Remote::Configuration::Target
  # @return [Target] a new instance of Target
  #
  # source://datadog//lib/datadog/core/remote/configuration/target.rb#59
  def initialize(digests:, length:, version:); end

  # source://datadog//lib/datadog/core/remote/configuration/target.rb#67
  def check(content); end

  # Returns the value of attribute digests.
  #
  # source://datadog//lib/datadog/core/remote/configuration/target.rb#57
  def digests; end

  # Returns the value of attribute length.
  #
  # source://datadog//lib/datadog/core/remote/configuration/target.rb#57
  def length; end

  # Returns the value of attribute version.
  #
  # source://datadog//lib/datadog/core/remote/configuration/target.rb#57
  def version; end

  class << self
    # source://datadog//lib/datadog/core/remote/configuration/target.rb#48
    def parse(hash); end

    private

    # source://datadog//lib/datadog/core/remote/configuration/target.rb#65
    def new(*_arg0); end
  end
end

# TargetMap stores information regarding Configuration::Path and Configuration::Target
#
# source://datadog//lib/datadog/core/remote/configuration/target.rb#11
class Datadog::Core::Remote::Configuration::TargetMap < ::Hash
  # @return [TargetMap] a new instance of TargetMap
  #
  # source://datadog//lib/datadog/core/remote/configuration/target.rb#35
  def initialize; end

  # Returns the value of attribute opaque_backend_state.
  #
  # source://datadog//lib/datadog/core/remote/configuration/target.rb#33
  def opaque_backend_state; end

  # Returns the value of attribute version.
  #
  # source://datadog//lib/datadog/core/remote/configuration/target.rb#33
  def version; end

  class << self
    # source://datadog//lib/datadog/core/remote/configuration/target.rb#13
    def parse(hash); end

    private

    # source://datadog//lib/datadog/core/remote/configuration/target.rb#42
    def new(*_arg0); end
  end
end

# Repository update dispatcher
#
# source://datadog//lib/datadog/core/remote/dispatcher.rb#7
class Datadog::Core::Remote::Dispatcher
  # @return [Dispatcher] a new instance of Dispatcher
  #
  # source://datadog//lib/datadog/core/remote/dispatcher.rb#10
  def initialize(receivers); end

  # source://datadog//lib/datadog/core/remote/dispatcher.rb#14
  def dispatch(changes, repository); end

  # Returns the value of attribute receivers.
  #
  # source://datadog//lib/datadog/core/remote/dispatcher.rb#8
  def receivers; end
end

# Matcher checks if the path matches
#
# source://datadog//lib/datadog/core/remote/dispatcher.rb#39
class Datadog::Core::Remote::Dispatcher::Matcher
  # @return [Matcher] a new instance of Matcher
  #
  # source://datadog//lib/datadog/core/remote/dispatcher.rb#40
  def initialize(&block); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/remote/dispatcher.rb#44
  def match?(path); end
end

# Matches on the product's path
#
# source://datadog//lib/datadog/core/remote/dispatcher.rb#49
class Datadog::Core::Remote::Dispatcher::Matcher::Product < ::Datadog::Core::Remote::Dispatcher::Matcher
  # @return [Product] a new instance of Product
  #
  # source://datadog//lib/datadog/core/remote/dispatcher.rb#50
  def initialize(products); end
end

# Store Matcher and block to be executed on a match
#
# source://datadog//lib/datadog/core/remote/dispatcher.rb#23
class Datadog::Core::Remote::Dispatcher::Receiver
  # @return [Receiver] a new instance of Receiver
  #
  # source://datadog//lib/datadog/core/remote/dispatcher.rb#24
  def initialize(matcher, &block); end

  # source://datadog//lib/datadog/core/remote/dispatcher.rb#33
  def call(repository, changes); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/remote/dispatcher.rb#29
  def match?(path); end
end

# source://datadog//lib/datadog/core/remote/ext.rb#6
module Datadog::Core::Remote::Ext; end

# source://datadog//lib/datadog/core/remote/ext.rb#9
Datadog::Core::Remote::Ext::ENV_BOOT_TIMEOUT_SECONDS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/remote/ext.rb#7
Datadog::Core::Remote::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/remote/ext.rb#8
Datadog::Core::Remote::Ext::ENV_POLL_INTERVAL_SECONDS = T.let(T.unsafe(nil), String)

# Endpoint negotiation
#
# source://datadog//lib/datadog/core/remote/negotiation.rb#9
class Datadog::Core::Remote::Negotiation
  # @return [Negotiation] a new instance of Negotiation
  #
  # source://datadog//lib/datadog/core/remote/negotiation.rb#12
  def initialize(_settings, agent_settings, logger: T.unsafe(nil), suppress_logging: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/remote/negotiation.rb#18
  def endpoint?(path); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/remote/negotiation.rb#10
  def logger; end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/remote/negotiation.rb#64
  def network_error?(error); end
end

# Provide Remote Configuration extensions to other components
#
# source://datadog//lib/datadog/core/remote/tie.rb#7
module Datadog::Core::Remote::Tie
  class << self
    # source://datadog//lib/datadog/core/remote/tie.rb#13
    def boot; end
  end
end

# source://datadog//lib/datadog/core/remote/tie.rb#8
class Datadog::Core::Remote::Tie::Boot < ::Struct
  # Returns the value of attribute barrier
  #
  # @return [Object] the current value of barrier
  #
  # source://datadog//lib/datadog/core/remote/tie.rb#8
  def barrier; end

  # Sets the attribute barrier
  #
  # @param value [Object] the value to set the attribute barrier to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/remote/tie.rb#8
  def barrier=(_); end

  # Returns the value of attribute time
  #
  # @return [Object] the current value of time
  #
  # source://datadog//lib/datadog/core/remote/tie.rb#8
  def time; end

  # Sets the attribute time
  #
  # @param value [Object] the value to set the attribute time to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/core/remote/tie.rb#8
  def time=(_); end

  class << self
    # source://datadog//lib/datadog/core/remote/tie.rb#8
    def [](*_arg0); end

    # source://datadog//lib/datadog/core/remote/tie.rb#8
    def inspect; end

    # source://datadog//lib/datadog/core/remote/tie.rb#8
    def keyword_init?; end

    # source://datadog//lib/datadog/core/remote/tie.rb#8
    def members; end

    # source://datadog//lib/datadog/core/remote/tie.rb#8
    def new(*_arg0); end
  end
end

# Extend Remote Configuration abilities with Tracing
#
# source://datadog//lib/datadog/core/remote/tie/tracing.rb#10
module Datadog::Core::Remote::Tie::Tracing
  class << self
    # Tag per-request Remote Configuration metadata using Tracing
    #
    # source://datadog//lib/datadog/core/remote/tie/tracing.rb#12
    def tag(boot, span); end
  end
end

# source://datadog//lib/datadog/core/remote/transport/negotiation.rb#27
module Datadog::Core::Remote::Transport; end

# source://datadog//lib/datadog/core/remote/transport/config.rb#10
module Datadog::Core::Remote::Transport::Config; end

# Data transfer object for encoded traces
#
# source://datadog//lib/datadog/core/remote/transport/config.rb#12
class Datadog::Core::Remote::Transport::Config::EncodedParcel
  include ::Datadog::Core::Transport::Parcel

  # source://datadog//lib/datadog/core/remote/transport/config.rb#15
  def count; end
end

# Config request
#
# source://datadog//lib/datadog/core/remote/transport/config.rb#21
class Datadog::Core::Remote::Transport::Config::Request < ::Datadog::Core::Transport::Request; end

# Config response
#
# source://datadog//lib/datadog/core/remote/transport/config.rb#25
module Datadog::Core::Remote::Transport::Config::Response
  # Returns the value of attribute client_configs.
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#26
  def client_configs; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#28
  def empty?; end

  # Returns the value of attribute roots.
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#26
  def roots; end

  # Returns the value of attribute target_files.
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#26
  def target_files; end

  # Returns the value of attribute targets.
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#26
  def targets; end
end

# Config transport
#
# source://datadog//lib/datadog/core/remote/transport/config.rb#34
class Datadog::Core::Remote::Transport::Config::Transport
  # @return [Transport] a new instance of Transport
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#37
  def initialize(apis, default_api, logger: T.unsafe(nil)); end

  # Returns the value of attribute apis.
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#35
  def apis; end

  # Returns the value of attribute client.
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#35
  def client; end

  # source://datadog//lib/datadog/core/remote/transport/config.rb#53
  def current_api; end

  # Returns the value of attribute current_api_id.
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#35
  def current_api_id; end

  # Returns the value of attribute default_api.
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#35
  def default_api; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#35
  def logger; end

  # there is only one transport! it's negotiation!
  #
  # source://datadog//lib/datadog/core/remote/transport/config.rb#45
  def send_config(payload); end
end

# Namespace for HTTP transport components
#
# source://datadog//lib/datadog/core/remote/transport/http/client.rb#15
module Datadog::Core::Remote::Transport::HTTP
  private

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # source://datadog//lib/datadog/core/remote/transport/http.rb#34
  def root(agent_settings:, logger: T.unsafe(nil), api_version: T.unsafe(nil), headers: T.unsafe(nil)); end

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # source://datadog//lib/datadog/core/remote/transport/http.rb#58
  def v7(agent_settings:, logger: T.unsafe(nil), api_version: T.unsafe(nil), headers: T.unsafe(nil)); end

  class << self
    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # source://datadog//lib/datadog/core/remote/transport/http.rb#34
    def root(agent_settings:, logger: T.unsafe(nil), api_version: T.unsafe(nil), headers: T.unsafe(nil)); end

    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # source://datadog//lib/datadog/core/remote/transport/http.rb#58
    def v7(agent_settings:, logger: T.unsafe(nil), api_version: T.unsafe(nil), headers: T.unsafe(nil)); end
  end
end

# Namespace for API components
#
# source://datadog//lib/datadog/core/remote/transport/http/api.rb#16
module Datadog::Core::Remote::Transport::HTTP::API
  private

  # source://datadog//lib/datadog/core/remote/transport/http/api.rb#23
  def defaults; end

  class << self
    # source://datadog//lib/datadog/core/remote/transport/http/api.rb#23
    def defaults; end
  end
end

# source://datadog//lib/datadog/core/remote/transport/http/api.rb#39
class Datadog::Core::Remote::Transport::HTTP::API::Instance < ::Datadog::Core::Transport::HTTP::API::Instance
  include ::Datadog::Core::Remote::Transport::HTTP::Config::API::Instance
  include ::Datadog::Core::Remote::Transport::HTTP::Negotiation::API::Instance
end

# Default API versions
#
# source://datadog//lib/datadog/core/remote/transport/http/api.rb#18
Datadog::Core::Remote::Transport::HTTP::API::ROOT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/remote/transport/http/api.rb#44
class Datadog::Core::Remote::Transport::HTTP::API::Spec < ::Datadog::Core::Transport::HTTP::API::Spec
  include ::Datadog::Core::Remote::Transport::HTTP::Config::API::Spec
  include ::Datadog::Core::Remote::Transport::HTTP::Negotiation::API::Spec
end

# source://datadog//lib/datadog/core/remote/transport/http/api.rb#19
Datadog::Core::Remote::Transport::HTTP::API::V7 = T.let(T.unsafe(nil), String)

# Routes, encodes, and sends tracer data to the trace agent via HTTP.
#
# source://datadog//lib/datadog/core/remote/transport/http/client.rb#17
class Datadog::Core::Remote::Transport::HTTP::Client
  include ::Datadog::Core::Remote::Transport::HTTP::Negotiation::Client
  include ::Datadog::Core::Remote::Transport::HTTP::Config::Client

  # @return [Client] a new instance of Client
  #
  # source://datadog//lib/datadog/core/remote/transport/http/client.rb#20
  def initialize(api, logger: T.unsafe(nil)); end

  # Returns the value of attribute api.
  #
  # source://datadog//lib/datadog/core/remote/transport/http/client.rb#18
  def api; end

  # source://datadog//lib/datadog/core/remote/transport/http/client.rb#41
  def build_env(request); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/remote/transport/http/client.rb#18
  def logger; end

  # source://datadog//lib/datadog/core/remote/transport/http/client.rb#25
  def send_request(request, &block); end
end

# HTTP transport behavior for remote configuration
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#18
module Datadog::Core::Remote::Transport::HTTP::Config; end

# source://datadog//lib/datadog/core/remote/transport/http/config.rb#186
module Datadog::Core::Remote::Transport::HTTP::Config::API; end

# Endpoint for remote configuration
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#218
class Datadog::Core::Remote::Transport::HTTP::Config::API::Endpoint < ::Datadog::Core::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#223
  def initialize(path, encoder); end

  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#228
  def call(env, &block); end

  # Returns the value of attribute encoder.
  #
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#221
  def encoder; end
end

# source://datadog//lib/datadog/core/remote/transport/http/config.rb#219
Datadog::Core::Remote::Transport::HTTP::Config::API::Endpoint::HEADER_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Extensions for HTTP API Instance
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#203
module Datadog::Core::Remote::Transport::HTTP::Config::API::Instance
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#204
  def send_config(env); end
end

# Extensions for HTTP API Spec
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#188
module Datadog::Core::Remote::Transport::HTTP::Config::API::Spec
  # Returns the value of attribute config.
  #
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#189
  def config; end

  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#191
  def config=(endpoint); end

  # @raise [Core::Transport::HTTP::API::Spec::EndpointNotDefinedError]
  #
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#195
  def send_config(env, &block); end
end

# Extensions for HTTP client
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#178
module Datadog::Core::Remote::Transport::HTTP::Config::Client
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#179
  def send_config_payload(request); end
end

# Response from HTTP transport for remote configuration
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#20
class Datadog::Core::Remote::Transport::HTTP::Config::Response
  include ::Datadog::Core::Transport::HTTP::Response
  include ::Datadog::Core::Remote::Transport::Config::Response

  # standard:disable Metrics/AbcSize,Metrics/CyclomaticComplexity,Metrics/MethodLength,Metrics/PerceivedComplexity
  #
  # @raise [AgentErrorResponse]
  # @return [Response] a new instance of Response
  #
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#24
  def initialize(http_response, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#117
  def inspect; end
end

# When the agent returned an error response to our request
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#141
class Datadog::Core::Remote::Transport::HTTP::Config::Response::AgentErrorResponse < ::Datadog::Core::Remote::Transport::HTTP::Config::Response::ConfigError
  # @return [AgentErrorResponse] a new instance of AgentErrorResponse
  #
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#142
  def initialize(code, body); end
end

# Base class for Remote Configuration Config errors
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#137
class Datadog::Core::Remote::Transport::HTTP::Config::Response::ConfigError < ::StandardError; end

# When value decoding fails
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#159
class Datadog::Core::Remote::Transport::HTTP::Config::Response::DecodeError < ::Datadog::Core::Remote::Transport::HTTP::Config::Response::ConfigError
  # @return [DecodeError] a new instance of DecodeError
  #
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#160
  def initialize(key, value); end
end

# When an expected key is missing
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#128
class Datadog::Core::Remote::Transport::HTTP::Config::Response::KeyError < ::StandardError
  # @return [KeyError] a new instance of KeyError
  #
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#129
  def initialize(key); end
end

# When value parsing fails
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#168
class Datadog::Core::Remote::Transport::HTTP::Config::Response::ParseError < ::Datadog::Core::Remote::Transport::HTTP::Config::Response::ConfigError
  # @return [ParseError] a new instance of ParseError
  #
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#169
  def initialize(key, value); end
end

# When an expected value type is incorrect
#
# source://datadog//lib/datadog/core/remote/transport/http/config.rb#150
class Datadog::Core::Remote::Transport::HTTP::Config::Response::TypeError < ::Datadog::Core::Remote::Transport::HTTP::Config::Response::ConfigError
  # @return [TypeError] a new instance of TypeError
  #
  # source://datadog//lib/datadog/core/remote/transport/http/config.rb#151
  def initialize(type, value); end
end

# HTTP transport behavior for agent feature negotiation
#
# source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#16
module Datadog::Core::Remote::Transport::HTTP::Negotiation; end

# source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#43
module Datadog::Core::Remote::Transport::HTTP::Negotiation::API; end

# Endpoint for negotiation
#
# source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#75
class Datadog::Core::Remote::Transport::HTTP::Negotiation::API::Endpoint < ::Datadog::Core::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#76
  def initialize(path); end

  # source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#80
  def call(env, &block); end
end

# Extensions for HTTP API Instance
#
# source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#60
module Datadog::Core::Remote::Transport::HTTP::Negotiation::API::Instance
  # source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#61
  def send_info(env); end
end

# Extensions for HTTP API Spec
#
# source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#45
module Datadog::Core::Remote::Transport::HTTP::Negotiation::API::Spec
  # Returns the value of attribute info.
  #
  # source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#46
  def info; end

  # source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#48
  def info=(endpoint); end

  # @raise [Core::Transport::HTTP::API::Spec::EndpointNotDefinedError]
  #
  # source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#52
  def send_info(env, &block); end
end

# Extensions for HTTP client
#
# source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#35
module Datadog::Core::Remote::Transport::HTTP::Negotiation::Client
  # source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#36
  def send_info_payload(request); end
end

# Response from HTTP transport for agent feature negotiation
#
# source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#18
class Datadog::Core::Remote::Transport::HTTP::Negotiation::Response
  include ::Datadog::Core::Transport::HTTP::Response
  include ::Datadog::Core::Remote::Transport::Negotiation::Response

  # @return [Response] a new instance of Response
  #
  # source://datadog//lib/datadog/core/remote/transport/http/negotiation.rb#22
  def initialize(http_response, options = T.unsafe(nil)); end
end

# source://datadog//lib/datadog/core/remote/transport/negotiation.rb#28
module Datadog::Core::Remote::Transport::Negotiation; end

# Negotiation request
#
# source://datadog//lib/datadog/core/remote/transport/negotiation.rb#30
class Datadog::Core::Remote::Transport::Negotiation::Request < ::Datadog::Core::Transport::Request; end

# Negotiation response
#
# source://datadog//lib/datadog/core/remote/transport/negotiation.rb#34
module Datadog::Core::Remote::Transport::Negotiation::Response
  # The agent configuration. These are configured by the user when starting the agent, as well as any defaults.
  #
  # @return [Hash]
  #
  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#47
  def config; end

  # The HTTP endpoints the agent supports.
  #
  # @return [Array<String>]
  #
  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#47
  def endpoints; end

  # Returns the value of attribute span_events.
  #
  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#47
  def span_events; end

  # The version of the agent.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#47
  def version; end
end

# Negotiation transport
#
# source://datadog//lib/datadog/core/remote/transport/negotiation.rb#51
class Datadog::Core::Remote::Transport::Negotiation::Transport
  # @return [Transport] a new instance of Transport
  #
  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#54
  def initialize(apis, default_api, logger: T.unsafe(nil)); end

  # Returns the value of attribute apis.
  #
  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#52
  def apis; end

  # Returns the value of attribute client.
  #
  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#52
  def client; end

  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#67
  def current_api; end

  # Returns the value of attribute current_api_id.
  #
  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#52
  def current_api_id; end

  # Returns the value of attribute default_api.
  #
  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#52
  def default_api; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#52
  def logger; end

  # source://datadog//lib/datadog/core/remote/transport/negotiation.rb#61
  def send_info; end
end

# Worker executes a block every interval on a separate Thread
#
# source://datadog//lib/datadog/core/remote/worker.rb#7
class Datadog::Core::Remote::Worker
  # @raise [ArgumentError]
  # @return [Worker] a new instance of Worker
  #
  # source://datadog//lib/datadog/core/remote/worker.rb#8
  def initialize(interval:, logger:, &block); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/remote/worker.rb#23
  def logger; end

  # source://datadog//lib/datadog/core/remote/worker.rb#25
  def start; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/remote/worker.rb#73
  def started?; end

  # source://datadog//lib/datadog/core/remote/worker.rb#52
  def stop; end

  private

  # source://datadog//lib/datadog/core/remote/worker.rb#79
  def acquire_lock; end

  # source://datadog//lib/datadog/core/remote/worker.rb#97
  def call; end

  # source://datadog//lib/datadog/core/remote/worker.rb#87
  def poll(interval); end

  # source://datadog//lib/datadog/core/remote/worker.rb#83
  def release_lock; end
end

# source://datadog//lib/datadog/core/runtime/ext.rb#5
module Datadog::Core::Runtime; end

# source://datadog//lib/datadog/core/runtime/ext.rb#7
module Datadog::Core::Runtime::Ext; end

# Metrics
#
# source://datadog//lib/datadog/core/runtime/ext.rb#14
module Datadog::Core::Runtime::Ext::Metrics; end

# source://datadog//lib/datadog/core/runtime/ext.rb#15
Datadog::Core::Runtime::Ext::Metrics::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#17
Datadog::Core::Runtime::Ext::Metrics::METRIC_CLASS_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#22
Datadog::Core::Runtime::Ext::Metrics::METRIC_CONSTANT_CACHE_INVALIDATIONS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#23
Datadog::Core::Runtime::Ext::Metrics::METRIC_CONSTANT_CACHE_MISSES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#18
Datadog::Core::Runtime::Ext::Metrics::METRIC_GC_PREFIX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#20
Datadog::Core::Runtime::Ext::Metrics::METRIC_GLOBAL_CONSTANT_STATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#21
Datadog::Core::Runtime::Ext::Metrics::METRIC_GLOBAL_METHOD_STATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#19
Datadog::Core::Runtime::Ext::Metrics::METRIC_THREAD_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#24
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_CODE_GC_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#25
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_CODE_REGION_SIZE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#26
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_FREED_CODE_SIZE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#27
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_FREED_PAGE_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#28
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_INLINE_CODE_SIZE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#29
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_LIVE_PAGE_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#30
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_OBJECT_SHAPE_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#31
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_OUTLINED_CODE_SIZE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#33
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_RATIO_IN_YJIT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#32
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_YJIT_ALLOC_SIZE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#35
Datadog::Core::Runtime::Ext::Metrics::TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#8
Datadog::Core::Runtime::Ext::TAG_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#9
Datadog::Core::Runtime::Ext::TAG_LANG = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/runtime/ext.rb#10
Datadog::Core::Runtime::Ext::TAG_PROCESS_ID = T.let(T.unsafe(nil), String)

# For generating runtime metrics
#
# source://datadog//lib/datadog/core/runtime/metrics.rb#16
class Datadog::Core::Runtime::Metrics < ::Datadog::Core::Metrics::Client
  # @return [Metrics] a new instance of Metrics
  #
  # source://datadog//lib/datadog/core/runtime/metrics.rb#17
  def initialize(telemetry:, **options); end

  # source://datadog//lib/datadog/core/runtime/metrics.rb#103
  def default_metric_options; end

  # Flush all runtime metrics to Statsd client
  #
  # source://datadog//lib/datadog/core/runtime/metrics.rb#45
  def flush; end

  # source://datadog//lib/datadog/core/runtime/metrics.rb#91
  def gc_metrics; end

  # Associate service with runtime metrics
  #
  # source://datadog//lib/datadog/core/runtime/metrics.rb#30
  def register_service(service); end

  # source://datadog//lib/datadog/core/runtime/metrics.rb#97
  def try_flush; end

  private

  # source://datadog//lib/datadog/core/runtime/metrics.rb#124
  def compile_service_tags!; end

  # standard:disable Metrics/MethodLength
  #
  # source://datadog//lib/datadog/core/runtime/metrics.rb#151
  def flush_yjit_stats; end

  # source://datadog//lib/datadog/core/runtime/metrics.rb#146
  def gauge_if_not_nil(metric_name, metric_value); end

  # source://datadog//lib/datadog/core/runtime/metrics.rb#130
  def nested_gc_metric(prefix, k, v); end

  # Returns the value of attribute runtime_id_enabled.
  #
  # source://datadog//lib/datadog/core/runtime/metrics.rb#119
  def runtime_id_enabled; end

  # Returns the value of attribute service_tags.
  #
  # source://datadog//lib/datadog/core/runtime/metrics.rb#119
  def service_tags; end

  # Returns the value of attribute services.
  #
  # source://datadog//lib/datadog/core/runtime/metrics.rb#119
  def services; end

  # source://datadog//lib/datadog/core/runtime/metrics.rb#142
  def to_metric_name(str); end
end

# Semaphore pattern implementation, as described in documentation for
# ConditionVariable.
#
# @api private
#
# source://datadog//lib/datadog/core/semaphore.rb#9
class Datadog::Core::Semaphore
  # @api private
  # @return [Semaphore] a new instance of Semaphore
  #
  # source://datadog//lib/datadog/core/semaphore.rb#10
  def initialize; end

  # @api private
  #
  # source://datadog//lib/datadog/core/semaphore.rb#15
  def signal; end

  # @api private
  #
  # source://datadog//lib/datadog/core/semaphore.rb#21
  def wait(timeout = T.unsafe(nil)); end

  private

  # @api private
  #
  # source://datadog//lib/datadog/core/semaphore.rb#32
  def wake; end

  # @api private
  #
  # source://datadog//lib/datadog/core/semaphore.rb#32
  def wake_lock; end
end

# This module builds a hash of tags.
#
# When changing or adding the tags, make sure they are kept in sync with
# https://docs.google.com/spreadsheets/d/1LOGMf4c4Avbtn36uZ2SWvhIGKRPLM1BoWkUP4JYj7hA/
# (Datadog internal link).
#
# @api private
#
# source://datadog//lib/datadog/core/tag_builder.rb#16
module Datadog::Core::TagBuilder
  class << self
    # @api private
    #
    # source://datadog//lib/datadog/core/tag_builder.rb#17
    def fixed_environment_tags; end

    # @api private
    #
    # source://datadog//lib/datadog/core/tag_builder.rb#48
    def serialize_tags(tags); end

    # @api private
    #
    # source://datadog//lib/datadog/core/tag_builder.rb#30
    def tags(settings); end
  end
end

# source://datadog//lib/datadog/core/telemetry/ext.rb#5
module Datadog::Core::Telemetry; end

# Telemetry entrypoint, coordinates sending telemetry events at various points in app lifecycle.
# Note: Telemetry does not spawn its worker thread in fork processes, thus no telemetry is sent in forked processes.
#
# @api private
#
# source://datadog//lib/datadog/core/telemetry/component.rb#21
class Datadog::Core::Telemetry::Component
  include ::Datadog::Core::Utils::Forking::ClassExtensions
  include ::Datadog::Core::Utils::Forking
  include ::Datadog::Core::Telemetry::Logging

  # @api private
  # @param enabled [Boolean] Determines whether telemetry events should be sent to the API
  # @return [Component] a new instance of Component
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#47
  def initialize(*args, **kwargs, &block); end

  # Report application endpoints
  #
  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#171
  def app_endpoints_loaded(endpoints, page_size: T.unsafe(nil)); end

  # Report configuration changes caused by Remote Configuration.
  #
  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#164
  def client_configuration_change!(changes); end

  # Decremenets a count metric.
  #
  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#185
  def dec(namespace, metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#107
  def disable!; end

  # Tracks distribution metric.
  #
  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#200
  def distribution(namespace, metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#134
  def emit_closing!; end

  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#24
  def enabled; end

  # Wait for the worker to send out all events that have already
  # been queued, up to 15 seconds. Returns whether all events have
  # been flushed.
  #
  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#157
  def flush; end

  # Tracks gauge metric.
  #
  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#190
  def gauge(namespace, metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # Increments a count metric.
  #
  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#180
  def inc(namespace, metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#140
  def integrations_change!; end

  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#146
  def log!(event); end

  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#24
  def logger; end

  # Tracks rate metric.
  #
  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#195
  def rate(namespace, metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#124
  def shutdown!; end

  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#112
  def start(initial_event_is_change = T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#24
  def transport; end

  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/component.rb#24
  def worker; end

  class << self
    # @api private
    #
    # source://datadog//lib/datadog/core/telemetry/component.rb#29
    def build(settings, agent_settings, logger); end
  end
end

# @api private
#
# source://datadog//lib/datadog/core/telemetry/component.rb#22
Datadog::Core::Telemetry::Component::ENDPOINT_COLLECTION_MESSAGE_LIMIT = T.let(T.unsafe(nil), Integer)

# Class that emits telemetry events
#
# source://datadog//lib/datadog/core/telemetry/emitter.rb#12
class Datadog::Core::Telemetry::Emitter
  extend ::Datadog::Core::Utils::Forking

  # @param transport [Datadog::Core::Telemetry::Transport::Telemetry::Transport] Transport object that can be used to send telemetry requests
  # @return [Emitter] a new instance of Emitter
  #
  # source://datadog//lib/datadog/core/telemetry/emitter.rb#19
  def initialize(transport, logger: T.unsafe(nil), debug: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/telemetry/emitter.rb#25
  def debug?; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/telemetry/emitter.rb#13
  def logger; end

  # Retrieves and emits a TelemetryRequest object based on the request type specified
  #
  # source://datadog//lib/datadog/core/telemetry/emitter.rb#30
  def request(event); end

  # Returns the value of attribute transport.
  #
  # source://datadog//lib/datadog/core/telemetry/emitter.rb#13
  def transport; end

  class << self
    # Initializes a Sequence object to track seq_id if not already initialized; else returns stored
    # Sequence object
    #
    # source://datadog//lib/datadog/core/telemetry/emitter.rb#49
    def sequence; end
  end
end

# Collection of telemetry events.
#
# @api private
#
# source://datadog//lib/datadog/core/telemetry/event.rb#12
module Datadog::Core::Telemetry::Event
  extend ::Datadog::Core::Utils::Forking

  class << self
    # returns sequence that increments every time the configuration changes
    #
    # @api private
    #
    # source://datadog//lib/datadog/core/telemetry/event.rb#16
    def configuration_sequence; end
  end
end

# Telemetry class for the 'app-client-configuration-change' event
#
# source://datadog//lib/datadog/core/telemetry/event/app_client_configuration_change.rb#10
class Datadog::Core::Telemetry::Event::AppClientConfigurationChange < ::Datadog::Core::Telemetry::Event::Base
  # @return [AppClientConfigurationChange] a new instance of AppClientConfigurationChange
  #
  # source://datadog//lib/datadog/core/telemetry/event/app_client_configuration_change.rb#17
  def initialize(changes, origin); end

  # source://datadog//lib/datadog/core/telemetry/event/app_client_configuration_change.rb#53
  def ==(other); end

  # Returns the value of attribute changes.
  #
  # source://datadog//lib/datadog/core/telemetry/event/app_client_configuration_change.rb#11
  def changes; end

  # source://datadog//lib/datadog/core/telemetry/event/app_client_configuration_change.rb#27
  def configuration; end

  # source://datadog//lib/datadog/core/telemetry/event/app_client_configuration_change.rb#57
  def eql?(other); end

  # source://datadog//lib/datadog/core/telemetry/event/app_client_configuration_change.rb#59
  def hash; end

  # Returns the value of attribute origin.
  #
  # source://datadog//lib/datadog/core/telemetry/event/app_client_configuration_change.rb#11
  def origin; end

  # source://datadog//lib/datadog/core/telemetry/event/app_client_configuration_change.rb#23
  def payload; end

  # source://datadog//lib/datadog/core/telemetry/event/app_client_configuration_change.rb#13
  def type; end
end

# Telemetry class for the 'app-closing' event
#
# source://datadog//lib/datadog/core/telemetry/event/app_closing.rb#10
class Datadog::Core::Telemetry::Event::AppClosing < ::Datadog::Core::Telemetry::Event::Base
  # source://datadog//lib/datadog/core/telemetry/event/app_closing.rb#11
  def type; end
end

# Telemetry class for the 'app-dependencies-loaded' event
#
# source://datadog//lib/datadog/core/telemetry/event/app_dependencies_loaded.rb#10
class Datadog::Core::Telemetry::Event::AppDependenciesLoaded < ::Datadog::Core::Telemetry::Event::Base
  # source://datadog//lib/datadog/core/telemetry/event/app_dependencies_loaded.rb#15
  def payload; end

  # source://datadog//lib/datadog/core/telemetry/event/app_dependencies_loaded.rb#11
  def type; end

  private

  # source://datadog//lib/datadog/core/telemetry/event/app_dependencies_loaded.rb#21
  def dependencies; end
end

# Telemetry event class for sending 'app-endpoints' payload
#
# source://datadog//lib/datadog/core/telemetry/event/app_endpoints_loaded.rb#10
class Datadog::Core::Telemetry::Event::AppEndpointsLoaded < ::Datadog::Core::Telemetry::Event::Base
  # @return [AppEndpointsLoaded] a new instance of AppEndpointsLoaded
  #
  # source://datadog//lib/datadog/core/telemetry/event/app_endpoints_loaded.rb#11
  def initialize(endpoints, is_first:); end

  # source://datadog//lib/datadog/core/telemetry/event/app_endpoints_loaded.rb#20
  def payload; end

  # source://datadog//lib/datadog/core/telemetry/event/app_endpoints_loaded.rb#16
  def type; end
end

# Telemetry class for the 'app-heartbeat' event
#
# source://datadog//lib/datadog/core/telemetry/event/app_heartbeat.rb#10
class Datadog::Core::Telemetry::Event::AppHeartbeat < ::Datadog::Core::Telemetry::Event::Base
  # source://datadog//lib/datadog/core/telemetry/event/app_heartbeat.rb#11
  def type; end
end

# Telemetry class for the 'app-integrations-change' event
#
# source://datadog//lib/datadog/core/telemetry/event/app_integrations_change.rb#10
class Datadog::Core::Telemetry::Event::AppIntegrationsChange < ::Datadog::Core::Telemetry::Event::Base
  # source://datadog//lib/datadog/core/telemetry/event/app_integrations_change.rb#15
  def payload; end

  # source://datadog//lib/datadog/core/telemetry/event/app_integrations_change.rb#11
  def type; end

  private

  # source://datadog//lib/datadog/core/telemetry/event/app_integrations_change.rb#21
  def integrations; end

  # source://datadog//lib/datadog/core/telemetry/event/app_integrations_change.rb#44
  def patch_error(integration); end
end

# Telemetry class for the 'app-started' event
#
# source://datadog//lib/datadog/core/telemetry/event/app_started.rb#10
class Datadog::Core::Telemetry::Event::AppStarted < ::Datadog::Core::Telemetry::Event::Base
  # @return [AppStarted] a new instance of AppStarted
  #
  # source://datadog//lib/datadog/core/telemetry/event/app_started.rb#11
  def initialize(agent_settings:); end

  # source://datadog//lib/datadog/core/telemetry/event/app_started.rb#19
  def payload; end

  # source://datadog//lib/datadog/core/telemetry/event/app_started.rb#15
  def type; end

  private

  # standard:enable Metrics/AbcSize
  # standard:enable Metrics/MethodLength
  #
  # source://datadog//lib/datadog/core/telemetry/event/app_started.rb#221
  def agent_transport; end

  # `origin`: Source of the configuration. One of :
  # - `fleet_stable_config`: configuration is set via the fleet automation Datadog UI
  # - `local_stable_config`: configuration set via a user-managed file
  # - `env_var`: configurations that are set through environment variables
  # - `jvm_prop`: JVM system properties passed on the command line
  # - `code`: configurations that are set through the customer application
  # - `dd_config`: set by the dd.yaml file or json
  # - `remote_config`: values that are set using remote config
  # - `app.config`: only applies to .NET
  # - `default`: set when the user has not set any configuration for the key (defaults to a value)
  # - `unknown`: set for cases where it is difficult/not possible to determine the source of a config.
  #
  # source://datadog//lib/datadog/core/telemetry/event/app_started.rb#241
  def conf_value(name, value, seq_id, origin); end

  # standard:disable Metrics/AbcSize
  # standard:disable Metrics/MethodLength
  #
  # source://datadog//lib/datadog/core/telemetry/event/app_started.rb#76
  def configuration; end

  # source://datadog//lib/datadog/core/telemetry/event/app_started.rb#272
  def get_telemetry_origin(config, config_path); end

  # source://datadog//lib/datadog/core/telemetry/event/app_started.rb#263
  def install_signature; end

  # source://datadog//lib/datadog/core/telemetry/event/app_started.rb#31
  def products; end

  # source://datadog//lib/datadog/core/telemetry/event/app_started.rb#253
  def to_value(value); end
end

# source://datadog//lib/datadog/core/telemetry/event/app_started.rb#55
Datadog::Core::Telemetry::Event::AppStarted::TARGET_OPTIONS = T.let(T.unsafe(nil), Array)

# Base class for all Telemetry V2 events.
#
# source://datadog//lib/datadog/core/telemetry/event/base.rb#8
class Datadog::Core::Telemetry::Event::Base
  # Override equality to allow for deduplication
  # The basic implementation is to check if the other object is an instance of the same class.
  # This works for events that have no attributes.
  # For events with attributes, you should override this method to compare the attributes.
  #
  # source://datadog//lib/datadog/core/telemetry/event/base.rb#25
  def ==(other); end

  # Override equality to allow for deduplication
  # The basic implementation is to check if the other object is an instance of the same class.
  # This works for events that have no attributes.
  # For events with attributes, you should override this method to compare the attributes.
  #
  # @see #==
  #
  # source://datadog//lib/datadog/core/telemetry/event/base.rb#30
  def eql?(other); end

  # @see #==
  #
  # source://datadog//lib/datadog/core/telemetry/event/base.rb#33
  def hash; end

  # The JSON payload for the event.
  #
  # source://datadog//lib/datadog/core/telemetry/event/base.rb#17
  def payload; end

  # The type of the event.
  # It must be one of the stings defined in the Telemetry V2
  # specification for event names.
  #
  # @raise [NotImplementedError]
  #
  # source://datadog//lib/datadog/core/telemetry/event/base.rb#12
  def type; end
end

# Telemetry class for the 'distributions' event
#
# source://datadog//lib/datadog/core/telemetry/event/distributions.rb#10
class Datadog::Core::Telemetry::Event::Distributions < ::Datadog::Core::Telemetry::Event::GenerateMetrics
  # source://datadog//lib/datadog/core/telemetry/event/distributions.rb#11
  def type; end
end

# Telemetry class for the 'generate-metrics' event
#
# source://datadog//lib/datadog/core/telemetry/event/generate_metrics.rb#10
class Datadog::Core::Telemetry::Event::GenerateMetrics < ::Datadog::Core::Telemetry::Event::Base
  # @return [GenerateMetrics] a new instance of GenerateMetrics
  #
  # source://datadog//lib/datadog/core/telemetry/event/generate_metrics.rb#17
  def initialize(namespace, metric_series); end

  # source://datadog//lib/datadog/core/telemetry/event/generate_metrics.rb#30
  def ==(other); end

  # source://datadog//lib/datadog/core/telemetry/event/generate_metrics.rb#34
  def eql?(other); end

  # source://datadog//lib/datadog/core/telemetry/event/generate_metrics.rb#36
  def hash; end

  # Returns the value of attribute metric_series.
  #
  # source://datadog//lib/datadog/core/telemetry/event/generate_metrics.rb#11
  def metric_series; end

  # Returns the value of attribute namespace.
  #
  # source://datadog//lib/datadog/core/telemetry/event/generate_metrics.rb#11
  def namespace; end

  # source://datadog//lib/datadog/core/telemetry/event/generate_metrics.rb#23
  def payload; end

  # source://datadog//lib/datadog/core/telemetry/event/generate_metrics.rb#13
  def type; end
end

# Telemetry class for the 'logs' event.
# Logs with the same content are deduplicated at flush time.
#
# source://datadog//lib/datadog/core/telemetry/event/log.rb#11
class Datadog::Core::Telemetry::Event::Log < ::Datadog::Core::Telemetry::Event::Base
  # @param count [Integer] the number of times the log was emitted. Used for deduplication.
  # @param level [Symbol, String] the log level. Either :error, :warn, 'ERROR', or 'WARN'.
  # @param message [String] the log message
  # @param stack_trace [String, nil] the stack trace
  # @return [Log] a new instance of Log
  #
  # source://datadog//lib/datadog/core/telemetry/event/log.rb#29
  def initialize(message:, level:, stack_trace: T.unsafe(nil), count: T.unsafe(nil)); end

  # override equality to allow for deduplication
  #
  # source://datadog//lib/datadog/core/telemetry/event/log.rb#61
  def ==(other); end

  # Returns the value of attribute count.
  #
  # source://datadog//lib/datadog/core/telemetry/event/log.rb#19
  def count; end

  # override equality to allow for deduplication
  #
  # source://datadog//lib/datadog/core/telemetry/event/log.rb#67
  def eql?(other); end

  # source://datadog//lib/datadog/core/telemetry/event/log.rb#69
  def hash; end

  # Returns the value of attribute level.
  #
  # source://datadog//lib/datadog/core/telemetry/event/log.rb#19
  def level; end

  # Returns the value of attribute message.
  #
  # source://datadog//lib/datadog/core/telemetry/event/log.rb#19
  def message; end

  # source://datadog//lib/datadog/core/telemetry/event/log.rb#47
  def payload; end

  # Returns the value of attribute stack_trace.
  #
  # source://datadog//lib/datadog/core/telemetry/event/log.rb#19
  def stack_trace; end

  # source://datadog//lib/datadog/core/telemetry/event/log.rb#21
  def type; end
end

# source://datadog//lib/datadog/core/telemetry/event/log.rb#12
Datadog::Core::Telemetry::Event::Log::LEVELS = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/core/telemetry/event/log.rb#17
Datadog::Core::Telemetry::Event::Log::LEVELS_STRING = T.let(T.unsafe(nil), Array)

# Telemetry class for the 'message-batch' event.
#
# source://datadog//lib/datadog/core/telemetry/event/message_batch.rb#8
class Datadog::Core::Telemetry::Event::MessageBatch < ::Datadog::Core::Telemetry::Event::Base
  # @return [MessageBatch] a new instance of MessageBatch
  #
  # source://datadog//lib/datadog/core/telemetry/event/message_batch.rb#15
  def initialize(events); end

  # source://datadog//lib/datadog/core/telemetry/event/message_batch.rb#29
  def ==(other); end

  # source://datadog//lib/datadog/core/telemetry/event/message_batch.rb#33
  def eql?(other); end

  # Returns the value of attribute events.
  #
  # source://datadog//lib/datadog/core/telemetry/event/message_batch.rb#9
  def events; end

  # source://datadog//lib/datadog/core/telemetry/event/message_batch.rb#35
  def hash; end

  # source://datadog//lib/datadog/core/telemetry/event/message_batch.rb#20
  def payload; end

  # source://datadog//lib/datadog/core/telemetry/event/message_batch.rb#11
  def type; end
end

# app-client-configuration-change event emitted instead of
# app-started event for telemetry startups other than the initial
# one in a process.
#
# dd-trace-rb generally creates a new component tree whenever
# the tracer is reconfigured via Datadog.configure (with some
# components potentially reused, if their configuration has not
# changed). Telemetry system tests on the other hand expect there
# to be one "tracer" per process, and do not permit multiple
# app-started events to be emitted.
#
# To resolve this conflict, we replace second and onward app-started
# events with app-client-configuration-change events.
# To avoid diffing configuration, we send all parameters that are
# sent in app-started event.
#
# It's a "quick fix" on top of a not-so-quick fix that omitted
# second and subsequent app-started (and app-closing) events in the
# first place, and only works with the existing hackery of app-started
# and app-closing events.
#
# source://datadog//lib/datadog/core/telemetry/event/synth_app_client_configuration_change.rb#29
class Datadog::Core::Telemetry::Event::SynthAppClientConfigurationChange < ::Datadog::Core::Telemetry::Event::AppStarted
  # source://datadog//lib/datadog/core/telemetry/event/synth_app_client_configuration_change.rb#34
  def payload; end

  # source://datadog//lib/datadog/core/telemetry/event/synth_app_client_configuration_change.rb#30
  def type; end
end

# source://datadog//lib/datadog/core/telemetry/ext.rb#6
module Datadog::Core::Telemetry::Ext; end

# source://datadog//lib/datadog/core/telemetry/ext.rb#15
Datadog::Core::Telemetry::Ext::ENV_AGENTLESS_URL_OVERRIDE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/telemetry/ext.rb#11
Datadog::Core::Telemetry::Ext::ENV_DEPENDENCY_COLLECTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/telemetry/ext.rb#7
Datadog::Core::Telemetry::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/telemetry/ext.rb#9
Datadog::Core::Telemetry::Ext::ENV_HEARTBEAT_INTERVAL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/telemetry/ext.rb#12
Datadog::Core::Telemetry::Ext::ENV_INSTALL_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/telemetry/ext.rb#14
Datadog::Core::Telemetry::Ext::ENV_INSTALL_TIME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/telemetry/ext.rb#13
Datadog::Core::Telemetry::Ext::ENV_INSTALL_TYPE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/telemetry/ext.rb#16
Datadog::Core::Telemetry::Ext::ENV_LOG_COLLECTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/telemetry/ext.rb#10
Datadog::Core::Telemetry::Ext::ENV_METRICS_AGGREGATION_INTERVAL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/telemetry/ext.rb#8
Datadog::Core::Telemetry::Ext::ENV_METRICS_ENABLED = T.let(T.unsafe(nil), String)

# === INTERNAL USAGE ONLY ===
#
# Report telemetry logs via delegating to the telemetry component instance via mutex.
#
# IMPORTANT: Invoking this method during the lifecycle of component initialization will
# be no-op instead.
#
# For developer using this module:
#   read: lib/datadog/core/telemetry/logging.rb
#
# source://datadog//lib/datadog/core/telemetry/logger.rb#15
module Datadog::Core::Telemetry::Logger
  class << self
    # source://datadog//lib/datadog/core/telemetry/logger.rb#21
    def error(description); end

    # source://datadog//lib/datadog/core/telemetry/logger.rb#17
    def report(exception, level: T.unsafe(nil), description: T.unsafe(nil), pii_safe: T.unsafe(nil)); end

    private

    # source://datadog//lib/datadog/core/telemetry/logger.rb#27
    def instance; end
  end
end

# === INTERNAL USAGE ONLY ===
#
# Logging interface for sending telemetry logs... so we can fix them.
#
# For developer using this module:
# - MUST NOT provide any sensitive information (PII)
# - SHOULD reduce the data cardinality for batching/aggregation
#
# Before using it, ask yourself:
# - Do we need to know about this (ie. internal error or client error)?
# - How severe/critical is this error? (ie. error, warning, fatal)
# - What information needed to make it actionable?
#
# source://datadog//lib/datadog/core/telemetry/logging.rb#23
module Datadog::Core::Telemetry::Logging
  # source://datadog//lib/datadog/core/telemetry/logging.rb#69
  def error(description); end

  # source://datadog//lib/datadog/core/telemetry/logging.rb#48
  def report(exception, level: T.unsafe(nil), description: T.unsafe(nil), pii_safe: T.unsafe(nil)); end
end

# Extract datadog stack trace from the exception
#
# source://datadog//lib/datadog/core/telemetry/logging.rb#25
module Datadog::Core::Telemetry::Logging::DatadogStackTrace
  class << self
    # source://datadog//lib/datadog/core/telemetry/logging.rb#28
    def from(exception); end
  end
end

# source://datadog//lib/datadog/core/telemetry/logging.rb#26
Datadog::Core::Telemetry::Logging::DatadogStackTrace::GEM_ROOT = T.let(T.unsafe(nil), String)

# Telemetry metrics data model (internal Datadog metrics for client libraries)
#
# source://datadog//lib/datadog/core/telemetry/metric.rb#7
module Datadog::Core::Telemetry::Metric; end

# Base class for all metric types
#
# source://datadog//lib/datadog/core/telemetry/metric.rb#9
class Datadog::Core::Telemetry::Metric::Base
  # @param common [Boolean] true if the metric is common for all languages, false for Ruby-specific metric
  # @param name [String] metric name
  # @param tags [Array<String>|Hash{String=>String}] metric tags as hash or array of "tag:val" strings
  # @return [Base] a new instance of Base
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#15
  def initialize(name, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#44
  def ==(other); end

  # Returns the value of attribute common.
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#10
  def common; end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#50
  def eql?(other); end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#52
  def hash; end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#22
  def id; end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#10
  def name; end

  # Returns the value of attribute tags.
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#10
  def tags; end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#34
  def to_h; end

  # @raise [NotImplementedError]
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#26
  def track(value); end

  # @raise [NotImplementedError]
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#30
  def type; end

  # Returns the value of attribute values.
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#10
  def values; end

  private

  # source://datadog//lib/datadog/core/telemetry/metric.rb#58
  def tags_to_array(tags); end
end

# Count metric adds up all the submitted values in a time interval. This would be suitable for a
# metric tracking the number of website hits, for instance.
#
# source://datadog//lib/datadog/core/telemetry/metric.rb#100
class Datadog::Core::Telemetry::Metric::Count < ::Datadog::Core::Telemetry::Metric::Base
  # source://datadog//lib/datadog/core/telemetry/metric.rb#107
  def track(value); end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#103
  def type; end
end

# source://datadog//lib/datadog/core/telemetry/metric.rb#101
Datadog::Core::Telemetry::Metric::Count::TYPE = T.let(T.unsafe(nil), String)

# Distribution metric represents the global statistical distribution of a set of values.
#
# source://datadog//lib/datadog/core/telemetry/metric.rb#164
class Datadog::Core::Telemetry::Metric::Distribution < ::Datadog::Core::Telemetry::Metric::Base
  # distribution metric data does not have type field
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#177
  def to_h; end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#171
  def track(value); end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#167
  def type; end
end

# source://datadog//lib/datadog/core/telemetry/metric.rb#165
Datadog::Core::Telemetry::Metric::Distribution::TYPE = T.let(T.unsafe(nil), String)

# A gauge type takes the last value reported during the interval. This type would make sense for tracking RAM or
# CPU usage, where taking the last value provides a representative picture of the hosts behavior during the time
# interval.
#
# source://datadog//lib/datadog/core/telemetry/metric.rb#123
class Datadog::Core::Telemetry::Metric::Gauge < ::Datadog::Core::Telemetry::Metric::IntervalMetric
  # source://datadog//lib/datadog/core/telemetry/metric.rb#130
  def track(value); end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#126
  def type; end
end

# source://datadog//lib/datadog/core/telemetry/metric.rb#124
Datadog::Core::Telemetry::Metric::Gauge::TYPE = T.let(T.unsafe(nil), String)

# Base class for metrics that require aggregation interval
#
# source://datadog//lib/datadog/core/telemetry/metric.rb#66
class Datadog::Core::Telemetry::Metric::IntervalMetric < ::Datadog::Core::Telemetry::Metric::Base
  # @param common [Boolean] true if the metric is common for all languages, false for Ruby-specific metric
  # @param interval [Integer] metrics aggregation interval in seconds
  # @param name [String] metric name
  # @param tags [Array<String>|Hash{String=>String}] metric tags as hash of array of "tag:val" strings
  # @raise [ArgumentError]
  # @return [IntervalMetric] a new instance of IntervalMetric
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#73
  def initialize(name, interval:, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#87
  def ==(other); end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#91
  def eql?(other); end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#93
  def hash; end

  # Returns the value of attribute interval.
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#67
  def interval; end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#81
  def to_h; end
end

# The rate type takes the count and divides it by the length of the time interval. This is useful if youre
# interested in the number of hits per second.
#
# source://datadog//lib/datadog/core/telemetry/metric.rb#143
class Datadog::Core::Telemetry::Metric::Rate < ::Datadog::Core::Telemetry::Metric::IntervalMetric
  # @return [Rate] a new instance of Rate
  #
  # source://datadog//lib/datadog/core/telemetry/metric.rb#146
  def initialize(name, interval:, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#156
  def track(value = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/telemetry/metric.rb#152
  def type; end
end

# source://datadog//lib/datadog/core/telemetry/metric.rb#144
Datadog::Core::Telemetry::Metric::Rate::TYPE = T.let(T.unsafe(nil), String)

# MetricsCollection is a thread-safe collection of metrics per namespace
#
# source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#10
class Datadog::Core::Telemetry::MetricsCollection
  # @return [MetricsCollection] a new instance of MetricsCollection
  #
  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#13
  def initialize(namespace, aggregation_interval:); end

  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#28
  def dec(metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#43
  def distribution(metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#48
  def flush!; end

  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#33
  def gauge(metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#23
  def inc(metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # Returns the value of attribute interval.
  #
  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#11
  def interval; end

  # Returns the value of attribute namespace.
  #
  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#11
  def namespace; end

  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#38
  def rate(metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#71
  def fetch_or_add_distribution(metric, value); end

  # source://datadog//lib/datadog/core/telemetry/metrics_collection.rb#63
  def fetch_or_add_metric(metric, value); end
end

# MetricsManager aggregates and flushes metrics and distributions
#
# source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#9
class Datadog::Core::Telemetry::MetricsManager
  # @return [MetricsManager] a new instance of MetricsManager
  #
  # source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#12
  def initialize(aggregation_interval:, enabled:); end

  # source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#28
  def dec(namespace, metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#67
  def disable!; end

  # source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#52
  def distribution(namespace, metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # Returns the value of attribute enabled.
  #
  # source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#10
  def enabled; end

  # source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#60
  def flush!; end

  # source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#36
  def gauge(namespace, metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#20
  def inc(namespace, metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#44
  def rate(namespace, metric_name, value, tags: T.unsafe(nil), common: T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/core/telemetry/metrics_manager.rb#73
  def fetch_or_create_collection(namespace); end
end

# Module defining methods for collecting metadata for telemetry
#
# source://datadog//lib/datadog/core/telemetry/request.rb#10
module Datadog::Core::Telemetry::Request
  class << self
    # source://datadog//lib/datadog/core/telemetry/request.rb#14
    def build_payload(event, seq_id, api_version: T.unsafe(nil), debug: T.unsafe(nil)); end

    private

    # source://datadog//lib/datadog/core/telemetry/request.rb#32
    def application; end

    # source://datadog//lib/datadog/core/telemetry/request.rb#58
    def host; end
  end
end

# source://datadog//lib/datadog/core/telemetry/transport/http/client.rb#14
module Datadog::Core::Telemetry::Transport; end

# Namespace for HTTP transport components
#
# source://datadog//lib/datadog/core/telemetry/transport/http/client.rb#15
module Datadog::Core::Telemetry::Transport::HTTP
  private

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http.rb#42
  def agent_telemetry(agent_settings:, logger:, api_version: T.unsafe(nil), headers: T.unsafe(nil)); end

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http.rb#17
  def agentless_telemetry(agent_settings:, logger:, api_key: T.unsafe(nil), api_version: T.unsafe(nil), headers: T.unsafe(nil)); end

  class << self
    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # source://datadog//lib/datadog/core/telemetry/transport/http.rb#42
    def agent_telemetry(agent_settings:, logger:, api_version: T.unsafe(nil), headers: T.unsafe(nil)); end

    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # source://datadog//lib/datadog/core/telemetry/transport/http.rb#17
    def agentless_telemetry(agent_settings:, logger:, api_key: T.unsafe(nil), api_version: T.unsafe(nil), headers: T.unsafe(nil)); end
  end
end

# Namespace for API components
#
# source://datadog//lib/datadog/core/telemetry/transport/http/api.rb#15
module Datadog::Core::Telemetry::Transport::HTTP::API
  private

  # source://datadog//lib/datadog/core/telemetry/transport/http/api.rb#22
  def defaults; end

  class << self
    # source://datadog//lib/datadog/core/telemetry/transport/http/api.rb#22
    def defaults; end
  end
end

# source://datadog//lib/datadog/core/telemetry/transport/http/api.rb#18
Datadog::Core::Telemetry::Transport::HTTP::API::AGENTLESS_TELEMETRY = T.let(T.unsafe(nil), String)

# Default API versions
#
# source://datadog//lib/datadog/core/telemetry/transport/http/api.rb#17
Datadog::Core::Telemetry::Transport::HTTP::API::AGENT_TELEMETRY = T.let(T.unsafe(nil), String)

# Routes, encodes, and sends DI data to the trace agent via HTTP.
#
# source://datadog//lib/datadog/core/telemetry/transport/http/client.rb#17
class Datadog::Core::Telemetry::Transport::HTTP::Client
  include ::Datadog::Core::Telemetry::Transport::HTTP::Telemetry::Client

  # @return [Client] a new instance of Client
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http/client.rb#20
  def initialize(api, logger:); end

  # Returns the value of attribute api.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http/client.rb#18
  def api; end

  # source://datadog//lib/datadog/core/telemetry/transport/http/client.rb#41
  def build_env(request); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http/client.rb#18
  def logger; end

  # source://datadog//lib/datadog/core/telemetry/transport/http/client.rb#25
  def send_request(request, &block); end
end

# source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#14
module Datadog::Core::Telemetry::Transport::HTTP::Telemetry; end

# source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#23
module Datadog::Core::Telemetry::Transport::HTTP::Telemetry::API; end

# source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#44
class Datadog::Core::Telemetry::Transport::HTTP::Telemetry::API::Endpoint < ::Datadog::Core::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#50
  def initialize(path, encoder); end

  # source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#55
  def call(env, &block); end

  # Returns the value of attribute encoder.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#47
  def encoder; end

  # source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#67
  def headers(request_type:, api_key:, api_version: T.unsafe(nil)); end
end

# source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#45
Datadog::Core::Telemetry::Transport::HTTP::Telemetry::API::Endpoint::HEADER_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#24
class Datadog::Core::Telemetry::Transport::HTTP::Telemetry::API::Instance < ::Datadog::Core::Transport::HTTP::API::Instance
  # @raise [Core::Transport::HTTP::API::Instance::EndpointNotSupportedError]
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#25
  def send_telemetry(env); end
end

# source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#34
class Datadog::Core::Telemetry::Transport::HTTP::Telemetry::API::Spec < ::Datadog::Core::Transport::HTTP::API::Spec
  # @raise [Core::Transport::HTTP::API::Spec::EndpointNotDefinedError]
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#37
  def send_telemetry(env, &block); end

  # Returns the value of attribute telemetry.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#35
  def telemetry; end

  # Sets the attribute telemetry
  #
  # @param value the value to set the attribute telemetry to.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#35
  def telemetry=(_arg0); end
end

# source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#15
module Datadog::Core::Telemetry::Transport::HTTP::Telemetry::Client
  # source://datadog//lib/datadog/core/telemetry/transport/http/telemetry.rb#16
  def send_telemetry_payload(request); end
end

# source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#11
module Datadog::Core::Telemetry::Transport::Telemetry; end

# source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#12
class Datadog::Core::Telemetry::Transport::Telemetry::EncodedParcel
  include ::Datadog::Core::Transport::Parcel
end

# source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#16
class Datadog::Core::Telemetry::Transport::Telemetry::Request < ::Datadog::Core::Transport::Request
  # @return [Request] a new instance of Request
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#20
  def initialize(request_type, parcel, api_key); end

  # Returns the value of attribute api_key.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#18
  def api_key; end

  # Returns the value of attribute request_type.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#17
  def request_type; end
end

# source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#27
class Datadog::Core::Telemetry::Transport::Telemetry::Transport
  # @return [Transport] a new instance of Transport
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#31
  def initialize(apis, default_api, logger:); end

  # Returns the value of attribute api_key.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#29
  def api_key; end

  # Sets the attribute api_key
  #
  # @param value the value to set the attribute api_key to.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#29
  def api_key=(_arg0); end

  # Returns the value of attribute apis.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#28
  def apis; end

  # Returns the value of attribute client.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#28
  def client; end

  # Returns the value of attribute current_api_id.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#28
  def current_api_id; end

  # Returns the value of attribute default_api.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#28
  def default_api; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#28
  def logger; end

  # source://datadog//lib/datadog/core/telemetry/transport/telemetry.rb#38
  def send_telemetry(request_type:, payload:); end
end

# Accumulates events and sends them to the API at a regular interval, including heartbeat event.
#
# source://datadog//lib/datadog/core/telemetry/worker.rb#13
class Datadog::Core::Telemetry::Worker
  include ::Datadog::Core::Workers::Queue::PrependedMethods
  include ::Datadog::Core::Workers::IntervalLoop::PrependedMethods
  include ::Datadog::Core::Workers::Async::Thread::PrependedMethods
  include ::Datadog::Core::Workers::Polling::PrependedMethods
  include ::Datadog::Core::Workers::Queue
  include ::Datadog::Core::Workers::Polling
  include ::Datadog::Core::Workers::IntervalLoop
  include ::Datadog::Core::Workers::Async::Thread

  # @return [Worker] a new instance of Worker
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#20
  def initialize(heartbeat_interval_seconds:, metrics_aggregation_interval_seconds:, emitter:, metrics_manager:, dependency_collection:, logger:, enabled: T.unsafe(nil), shutdown_timeout: T.unsafe(nil), buffer_size: T.unsafe(nil)); end

  # Returns true if event was enqueued, nil if not.
  # While returning false may seem more reasonable, the only reason
  # for not enqueueing event (presently) is that telemetry is disabled
  # altogether, and in this case other methods return nil.
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#81
  def enqueue(event); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#92
  def failed_initial_event?; end

  # Wait for the worker to send out all events that have already
  # been queued, up to 15 seconds. Returns whether all events have
  # been flushed.
  #
  # @api private
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#105
  def flush; end

  # Returns the value of attribute initial_event.
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#55
  def initial_event; end

  # Returns the value of attribute initial_event_once.
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#54
  def initial_event_once; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#53
  def logger; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#96
  def need_initial_event?; end

  # source://datadog//lib/datadog/core/telemetry/worker.rb#135
  def perform(*args); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#88
  def sent_initial_event?; end

  # Returns true if worker thread is successfully started,
  # false if worker thread was not started but telemetry is enabled,
  # nil if telemetry is disabled.
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#60
  def start(initial_event); end

  # source://datadog//lib/datadog/core/telemetry/worker.rb#71
  def stop(force_stop = T.unsafe(nil), timeout = T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/core/telemetry/worker.rb#223
  def buffer_klass; end

  # Deduplicate logs by counting the number of repeated occurrences of the same log
  # entry and replacing them with a single entry with the calculated `count` value.
  # Non-log events are unchanged.
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#246
  def deduplicate_logs(events); end

  # source://datadog//lib/datadog/core/telemetry/worker.rb#215
  def dequeue; end

  # source://datadog//lib/datadog/core/telemetry/worker.rb#231
  def disable!; end

  # source://datadog//lib/datadog/core/telemetry/worker.rb#236
  def disable_on_not_found!(response); end

  # source://datadog//lib/datadog/core/telemetry/worker.rb#166
  def flush_events(events); end

  # source://datadog//lib/datadog/core/telemetry/worker.rb#173
  def heartbeat!; end

  # source://datadog//lib/datadog/core/telemetry/worker.rb#207
  def send_event(event); end

  # source://datadog//lib/datadog/core/telemetry/worker.rb#179
  def started!; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/telemetry/worker.rb#219
  def work_pending?; end
end

# source://datadog//lib/datadog/core/telemetry/worker.rb#18
Datadog::Core::Telemetry::Worker::APP_STARTED_EVENT_RETRIES = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/core/telemetry/worker.rb#17
Datadog::Core::Telemetry::Worker::DEFAULT_BUFFER_MAX_SIZE = T.let(T.unsafe(nil), Integer)

# Implementation of the Token Bucket metering algorithm
# for rate limiting.
#
# @see https://en.wikipedia.org/wiki/Token_bucket Token bucket
#
# source://datadog//lib/datadog/core/rate_limiter.rb#31
class Datadog::Core::TokenBucket < ::Datadog::Core::RateLimiter
  # @param max_tokens [Numeric] Limit of available tokens
  # @param rate [Numeric] Allowance rate, in units per second
  #   if rate is negative, always allow
  #   if rate is zero, never allow
  # @raise [ArgumentError]
  # @return [TokenBucket] a new instance of TokenBucket
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#38
  def initialize(rate, max_tokens = T.unsafe(nil)); end

  # Checks if a message of provided +size+
  # conforms with the current bucket limit.
  #
  # If it does, return +true+ and remove +size+
  # tokens from the bucket.
  # If it does not, return +false+ without affecting
  # the tokens from the bucket.
  #
  # @return [Boolean] +true+ if message conforms with current bucket limit
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#66
  def allow?(size = T.unsafe(nil)); end

  # @return [Numeric] number of tokens currently available
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#100
  def available_tokens; end

  # Ratio of 'conformance' per 'total messages' checked
  # on this bucket
  #
  # Returns +1.0+ when no messages have been checked yet.
  #
  # @return [Float] Conformance ratio, between +[0,1]+
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#93
  def current_window_rate; end

  # Ratio of 'conformance' per 'total messages' checked
  # averaged for the past 2 buckets
  #
  # Returns +1.0+ when no messages have been checked yet.
  #
  # @return [Float] Conformance ratio, between +[0,1]+
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#78
  def effective_rate; end

  # Returns the value of attribute max_tokens.
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#32
  def max_tokens; end

  # Returns the value of attribute rate.
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#32
  def rate; end

  private

  # source://datadog//lib/datadog/core/rate_limiter.rb#126
  def increment_conforming_count; end

  # source://datadog//lib/datadog/core/rate_limiter.rb#122
  def increment_total_count; end

  # source://datadog//lib/datadog/core/rate_limiter.rb#106
  def refill_since_last_message; end

  # source://datadog//lib/datadog/core/rate_limiter.rb#117
  def refill_tokens(size); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#130
  def should_allow?(size = T.unsafe(nil)); end

  # Sets and Updates the past two 1 second windows for which
  # the rate limiter must compute it's rate over and updates
  # the total count, and conforming message count if +allowed+
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#150
  def update_rate_counts(allowed); end
end

# source://datadog//lib/datadog/core/transport/ext.rb#6
module Datadog::Core::Transport; end

# source://datadog//lib/datadog/core/transport/ext.rb#8
module Datadog::Core::Transport::Ext; end

# source://datadog//lib/datadog/core/transport/ext.rb#9
module Datadog::Core::Transport::Ext::HTTP; end

# source://datadog//lib/datadog/core/transport/ext.rb#19
Datadog::Core::Transport::Ext::HTTP::HEADER_CLIENT_COMPUTED_STATS = T.let(T.unsafe(nil), String)

# Tells agent that `_dd.top_level` metrics have been set by the tracer.
# The agent will not calculate top-level spans but instead trust the tracer tagging.
#
# This prevents partially flushed traces being mistakenly marked as top-level.
#
# Setting this header to any non-empty value enables this feature.
#
# source://datadog//lib/datadog/core/transport/ext.rb#18
Datadog::Core::Transport::Ext::HTTP::HEADER_CLIENT_COMPUTED_TOP_LEVEL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/transport/ext.rb#10
Datadog::Core::Transport::Ext::HTTP::HEADER_CONTAINER_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/transport/ext.rb#11
Datadog::Core::Transport::Ext::HTTP::HEADER_DD_API_KEY = T.let(T.unsafe(nil), String)

# Header that prevents the Net::HTTP integration from tracing internal trace requests.
# Set it to any value to skip tracing.
#
# source://datadog//lib/datadog/core/transport/ext.rb#29
Datadog::Core::Transport::Ext::HTTP::HEADER_DD_INTERNAL_UNTRACED_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/transport/ext.rb#20
Datadog::Core::Transport::Ext::HTTP::HEADER_META_LANG = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/transport/ext.rb#22
Datadog::Core::Transport::Ext::HTTP::HEADER_META_LANG_INTERPRETER = T.let(T.unsafe(nil), String)

# Use for distinguishing between CRuby, JRuby, and TruffleRuby.
#
# source://datadog//lib/datadog/core/transport/ext.rb#24
Datadog::Core::Transport::Ext::HTTP::HEADER_META_LANG_INTERPRETER_VENDOR = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/transport/ext.rb#21
Datadog::Core::Transport::Ext::HTTP::HEADER_META_LANG_VERSION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/transport/ext.rb#25
Datadog::Core::Transport::Ext::HTTP::HEADER_META_TRACER_VERSION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/transport/ext.rb#32
module Datadog::Core::Transport::Ext::Test; end

# source://datadog//lib/datadog/core/transport/ext.rb#33
Datadog::Core::Transport::Ext::Test::ADAPTER = T.let(T.unsafe(nil), Symbol)

# source://datadog//lib/datadog/core/transport/ext.rb#36
module Datadog::Core::Transport::Ext::UnixSocket; end

# source://datadog//lib/datadog/core/transport/ext.rb#37
Datadog::Core::Transport::Ext::UnixSocket::ADAPTER = T.let(T.unsafe(nil), Symbol)

# source://datadog//lib/datadog/core/transport/ext.rb#38
Datadog::Core::Transport::Ext::UnixSocket::DEFAULT_PATH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/core/transport/ext.rb#39
Datadog::Core::Transport::Ext::UnixSocket::DEFAULT_TIMEOUT_SECONDS = T.let(T.unsafe(nil), Integer)

# HTTP transport
#
# source://datadog//lib/datadog/core/transport/http/env.rb#6
module Datadog::Core::Transport::HTTP
  private

  # Helper function that delegates to Builder.new
  # but is under HTTP namespace so that client code requires this file
  # to get the adapters configured, and not the builder directly.
  #
  # source://datadog//lib/datadog/core/transport/http.rb#32
  def build(api_instance_class:, agent_settings:, logger: T.unsafe(nil), api_version: T.unsafe(nil), headers: T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/core/transport/http.rb#46
  def default_headers; end

  class << self
    # Helper function that delegates to Builder.new
    # but is under HTTP namespace so that client code requires this file
    # to get the adapters configured, and not the builder directly.
    #
    # source://datadog//lib/datadog/core/transport/http.rb#32
    def build(api_instance_class:, agent_settings:, logger: T.unsafe(nil), api_version: T.unsafe(nil), headers: T.unsafe(nil), &block); end

    # source://datadog//lib/datadog/core/transport/http.rb#46
    def default_headers; end
  end
end

# source://datadog//lib/datadog/core/transport/http/api/endpoint.rb#9
module Datadog::Core::Transport::HTTP::API; end

# Endpoint
#
# source://datadog//lib/datadog/core/transport/http/api/endpoint.rb#11
class Datadog::Core::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://datadog//lib/datadog/core/transport/http/api/endpoint.rb#16
  def initialize(verb, path); end

  # @yield [env]
  #
  # source://datadog//lib/datadog/core/transport/http/api/endpoint.rb#21
  def call(env); end

  # Returns the value of attribute path.
  #
  # source://datadog//lib/datadog/core/transport/http/api/endpoint.rb#12
  def path; end

  # Returns the value of attribute verb.
  #
  # source://datadog//lib/datadog/core/transport/http/api/endpoint.rb#12
  def verb; end
end

# Extension for Map with adds fallback versions.
#
# source://datadog//lib/datadog/core/transport/http/api/fallbacks.rb#9
module Datadog::Core::Transport::HTTP::API::Fallbacks
  # source://datadog//lib/datadog/core/transport/http/api/fallbacks.rb#18
  def add_fallbacks!(fallbacks); end

  # source://datadog//lib/datadog/core/transport/http/api/fallbacks.rb#10
  def fallbacks; end

  # source://datadog//lib/datadog/core/transport/http/api/fallbacks.rb#14
  def with_fallbacks(fallbacks); end
end

# An API configured with adapter and routes
#
# source://datadog//lib/datadog/core/transport/http/api/instance.rb#9
class Datadog::Core::Transport::HTTP::API::Instance
  # @return [Instance] a new instance of Instance
  #
  # source://datadog//lib/datadog/core/transport/http/api/instance.rb#32
  def initialize(spec, adapter, options = T.unsafe(nil)); end

  # Returns the value of attribute adapter.
  #
  # source://datadog//lib/datadog/core/transport/http/api/instance.rb#27
  def adapter; end

  # source://datadog//lib/datadog/core/transport/http/api/instance.rb#42
  def call(env); end

  # source://datadog//lib/datadog/core/transport/http/api/instance.rb#38
  def encoder; end

  # Returns the value of attribute headers.
  #
  # source://datadog//lib/datadog/core/transport/http/api/instance.rb#27
  def headers; end

  # Returns the value of attribute spec.
  #
  # source://datadog//lib/datadog/core/transport/http/api/instance.rb#27
  def spec; end
end

# Raised when an endpoint is invoked on an API that is not the
# of expected API class for that endpoint.
#
# source://datadog//lib/datadog/core/transport/http/api/instance.rb#12
class Datadog::Core::Transport::HTTP::API::Instance::EndpointNotSupportedError < ::StandardError
  # @return [EndpointNotSupportedError] a new instance of EndpointNotSupportedError
  #
  # source://datadog//lib/datadog/core/transport/http/api/instance.rb#15
  def initialize(endpoint_name, spec); end

  # Returns the value of attribute endpoint_name.
  #
  # source://datadog//lib/datadog/core/transport/http/api/instance.rb#13
  def endpoint_name; end

  # source://datadog//lib/datadog/core/transport/http/api/instance.rb#22
  def message; end

  # Returns the value of attribute spec.
  #
  # source://datadog//lib/datadog/core/transport/http/api/instance.rb#13
  def spec; end
end

# A mapping of API version => API Routes/Instance
#
# source://datadog//lib/datadog/core/transport/http/api/map.rb#11
class Datadog::Core::Transport::HTTP::API::Map < ::Hash
  include ::Datadog::Core::Transport::HTTP::API::Fallbacks
end

# Specification for an HTTP API
# Defines behaviors without specific configuration details.
#
# source://datadog//lib/datadog/core/transport/http/api/spec.rb#10
class Datadog::Core::Transport::HTTP::API::Spec
  # @return [Spec] a new instance of Spec
  # @yield [_self]
  # @yieldparam _self [Datadog::Core::Transport::HTTP::API::Spec] the object that the method was called on
  #
  # source://datadog//lib/datadog/core/transport/http/api/spec.rb#28
  def initialize; end
end

# Raised when an endpoint is invoked on an API that did not
# define that endpoint.
#
# source://datadog//lib/datadog/core/transport/http/api/spec.rb#13
class Datadog::Core::Transport::HTTP::API::Spec::EndpointNotDefinedError < ::StandardError
  # @return [EndpointNotDefinedError] a new instance of EndpointNotDefinedError
  #
  # source://datadog//lib/datadog/core/transport/http/api/spec.rb#16
  def initialize(endpoint_name, spec); end

  # Returns the value of attribute endpoint_name.
  #
  # source://datadog//lib/datadog/core/transport/http/api/spec.rb#14
  def endpoint_name; end

  # source://datadog//lib/datadog/core/transport/http/api/spec.rb#23
  def message; end

  # Returns the value of attribute spec.
  #
  # source://datadog//lib/datadog/core/transport/http/api/spec.rb#14
  def spec; end
end

# source://datadog//lib/datadog/core/transport/http/adapters/registry.rb#7
module Datadog::Core::Transport::HTTP::Adapters; end

# Adapter for Net::HTTP
#
# source://datadog//lib/datadog/core/transport/http/adapters/net.rb#12
class Datadog::Core::Transport::HTTP::Adapters::Net
  # @return [Net] a new instance of Net
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#19
  def initialize(agent_settings); end

  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#42
  def call(env); end

  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#50
  def get(env); end

  # Returns the value of attribute hostname.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#13
  def hostname; end

  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#89
  def net_http_path_from_env(env); end

  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#30
  def open(&block); end

  # Returns the value of attribute port.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#13
  def port; end

  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#62
  def post(env); end

  # Returns the value of attribute ssl.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#13
  def ssl; end

  # Returns the value of attribute timeout.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#13
  def timeout; end

  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#85
  def url; end

  class << self
    # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#26
    def build(agent_settings); end
  end
end

# A wrapped Net::HTTP response that implements the Transport::Response interface
#
# source://datadog//lib/datadog/core/transport/http/adapters/net.rb#114
class Datadog::Core::Transport::HTTP::Adapters::Net::Response
  include ::Datadog::Core::Transport::Response

  # @return [Response] a new instance of Response
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#119
  def initialize(http_response); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#153
  def client_error?; end

  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#129
  def code; end

  # Returns the value of attribute http_response.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#117
  def http_response; end

  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#165
  def inspect; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#147
  def not_found?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#135
  def ok?; end

  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#123
  def payload; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#159
  def server_error?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#141
  def unsupported?; end
end

# Raised when called with an unknown HTTP method
#
# source://datadog//lib/datadog/core/transport/http/adapters/net.rb#105
class Datadog::Core::Transport::HTTP::Adapters::Net::UnknownHTTPMethod < ::StandardError
  # @return [UnknownHTTPMethod] a new instance of UnknownHTTPMethod
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#108
  def initialize(verb); end

  # Returns the value of attribute verb.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/net.rb#106
  def verb; end
end

# List of available adapters
#
# source://datadog//lib/datadog/core/transport/http/adapters/registry.rb#9
class Datadog::Core::Transport::HTTP::Adapters::Registry
  # @return [Registry] a new instance of Registry
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/registry.rb#10
  def initialize; end

  # source://datadog//lib/datadog/core/transport/http/adapters/registry.rb#14
  def get(name); end

  # source://datadog//lib/datadog/core/transport/http/adapters/registry.rb#18
  def set(klass, name = T.unsafe(nil)); end
end

# Adapter for testing
#
# source://datadog//lib/datadog/core/transport/http/adapters/test.rb#11
class Datadog::Core::Transport::HTTP::Adapters::Test
  # @deprecated Positional parameters are deprecated. Use named parameters instead.
  # @param buffer [Array] an optional array that will capture all spans sent to this adapter, defaults to +nil+
  # @return [Test] a new instance of Test
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#18
  def initialize(buffer = T.unsafe(nil), **options); end

  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#33
  def add_request(env); end

  # Returns the value of attribute buffer.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#12
  def buffer; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#29
  def buffer?; end

  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#24
  def call(env); end

  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#37
  def set_status!(status); end

  # Returns the value of attribute status.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#12
  def status; end

  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#41
  def url; end
end

# Response for test adapter
#
# source://datadog//lib/datadog/core/transport/http/adapters/test.rb#45
class Datadog::Core::Transport::HTTP::Adapters::Test::Response
  include ::Datadog::Core::Transport::Response

  # @return [Response] a new instance of Response
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#52
  def initialize(code, body = T.unsafe(nil)); end

  # Returns the value of attribute body.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#48
  def body; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#73
  def client_error?; end

  # Returns the value of attribute code.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#48
  def code; end

  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#81
  def inspect; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#69
  def not_found?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#61
  def ok?; end

  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#57
  def payload; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#77
  def server_error?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/test.rb#65
  def unsupported?; end
end

# Adapter for Unix sockets
#
# source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#13
class Datadog::Core::Transport::HTTP::Adapters::UnixSocket < ::Datadog::Core::Transport::HTTP::Adapters::Net
  # @deprecated Positional parameters are deprecated. Use named parameters instead.
  # @return [UnixSocket] a new instance of UnixSocket
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#22
  def initialize(uds_path = T.unsafe(nil), **options); end

  # Returns the value of attribute filepath.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#14
  def filepath; end

  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#35
  def open(&block); end

  # Returns the value of attribute timeout.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#14
  def timeout; end

  # Returns the value of attribute filepath.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#18
  def uds_path; end

  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#46
  def url; end

  class << self
    # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#28
    def build(agent_settings); end
  end
end

# Re-implements Net:HTTP with underlying Unix socket
#
# source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#51
class Datadog::Core::Transport::HTTP::Adapters::UnixSocket::HTTP < ::Net::HTTP
  # @return [HTTP] a new instance of HTTP
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#60
  def initialize(uds_path, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#68
  def connect; end

  # Returns the value of attribute filepath.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#54
  def filepath; end

  # Returns the value of attribute filepath.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#58
  def uds_path; end

  # Returns the value of attribute unix_socket.
  #
  # source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#54
  def unix_socket; end
end

# source://datadog//lib/datadog/core/transport/http/adapters/unix_socket.rb#52
Datadog::Core::Transport::HTTP::Adapters::UnixSocket::HTTP::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Builds new instances of Transport::HTTP::Client
#
# source://datadog//lib/datadog/core/transport/http/builder.rb#12
class Datadog::Core::Transport::HTTP::Builder
  # @return [Builder] a new instance of Builder
  # @yield [_self]
  # @yieldparam _self [Datadog::Core::Transport::HTTP::Builder] the object that the method was called on
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#24
  def initialize(api_instance_class:, logger: T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/transport/http/builder.rb#42
  def adapter(config, *args, **kwargs); end

  # Adds a new API to the client
  # Valid options:
  #  - :adapter
  #  - :default
  #  - :fallback
  #  - :headers
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#69
  def api(key, spec, options = T.unsafe(nil)); end

  # Returns the value of attribute api_instance_class.
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#15
  def api_instance_class; end

  # Returns the value of attribute api_options.
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#15
  def api_options; end

  # Returns the value of attribute apis.
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#15
  def apis; end

  # Returns the value of attribute default_adapter.
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#15
  def default_adapter; end

  # Returns the value of attribute default_api.
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#15
  def default_api; end

  # @raise [UnknownApiError]
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#82
  def default_api=(key); end

  # Returns the value of attribute default_headers.
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#15
  def default_headers; end

  # source://datadog//lib/datadog/core/transport/http/builder.rb#59
  def headers(values = T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#15
  def logger; end

  # @raise [NoApisError]
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#94
  def to_api_instances; end

  # @raise [NoDefaultApiError]
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#88
  def to_transport(klass); end
end

# Raised when an adapter cannot be resolved for an API instance.
#
# source://datadog//lib/datadog/core/transport/http/builder.rb#153
class Datadog::Core::Transport::HTTP::Builder::NoAdapterForApiError < ::StandardError
  # @return [NoAdapterForApiError] a new instance of NoAdapterForApiError
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#156
  def initialize(key); end

  # Returns the value of attribute key.
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#154
  def key; end

  # source://datadog//lib/datadog/core/transport/http/builder.rb#162
  def message; end
end

# Raised when built without defining APIs.
#
# source://datadog//lib/datadog/core/transport/http/builder.rb#168
class Datadog::Core::Transport::HTTP::Builder::NoApisError < ::StandardError
  # source://datadog//lib/datadog/core/transport/http/builder.rb#169
  def message; end
end

# Raised when client built without defining a default API.
#
# source://datadog//lib/datadog/core/transport/http/builder.rb#175
class Datadog::Core::Transport::HTTP::Builder::NoDefaultApiError < ::StandardError
  # source://datadog//lib/datadog/core/transport/http/builder.rb#176
  def message; end
end

# source://datadog//lib/datadog/core/transport/http/builder.rb#13
Datadog::Core::Transport::HTTP::Builder::REGISTRY = T.let(T.unsafe(nil), Datadog::Core::Transport::HTTP::Adapters::Registry)

# Raised when the identifier cannot be matched to an adapter.
#
# source://datadog//lib/datadog/core/transport/http/builder.rb#138
class Datadog::Core::Transport::HTTP::Builder::UnknownAdapterError < ::StandardError
  # @return [UnknownAdapterError] a new instance of UnknownAdapterError
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#141
  def initialize(type); end

  # source://datadog//lib/datadog/core/transport/http/builder.rb#147
  def message; end

  # Returns the value of attribute type.
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#139
  def type; end
end

# Raised when the API key does not match known APIs.
#
# source://datadog//lib/datadog/core/transport/http/builder.rb#123
class Datadog::Core::Transport::HTTP::Builder::UnknownApiError < ::StandardError
  # @return [UnknownApiError] a new instance of UnknownApiError
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#126
  def initialize(key); end

  # Returns the value of attribute key.
  #
  # source://datadog//lib/datadog/core/transport/http/builder.rb#124
  def key; end

  # source://datadog//lib/datadog/core/transport/http/builder.rb#132
  def message; end
end

# Data structure for an HTTP request
#
# source://datadog//lib/datadog/core/transport/http/env.rb#8
class Datadog::Core::Transport::HTTP::Env < ::Hash
  # @return [Env] a new instance of Env
  #
  # source://datadog//lib/datadog/core/transport/http/env.rb#13
  def initialize(request, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/transport/http/env.rb#43
  def body; end

  # source://datadog//lib/datadog/core/transport/http/env.rb#47
  def body=(value); end

  # source://datadog//lib/datadog/core/transport/http/env.rb#59
  def form; end

  # source://datadog//lib/datadog/core/transport/http/env.rb#63
  def form=(value); end

  # source://datadog//lib/datadog/core/transport/http/env.rb#51
  def headers; end

  # source://datadog//lib/datadog/core/transport/http/env.rb#55
  def headers=(value); end

  # source://datadog//lib/datadog/core/transport/http/env.rb#27
  def path; end

  # source://datadog//lib/datadog/core/transport/http/env.rb#31
  def path=(value); end

  # source://datadog//lib/datadog/core/transport/http/env.rb#35
  def query; end

  # source://datadog//lib/datadog/core/transport/http/env.rb#39
  def query=(value); end

  # Returns the value of attribute request.
  #
  # source://datadog//lib/datadog/core/transport/http/env.rb#9
  def request; end

  # source://datadog//lib/datadog/core/transport/http/env.rb#19
  def verb; end

  # source://datadog//lib/datadog/core/transport/http/env.rb#23
  def verb=(value); end
end

# Wraps an HTTP response from an adapter.
#
# Used by endpoints to wrap responses from adapters with
# fields or behavior that's specific to that endpoint.
#
# source://datadog//lib/datadog/core/transport/http/response.rb#13
module Datadog::Core::Transport::HTTP::Response
  # source://datadog//lib/datadog/core/transport/http/response.rb#14
  def initialize(http_response); end

  # source://datadog//lib/datadog/core/transport/http/response.rb#44
  def client_error?; end

  # source://datadog//lib/datadog/core/transport/http/response.rb#53
  def code; end

  # source://datadog//lib/datadog/core/transport/http/response.rb#24
  def internal_error?; end

  # source://datadog//lib/datadog/core/transport/http/response.rb#39
  def not_found?; end

  # source://datadog//lib/datadog/core/transport/http/response.rb#34
  def ok?; end

  # source://datadog//lib/datadog/core/transport/http/response.rb#19
  def payload; end

  # source://datadog//lib/datadog/core/transport/http/response.rb#49
  def server_error?; end

  # source://datadog//lib/datadog/core/transport/http/response.rb#29
  def unsupported?; end
end

# A generic error response for internal errors
#
# source://datadog//lib/datadog/core/transport/response.rb#48
class Datadog::Core::Transport::InternalErrorResponse
  include ::Datadog::Core::Transport::Response

  # @return [InternalErrorResponse] a new instance of InternalErrorResponse
  #
  # source://datadog//lib/datadog/core/transport/response.rb#53
  def initialize(error); end

  # Returns the value of attribute error.
  #
  # source://datadog//lib/datadog/core/transport/response.rb#51
  def error; end

  # source://datadog//lib/datadog/core/transport/response.rb#65
  def inspect; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/response.rb#57
  def internal_error?; end

  # source://datadog//lib/datadog/core/transport/response.rb#61
  def to_s; end
end

# Data transfer object for generic data
#
# @abstract
#
# source://datadog//lib/datadog/core/transport/parcel.rb#8
module Datadog::Core::Transport::Parcel
  # source://datadog//lib/datadog/core/transport/parcel.rb#12
  def initialize(data); end

  # Returns the value of attribute data.
  #
  # source://datadog//lib/datadog/core/transport/parcel.rb#9
  def data; end

  # @raise [NotImplementedError]
  #
  # source://datadog//lib/datadog/core/transport/parcel.rb#16
  def encode_with(encoder); end
end

# Defines request for transport operations
#
# source://datadog//lib/datadog/core/transport/request.rb#7
class Datadog::Core::Transport::Request
  # @return [Request] a new instance of Request
  #
  # source://datadog//lib/datadog/core/transport/request.rb#11
  def initialize(parcel = T.unsafe(nil)); end

  # Returns the value of attribute parcel.
  #
  # source://datadog//lib/datadog/core/transport/request.rb#8
  def parcel; end
end

# Defines abstract response for transport operations
#
# source://datadog//lib/datadog/core/transport/response.rb#7
module Datadog::Core::Transport::Response
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/response.rb#24
  def client_error?; end

  # source://datadog//lib/datadog/core/transport/response.rb#36
  def inspect; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/response.rb#32
  def internal_error?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/response.rb#20
  def not_found?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/response.rb#12
  def ok?; end

  # source://datadog//lib/datadog/core/transport/response.rb#8
  def payload; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/response.rb#28
  def server_error?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/transport/response.rb#16
  def unsupported?; end
end

# {Datadog::Core::RateLimiter} that accepts all resources,
# with no limits.
#
# source://datadog//lib/datadog/core/rate_limiter.rb#173
class Datadog::Core::UnlimitedLimiter < ::Datadog::Core::RateLimiter
  # @return [Boolean] always +true+
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#175
  def allow?(_ = T.unsafe(nil)); end

  # @return [Float] always 100%
  #
  # source://datadog//lib/datadog/core/rate_limiter.rb#180
  def effective_rate; end
end

# Utils contains low-level utilities, typically to provide pseudo-random trace IDs.
#
# source://datadog//lib/datadog/core/utils/only_once.rb#5
module Datadog::Core::Utils
  extend ::Datadog::Core::Utils::Forking

  class << self
    # source://datadog//lib/datadog/core/utils.rb#69
    def encode_tags(hash); end

    # Extracts hostname and port from
    # a string that contains both, separated by ':'.
    #
    # @return [String, Integer] hostname and port
    # @return [nil] if format did not match
    #
    # source://datadog//lib/datadog/core/utils.rb#93
    def extract_host_port(host_port); end

    # Stringifies `value` and ensures the outcome is
    # string is no longer than `size`.
    # `omission` replaces the end of the output if
    # `value.to_s` does not fit in `size`, to signify
    # truncation.
    #
    # If `omission.size` is larger than `size`, the output
    # will still be `omission.size` in length.
    #
    # source://datadog//lib/datadog/core/utils.rb#23
    def truncate(value, size, omission = T.unsafe(nil)); end

    # Ensure `str` is a valid UTF-8, ready to be
    # sent through the tracer transport.
    #
    # @param binary [Boolean] whether to expect binary data in the `str` parameter
    # @param placeholder [String] string to be returned when encoding fails
    # @param str [String, #to_s] object to be converted to a UTF-8 string
    # @return a UTF-8 string version of `str`
    #
    # source://datadog//lib/datadog/core/utils.rb#47
    def utf8_encode(str, binary: T.unsafe(nil), placeholder: T.unsafe(nil)); end

    # source://datadog//lib/datadog/core/utils.rb#77
    def without_warnings; end
  end
end

# Monkey patches `Kernel#fork` and similar functions, adding an `at_fork` callback mechanism which
# is used to restart observability after the VM forks (e.g. in multiprocess Ruby apps).
#
# source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#8
module Datadog::Core::Utils::AtForkMonkeyPatch
  class << self
    # source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#16
    def apply!; end

    # @raise [ArgumentError]
    #
    # source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#40
    def at_fork(stage, &block); end

    # @raise [ArgumentError]
    #
    # source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#34
    def run_at_fork_blocks(stage); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#12
    def supported?; end
  end
end

# source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#9
Datadog::Core::Utils::AtForkMonkeyPatch::AT_FORK_CHILD_BLOCKS = T.let(T.unsafe(nil), Array)

# Adds `at_fork` behavior; see parent module for details.
#
# source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#50
module Datadog::Core::Utils::AtForkMonkeyPatch::KernelMonkeyPatch
  # source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#51
  def fork; end
end

# Adds `at_fork` behavior; see parent module for details.
#
# source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#77
module Datadog::Core::Utils::AtForkMonkeyPatch::ProcessMonkeyPatch
  # Hook provided by Ruby 3.1+ for observability libraries that want to know about fork, see
  # https://github.com/ruby/ruby/pull/5017 and https://bugs.ruby-lang.org/issues/17795
  #
  # source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#80
  def _fork; end

  # A call to Process.daemon ( https://rubyapi.org/3.1/o/process#method-c-daemon ) forks the current process and
  # keeps executing code in the child process, killing off the parent, thus effectively replacing it.
  # This is not covered by `_fork` and thus we have some extra code for it.
  #
  # source://datadog//lib/datadog/core/utils/at_fork_monkey_patch.rb#91
  def daemon(*args); end
end

# Helper methods for encoding and decoding base64
#
# source://datadog//lib/datadog/core/utils/base64.rb#7
module Datadog::Core::Utils::Base64
  class << self
    # source://datadog//lib/datadog/core/utils/base64.rb#8
    def encode64(bin); end

    # source://datadog//lib/datadog/core/utils/base64.rb#16
    def strict_decode64(str); end

    # source://datadog//lib/datadog/core/utils/base64.rb#12
    def strict_encode64(bin); end
  end
end

# Helper methods for parsing string values into Numeric
#
# source://datadog//lib/datadog/core/utils/duration.rb#7
module Datadog::Core::Utils::Duration
  class << self
    # source://datadog//lib/datadog/core/utils/duration.rb#8
    def call(value, base: T.unsafe(nil)); end
  end
end

# source://datadog//lib/datadog/core/utils.rb#12
Datadog::Core::Utils::EMPTY_STRING = T.let(T.unsafe(nil), String)

# Helper methods for managing forking behavior
#
# source://datadog//lib/datadog/core/utils/forking.rb#7
module Datadog::Core::Utils::Forking
  # source://datadog//lib/datadog/core/utils/forking.rb#20
  def after_fork!; end

  # source://datadog//lib/datadog/core/utils/forking.rb#38
  def fork_pid; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/utils/forking.rb#30
  def forked?; end

  # source://datadog//lib/datadog/core/utils/forking.rb#34
  def update_fork_pid!; end

  class << self
    # @private
    #
    # source://datadog//lib/datadog/core/utils/forking.rb#12
    def extended(base); end

    # @private
    #
    # source://datadog//lib/datadog/core/utils/forking.rb#8
    def included(base); end
  end
end

# Adds additional functionality for Classes that implement Forking
#
# source://datadog//lib/datadog/core/utils/forking.rb#43
module Datadog::Core::Utils::Forking::ClassExtensions
  # source://datadog//lib/datadog/core/utils/forking.rb#49
  def initialize(*args, **kwargs, &block); end
end

# Refinements for {Hash}.
#
# source://datadog//lib/datadog/core/utils/hash.rb#7
module Datadog::Core::Utils::Hash; end

# A minimal {Hash} wrapper that provides case-insensitive access
# to hash keys, without the overhead of copying the original hash.
#
# This class should be used when the original hash is short lived *and*
# each hash key is only accesses a few times.
# For other cases, create a copy of the original hash with the keys
# normalized adequate to your use case.
#
# source://datadog//lib/datadog/core/utils/hash.rb#37
class Datadog::Core::Utils::Hash::CaseInsensitiveWrapper
  # @raise [ArgumentError]
  # @return [CaseInsensitiveWrapper] a new instance of CaseInsensitiveWrapper
  #
  # source://datadog//lib/datadog/core/utils/hash.rb#38
  def initialize(hash); end

  # source://datadog//lib/datadog/core/utils/hash.rb#44
  def [](key); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/utils/hash.rb#64
  def empty?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/utils/hash.rb#54
  def key?(key); end

  # source://datadog//lib/datadog/core/utils/hash.rb#68
  def length; end

  # source://datadog//lib/datadog/core/utils/hash.rb#72
  def original_hash; end
end

# This refinement ensures modern rubies are allowed to use newer,
# simpler, and more performant APIs.
#
# source://datadog//lib/datadog/core/utils/hash.rb#10
module Datadog::Core::Utils::Hash::Refinement; end

# Common Network utility functions.
#
# source://datadog//lib/datadog/core/utils/network.rb#9
module Datadog::Core::Utils::Network
  class << self
    # @param IP [String] value.
    # @return [String] IP value without the port and the zone indentifier.
    # @return [nil] when no valid IP value found.
    #
    # source://datadog//lib/datadog/core/utils/network.rb#42
    def stripped_ip(ip); end

    # Returns a client IP associated with the request if it was
    #   retrieved successfully.
    #
    # @param headers [Datadog::Core::HeaderCollection, #get, nil] The request headers
    # @param list [Array<String>] of headers to check.
    # @return [String] IP value without the port and the zone indentifier.
    # @return [nil] when no valid IP value found.
    #
    # source://datadog//lib/datadog/core/utils/network.rb#33
    def stripped_ip_from_request_headers(headers, ip_headers_to_check: T.unsafe(nil)); end

    private

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/utils/network.rb#133
    def global_ip?(parsed_ip); end

    # source://datadog//lib/datadog/core/utils/network.rb#68
    def ip_header(headers, ip_headers_to_check); end

    # @param IP [String] value.
    # @return [IPaddr]
    # @return [nil] when no valid IP value found.
    #
    # source://datadog//lib/datadog/core/utils/network.rb#52
    def ip_to_ipaddr(ip); end

    # Returns whether the given value is more likely to be an IPv4 than an IPv6 address.
    #
    # This is done by checking if a dot (`'.'`) character appears before a colon (`':'`) in the value.
    # The rationale is that in valid IPv6 addresses, colons will always preced dots,
    #   and in valid IPv4 addresses dots will always preced colons.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/utils/network.rb#110
    def likely_ipv4?(value); end

    # source://datadog//lib/datadog/core/utils/network.rb#89
    def process_forwarded_header_values(values); end

    # source://datadog//lib/datadog/core/utils/network.rb#129
    def strip_ipv4_port(ip); end

    # source://datadog//lib/datadog/core/utils/network.rb#121
    def strip_ipv6_port(ip); end

    # source://datadog//lib/datadog/core/utils/network.rb#117
    def strip_zone_specifier(ipv6); end
  end
end

# source://datadog//lib/datadog/core/utils/network.rb#10
Datadog::Core::Utils::Network::DEFAULT_IP_HEADERS_NAMES = T.let(T.unsafe(nil), Array)

# Helper class to execute something only once such as not repeating warning logs, and instrumenting classes
# only once.
#
# Thread-safe when used correctly (e.g. be careful of races when lazily initializing instances of this class).
#
# Note: In its current state, this class is not Ractor-safe.
# In https://github.com/DataDog/dd-trace-rb/pull/1398#issuecomment-797378810 we have a discussion of alternatives,
# including an alternative implementation that is Ractor-safe once spent.
#
# source://datadog//lib/datadog/core/utils/only_once.rb#14
class Datadog::Core::Utils::OnlyOnce
  # @return [OnlyOnce] a new instance of OnlyOnce
  #
  # source://datadog//lib/datadog/core/utils/only_once.rb#15
  def initialize; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/utils/only_once.rb#30
  def ran?; end

  # source://datadog//lib/datadog/core/utils/only_once.rb#20
  def run; end

  private

  # source://datadog//lib/datadog/core/utils/only_once.rb#36
  def reset_ran_once_state_for_tests; end
end

# Helper class to execute something with only one successful execution.
#
# If limit is not provided to the constructor, +run+ will execute the
# block an unlimited number of times until the block indicates that it
# executed successfully by returning a truthy value. After a block
# executes successfully, subsequent +run+ calls will not invoke the
# block.
#
# If a non-zero limit is provided to the constructor, +run+ will
# execute the block up to that many times, and will mark the instance
# of OnlyOneSuccessful as failed if none of the executions succeeded.
#
# One consumer of this class is sending the app-started telemetry event.
#
# Successful execution is determined by the return value of the block:
# any truthy value is considered success.
#
# This class is thread-safe (however, instances of it must also be
# created in a thread-safe manner).
#
# Note: In its current state, this class is not Ractor-safe.
# In https://github.com/DataDog/dd-trace-rb/pull/1398#issuecomment-797378810 we have a discussion of alternatives,
# including an alternative implementation that is Ractor-safe once spent.
#
# source://datadog//lib/datadog/core/utils/only_once_successful.rb#31
class Datadog::Core::Utils::OnlyOnceSuccessful < ::Datadog::Core::Utils::OnlyOnce
  # @return [OnlyOnceSuccessful] a new instance of OnlyOnceSuccessful
  #
  # source://datadog//lib/datadog/core/utils/only_once_successful.rb#32
  def initialize(limit = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/utils/only_once_successful.rb#60
  def failed?; end

  # source://datadog//lib/datadog/core/utils/only_once_successful.rb#40
  def run; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/utils/only_once_successful.rb#56
  def success?; end

  private

  # source://datadog//lib/datadog/core/utils/only_once_successful.rb#66
  def check_limit!; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/utils/only_once_successful.rb#73
  def limited?; end

  # source://datadog//lib/datadog/core/utils/only_once_successful.rb#77
  def reset_ran_once_state_for_tests; end
end

# Helper methods for safer dup
#
# source://datadog//lib/datadog/core/utils/safe_dup.rb#7
module Datadog::Core::Utils::SafeDup
  class << self
    # source://datadog//lib/datadog/core/utils/safe_dup.rb#25
    def frozen_dup(v); end

    # String#+@ was introduced in Ruby 2.3
    #
    # source://datadog//lib/datadog/core/utils/safe_dup.rb#9
    def frozen_or_dup(v); end
  end
end

# Generates values from a consistent sequence
#
# source://datadog//lib/datadog/core/utils/sequence.rb#7
class Datadog::Core::Utils::Sequence
  # @return [Sequence] a new instance of Sequence
  #
  # source://datadog//lib/datadog/core/utils/sequence.rb#8
  def initialize(seed = T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/core/utils/sequence.rb#14
  def next; end

  # source://datadog//lib/datadog/core/utils/sequence.rb#20
  def reset!; end
end

# Common database-related utility functions.
#
# source://datadog//lib/datadog/core/utils/time.rb#7
module Datadog::Core::Utils::Time
  private

  # source://datadog//lib/datadog/core/utils/time.rb#76
  def as_utc_epoch_ns(time); end

  # Current monotonic time
  #
  # @param unit [Symbol] unit for the resulting value, same as ::Process#clock_gettime, defaults to :float_second
  # @return [Numeric] timestamp in the requested unit, since some unspecified starting point
  #
  # source://datadog//lib/datadog/core/utils/time.rb#14
  def get_time(unit = T.unsafe(nil)); end

  # Overrides the implementation of `#get_time
  # with the provided callable.
  #
  # Overriding the method `#get_time` instead of
  # indirectly calling `block` removes
  # one level of method call overhead.
  #
  # @param block [Proc] block that accepts unit and returns timestamp in the requested unit
  #
  # source://datadog//lib/datadog/core/utils/time.rb#55
  def get_time_provider=(block); end

  # source://datadog//lib/datadog/core/utils/time.rb#69
  def measure(unit = T.unsafe(nil)); end

  # Current wall time.
  #
  # @return [Time] current time object
  #
  # source://datadog//lib/datadog/core/utils/time.rb#21
  def now; end

  # Overrides the implementation of `#now
  # with the provided callable.
  #
  # Overriding the method `#now` instead of
  # indirectly calling `block` removes
  # one level of method call overhead.
  #
  # @param block [Proc] block that returns a `Time` object representing the current wall time
  #
  # source://datadog//lib/datadog/core/utils/time.rb#33
  def now_provider=(block); end

  class << self
    # source://datadog//lib/datadog/core/utils/time.rb#76
    def as_utc_epoch_ns(time); end

    # Current monotonic time
    #
    # @param unit [Symbol] unit for the resulting value, same as ::Process#clock_gettime, defaults to :float_second
    # @return [Numeric] timestamp in the requested unit, since some unspecified starting point
    #
    # source://datadog//lib/datadog/core/utils/time.rb#14
    def get_time(unit = T.unsafe(nil)); end

    # Overrides the implementation of `#get_time
    # with the provided callable.
    #
    # Overriding the method `#get_time` instead of
    # indirectly calling `block` removes
    # one level of method call overhead.
    #
    # @param block [Proc] block that accepts unit and returns timestamp in the requested unit
    #
    # source://datadog//lib/datadog/core/utils/time.rb#55
    def get_time_provider=(block); end

    # source://datadog//lib/datadog/core/utils/time.rb#69
    def measure(unit = T.unsafe(nil)); end

    # Current wall time.
    #
    # @return [Time] current time object
    #
    # source://datadog//lib/datadog/core/utils/time.rb#21
    def now; end

    # Overrides the implementation of `#now
    # with the provided callable.
    #
    # Overriding the method `#now` instead of
    # indirectly calling `block` removes
    # one level of method call overhead.
    #
    # @param block [Proc] block that returns a `Time` object representing the current wall time
    #
    # source://datadog//lib/datadog/core/utils/time.rb#33
    def now_provider=(block); end
  end
end

# Helper methods for truncating data
#
# source://datadog//lib/datadog/core/utils/truncation.rb#7
module Datadog::Core::Utils::Truncation
  private

  # source://datadog//lib/datadog/core/utils/truncation.rb#10
  def truncate_in_middle(string, max_prefix_length, max_suffix_length); end

  class << self
    # source://datadog//lib/datadog/core/utils/truncation.rb#10
    def truncate_in_middle(string, max_prefix_length, max_suffix_length); end
  end
end

# Helpers class that provides methods to process URLs
# such as filtering sensitive information.
#
# source://datadog//lib/datadog/core/utils/url.rb#10
module Datadog::Core::Utils::Url
  class << self
    # source://datadog//lib/datadog/core/utils/url.rb#11
    def filter_basic_auth(url); end
  end
end

# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#9
module Datadog::Core::Vendor; end

# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#10
module Datadog::Core::Vendor::Multipart; end

# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#11
module Datadog::Core::Vendor::Multipart::Post; end

# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#20
class Datadog::Core::Vendor::Multipart::Post::CompositeReadIO
  # Create a new composite-read IO from the arguments, all of which should
  # respond to #read in a manner consistent with IO.
  #
  # @return [CompositeReadIO] a new instance of CompositeReadIO
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#23
  def initialize(*ios); end

  # Read from IOs in order until `length` bytes have been received.
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#29
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#46
  def rewind; end

  private

  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#57
  def advance_io; end

  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#53
  def current_io; end
end

# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#16
module Datadog::Core::Vendor::Multipart::Post::Multipartable
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#31
  def initialize(path, params, headers = T.unsafe(nil), boundary = T.unsafe(nil)); end

  # Returns the value of attribute boundary.
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#53
  def boundary; end

  class << self
    # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#17
    def secure_boundary; end
  end
end

# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#12
module Datadog::Core::Vendor::Multipart::Post::Parts; end

# Represents the epilogue or closing boundary.
#
# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#124
class Datadog::Core::Vendor::Multipart::Post::Parts::EpiloguePart
  include ::Datadog::Core::Vendor::Multipart::Post::Parts::Part

  # @return [EpiloguePart] a new instance of EpiloguePart
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#127
  def initialize(boundary); end
end

# Represents a part to be filled from file IO.
#
# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#69
class Datadog::Core::Vendor::Multipart::Post::Parts::FilePart
  include ::Datadog::Core::Vendor::Multipart::Post::Parts::Part

  # @param boundary [String]
  # @param headers [Hash]
  # @param io [IO]
  # @param name [#to_s]
  # @return [FilePart] a new instance of FilePart
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#78
  def initialize(boundary, name, io, headers = T.unsafe(nil)); end

  # @param boundary [String]
  # @param content_len [Integer]
  # @param filename [String]
  # @param name [#to_s]
  # @param opts [Hash]
  # @param type [String]
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#93
  def build_head(boundary, name, filename, type, content_len, opts = T.unsafe(nil)); end

  # Returns the value of attribute length.
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#72
  def length; end
end

# Represents a parametric part to be filled with given value.
#
# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#37
class Datadog::Core::Vendor::Multipart::Post::Parts::ParamPart
  include ::Datadog::Core::Vendor::Multipart::Post::Parts::Part

  # @param boundary [String]
  # @param headers [Hash] Content-Type and Content-ID are used, if present.
  # @param name [#to_s]
  # @param value [String]
  # @return [ParamPart] a new instance of ParamPart
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#44
  def initialize(boundary, name, value, headers = T.unsafe(nil)); end

  # @param boundary [String]
  # @param headers [Hash] Content-Type is used, if present.
  # @param name [#to_s]
  # @param value [String]
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#57
  def build_part(boundary, name, value, headers = T.unsafe(nil)); end

  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#49
  def length; end
end

# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#13
module Datadog::Core::Vendor::Multipart::Post::Parts::Part
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#27
  def length; end

  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#31
  def to_io; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#23
    def file?(value); end

    # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#14
    def new(boundary, name, value, headers = T.unsafe(nil)); end
  end
end

# Convenience methods for dealing with files and IO that are to be uploaded.
#
# source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#63
class Datadog::Core::Vendor::Multipart::Post::UploadIO
  # Create an upload IO suitable for including in the params hash of a
  # Net::HTTP::Post::Multipart.
  #
  # Can take two forms. The first accepts a filename and content type, and
  # opens the file for reading (to be closed by finalizer).
  #
  # The second accepts an already-open IO, but also requires a third argument,
  # the filename from which it was opened (particularly useful/recommended if
  # uploading directly from a form in a framework, which often save the file to
  # an arbitrarily named RackMultipart file in /tmp).
  #
  # @example
  #   UploadIO.new("file.txt", "text/plain")
  #   UploadIO.new(file_io, "text/plain", "file.txt")
  # @return [UploadIO] a new instance of UploadIO
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#80
  def initialize(filename_or_io, content_type, filename = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Returns the value of attribute content_type.
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#64
  def content_type; end

  # Returns the value of attribute io.
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#64
  def io; end

  # Returns the value of attribute local_path.
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#64
  def local_path; end

  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#106
  def method_missing(*args); end

  # Returns the value of attribute opts.
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#64
  def opts; end

  # Returns the value of attribute original_filename.
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#64
  def original_filename; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#110
  def respond_to?(meth, include_all = T.unsafe(nil)); end

  class << self
    # @raise [ArgumentError]
    #
    # source://datadog//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#100
    def convert!(io, content_type, original_filename, local_path); end
  end
end

# source://datadog//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#17
module Datadog::Core::Vendor::Net; end

# source://datadog//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#18
class Datadog::Core::Vendor::Net::HTTP; end

# source://datadog//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#25
class Datadog::Core::Vendor::Net::HTTP::Post; end

# source://datadog//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#26
class Datadog::Core::Vendor::Net::HTTP::Post::Multipart < ::Net::HTTP::Post
  include ::Datadog::Core::Vendor::Multipart::Post::Multipartable
end

# source://datadog//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#19
class Datadog::Core::Vendor::Net::HTTP::Put; end

# source://datadog//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#20
class Datadog::Core::Vendor::Net::HTTP::Put::Multipart < ::Net::HTTP::Put
  include ::Datadog::Core::Vendor::Multipart::Post::Multipartable
end

# Base class for work tasks
#
# source://datadog//lib/datadog/core/worker.rb#6
class Datadog::Core::Worker
  # @return [Worker] a new instance of Worker
  #
  # source://datadog//lib/datadog/core/worker.rb#10
  def initialize(&block); end

  # source://datadog//lib/datadog/core/worker.rb#14
  def perform(*args); end

  # Returns the value of attribute task.
  #
  # source://datadog//lib/datadog/core/worker.rb#7
  def task; end

  protected

  # Sets the attribute task
  #
  # @param value the value to set the attribute task to.
  #
  # source://datadog//lib/datadog/core/worker.rb#20
  def task=(_arg0); end
end

# source://datadog//lib/datadog/core/workers/async.rb#7
module Datadog::Core::Workers; end

# source://datadog//lib/datadog/core/workers/async.rb#8
module Datadog::Core::Workers::Async; end

# Adds threading behavior to workers
# to run tasks asynchronously.
#
# source://datadog//lib/datadog/core/workers/async.rb#11
module Datadog::Core::Workers::Async::Thread
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/async.rb#81
  def completed?; end

  # Returns the value of attribute error.
  #
  # source://datadog//lib/datadog/core/workers/async.rb#31
  def error; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/async.rb#75
  def error?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/async.rb#85
  def failed?; end

  # source://datadog//lib/datadog/core/workers/async.rb#93
  def fork_policy; end

  # Sets the attribute fork_policy
  #
  # @param value the value to set the attribute fork_policy to.
  #
  # source://datadog//lib/datadog/core/workers/async.rb#35
  def fork_policy=(_arg0); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/async.rb#89
  def forked?; end

  # source://datadog//lib/datadog/core/workers/async.rb#38
  def join(timeout = T.unsafe(nil)); end

  # Returns the value of attribute result.
  #
  # source://datadog//lib/datadog/core/workers/async.rb#31
  def result; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/async.rb#61
  def run_async?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/async.rb#71
  def running?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/async.rb#67
  def started?; end

  # source://datadog//lib/datadog/core/workers/async.rb#44
  def terminate; end

  protected

  # source://datadog//lib/datadog/core/workers/async.rb#106
  def after_fork; end

  # source://datadog//lib/datadog/core/workers/async.rb#102
  def mutex; end

  # Sets the attribute result
  #
  # @param value the value to set the attribute result to.
  #
  # source://datadog//lib/datadog/core/workers/async.rb#99
  def result=(_arg0); end

  private

  # source://datadog//lib/datadog/core/workers/async.rb#115
  def mutex_after_fork; end

  # Returns the value of attribute pid.
  #
  # source://datadog//lib/datadog/core/workers/async.rb#112
  def pid; end

  # source://datadog//lib/datadog/core/workers/async.rb#187
  def restart_after_fork(&block); end

  # Returns true if worker thread is successfully started,
  # false if it is not started. Reasons for not starting the worker
  # thread: it is already running, or the process forked and fork
  # policy is to stop the workers on fork (which means they are
  # not started in children, really).
  #
  # source://datadog//lib/datadog/core/workers/async.rb#128
  def start_async(&block); end

  # Returns true if worker thread is successfully started,
  # which should generally be always.
  #
  # source://datadog//lib/datadog/core/workers/async.rb#150
  def start_worker; end

  # source://datadog//lib/datadog/core/workers/async.rb#174
  def stop_fork; end

  # source://datadog//lib/datadog/core/workers/async.rb#119
  def worker; end

  class << self
    # @private
    #
    # source://datadog//lib/datadog/core/workers/async.rb#20
    def included(base); end
  end
end

# source://datadog//lib/datadog/core/workers/async.rb#13
Datadog::Core::Workers::Async::Thread::FORK_POLICY_RESTART = T.let(T.unsafe(nil), Symbol)

# source://datadog//lib/datadog/core/workers/async.rb#12
Datadog::Core::Workers::Async::Thread::FORK_POLICY_STOP = T.let(T.unsafe(nil), Symbol)

# This single shared mutex is used to avoid concurrency issues during the
# initialization of per-instance lazy-initialized mutexes.
#
# source://datadog//lib/datadog/core/workers/async.rb#18
Datadog::Core::Workers::Async::Thread::MUTEX_INIT = T.let(T.unsafe(nil), Thread::Mutex)

# Methods that must be prepended
#
# source://datadog//lib/datadog/core/workers/async.rb#25
module Datadog::Core::Workers::Async::Thread::PrependedMethods
  # source://datadog//lib/datadog/core/workers/async.rb#26
  def perform(*args); end
end

# source://datadog//lib/datadog/core/workers/async.rb#14
Datadog::Core::Workers::Async::Thread::SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Adds looping behavior to workers, with a sleep
# interval between each loop.
#
# source://datadog//lib/datadog/core/workers/interval_loop.rb#8
module Datadog::Core::Workers::IntervalLoop
  # source://datadog//lib/datadog/core/workers/interval_loop.rb#80
  def loop_back_off!; end

  # source://datadog//lib/datadog/core/workers/interval_loop.rb#68
  def loop_back_off_max; end

  # source://datadog//lib/datadog/core/workers/interval_loop.rb#64
  def loop_back_off_ratio; end

  # source://datadog//lib/datadog/core/workers/interval_loop.rb#60
  def loop_base_interval; end

  # Should perform_loop just straight into work, or start by waiting?
  #
  # The use case is if we want to report some information (like profiles) from time to time, we may not want to
  # report empty/zero/some residual value immediately when the worker starts.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/interval_loop.rb#88
  def loop_wait_before_first_iteration?; end

  # source://datadog//lib/datadog/core/workers/interval_loop.rb#72
  def loop_wait_time; end

  # source://datadog//lib/datadog/core/workers/interval_loop.rb#76
  def loop_wait_time=(value); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/interval_loop.rb#54
  def run_loop?; end

  # source://datadog//lib/datadog/core/workers/interval_loop.rb#39
  def stop_loop; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/interval_loop.rb#50
  def work_pending?; end

  protected

  # Sets the attribute loop_back_off_max
  #
  # @param value the value to set the attribute loop_back_off_max to.
  #
  # source://datadog//lib/datadog/core/workers/interval_loop.rb#94
  def loop_back_off_max=(_arg0); end

  # Sets the attribute loop_back_off_ratio
  #
  # @param value the value to set the attribute loop_back_off_ratio to.
  #
  # source://datadog//lib/datadog/core/workers/interval_loop.rb#94
  def loop_back_off_ratio=(_arg0); end

  # Sets the attribute loop_base_interval
  #
  # @param value the value to set the attribute loop_base_interval to.
  #
  # source://datadog//lib/datadog/core/workers/interval_loop.rb#94
  def loop_base_interval=(_arg0); end

  # source://datadog//lib/datadog/core/workers/interval_loop.rb#99
  def mutex; end

  private

  # source://datadog//lib/datadog/core/workers/interval_loop.rb#105
  def perform_loop; end

  # source://datadog//lib/datadog/core/workers/interval_loop.rb#128
  def shutdown; end

  class << self
    # @private
    #
    # source://datadog//lib/datadog/core/workers/interval_loop.rb#17
    def included(base); end
  end
end

# source://datadog//lib/datadog/core/workers/interval_loop.rb#10
Datadog::Core::Workers::IntervalLoop::BACK_OFF_MAX = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/core/workers/interval_loop.rb#9
Datadog::Core::Workers::IntervalLoop::BACK_OFF_RATIO = T.let(T.unsafe(nil), Float)

# source://datadog//lib/datadog/core/workers/interval_loop.rb#11
Datadog::Core::Workers::IntervalLoop::BASE_INTERVAL = T.let(T.unsafe(nil), Integer)

# This single shared mutex is used to avoid concurrency issues during the
# initialization of per-instance lazy-initialized mutexes.
#
# source://datadog//lib/datadog/core/workers/interval_loop.rb#15
Datadog::Core::Workers::IntervalLoop::MUTEX_INIT = T.let(T.unsafe(nil), Thread::Mutex)

# Methods that must be prepended
#
# source://datadog//lib/datadog/core/workers/interval_loop.rb#22
module Datadog::Core::Workers::IntervalLoop::PrependedMethods
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/interval_loop.rb#34
  def in_iteration?; end

  # source://datadog//lib/datadog/core/workers/interval_loop.rb#23
  def perform(*args); end
end

# Adds polling (async looping) behavior to workers
#
# source://datadog//lib/datadog/core/workers/polling.rb#10
module Datadog::Core::Workers::Polling
  include ::Datadog::Core::Workers::IntervalLoop
  include ::Datadog::Core::Workers::Async::Thread

  # Allow worker to be started
  #
  # source://datadog//lib/datadog/core/workers/polling.rb#52
  def enabled=(value); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/polling.rb#45
  def enabled?; end

  # source://datadog//lib/datadog/core/workers/polling.rb#26
  def stop(force_stop = T.unsafe(nil), timeout = T.unsafe(nil)); end

  class << self
    # @private
    #
    # source://datadog//lib/datadog/core/workers/polling.rb#13
    def included(base); end
  end
end

# source://datadog//lib/datadog/core/workers/polling.rb#11
Datadog::Core::Workers::Polling::DEFAULT_SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Methods that must be prepended
#
# source://datadog//lib/datadog/core/workers/polling.rb#20
module Datadog::Core::Workers::Polling::PrependedMethods
  # source://datadog//lib/datadog/core/workers/polling.rb#21
  def perform(*args); end
end

# Adds queue behavior to workers, with a buffer
# to which items can be queued then dequeued.
#
# source://datadog//lib/datadog/core/workers/queue.rb#8
module Datadog::Core::Workers::Queue
  # source://datadog//lib/datadog/core/workers/queue.rb#20
  def buffer; end

  # source://datadog//lib/datadog/core/workers/queue.rb#28
  def dequeue; end

  # source://datadog//lib/datadog/core/workers/queue.rb#24
  def enqueue(*args); end

  # Are there more items to be processed next?
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/core/workers/queue.rb#33
  def work_pending?; end

  protected

  # Sets the attribute buffer
  #
  # @param value the value to set the attribute buffer to.
  #
  # source://datadog//lib/datadog/core/workers/queue.rb#39
  def buffer=(_arg0); end

  class << self
    # @private
    #
    # source://datadog//lib/datadog/core/workers/queue.rb#9
    def included(base); end
  end
end

# Methods that must be prepended
#
# source://datadog//lib/datadog/core/workers/queue.rb#14
module Datadog::Core::Workers::Queue::PrependedMethods
  # source://datadog//lib/datadog/core/workers/queue.rb#15
  def perform(*args); end
end

# Emits runtime metrics asynchronously on a timed loop
#
# source://datadog//lib/datadog/core/workers/runtime_metrics.rb#13
class Datadog::Core::Workers::RuntimeMetrics < ::Datadog::Core::Worker
  include ::Datadog::Core::Workers::IntervalLoop::PrependedMethods
  include ::Datadog::Core::Workers::Async::Thread::PrependedMethods
  include ::Datadog::Core::Workers::Polling::PrependedMethods
  include ::Datadog::Core::Workers::Polling
  include ::Datadog::Core::Workers::IntervalLoop
  include ::Datadog::Core::Workers::Async::Thread

  # @return [RuntimeMetrics] a new instance of RuntimeMetrics
  #
  # source://datadog//lib/datadog/core/workers/runtime_metrics.rb#23
  def initialize(telemetry:, **options); end

  # Returns the value of attribute metrics.
  #
  # source://datadog//lib/datadog/core/workers/runtime_metrics.rb#20
  def metrics; end

  # source://datadog//lib/datadog/core/workers/runtime_metrics.rb#37
  def perform(*args); end

  # source://datadog//lib/datadog/core/workers/runtime_metrics.rb#42
  def register_service(service); end

  # TODO: `close_metrics` is only needed because
  # Datadog::Core::Configuration::Components directly manipulates
  # the lifecycle of Runtime::Metrics.statsd instances.
  # This should be avoided, as it prevents this class from
  # ensuring correct resource decommission of its internal
  # dependencies.
  #
  # source://datadog//lib/datadog/core/workers/runtime_metrics.rb#53
  def stop(*args, close_metrics: T.unsafe(nil)); end
end

# source://datadog//lib/datadog/core/workers/runtime_metrics.rb#18
Datadog::Core::Workers::RuntimeMetrics::DEFAULT_BACK_OFF_MAX = T.let(T.unsafe(nil), Integer)

# In seconds
#
# source://datadog//lib/datadog/core/workers/runtime_metrics.rb#17
Datadog::Core::Workers::RuntimeMetrics::DEFAULT_FLUSH_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/core.rb#25
Datadog::DATADOG_ENV = T.let(T.unsafe(nil), Datadog::Core::Configuration::ConfigHelper)

# Namespace for Datadog dynamic instrumentation.
#
# @api private
#
# source://datadog//lib/datadog/di/component.rb#4
module Datadog::DI
  class << self
    # Activates code tracking if possible.
    #
    # This method does nothing if invoked in an environment that does not
    # implement required trace points for code tracking (MRI Ruby < 2.6,
    # JRuby) and rescues any exceptions that may be raised by downstream
    # DI code.
    #
    # @api private
    #
    # source://datadog//lib/datadog/di/base.rb#41
    def activate_tracking; end

    # Activates code tracking. Normally this method should be called
    # when the application starts. If instrumenting third-party code,
    # code tracking needs to be enabled before the third-party libraries
    # are loaded. Any third-party code loaded before code tracking is
    # activated will NOT be instrumentable using dynamic instrumentation.
    #
    # TODO test that activating tracker multiple times preserves
    # existing mappings in the registry
    #
    # @api private
    #
    # source://datadog//lib/datadog/di/base.rb#31
    def activate_tracking!; end

    # To avoid potential races with DI::Component being added and removed,
    # we maintain a list of the components. Normally the list should contain
    # either zero or one component depending on whether DI is enabled in
    # Datadog configuration. However, if a new instance of DI::Component
    # is created while the previous instance is still running, we are
    # guaranteed to not end up with no component when one is running.
    #
    # @api private
    #
    # source://datadog//lib/datadog/di/base.rb#101
    def add_current_component(component); end

    # @api private
    #
    # source://datadog//lib/datadog/di/base.rb#21
    def code_tracker; end

    # Returns whether code tracking is available.
    # This method should be used instead of querying #code_tracker
    # because the latter one may be nil.
    #
    # @api private
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/di/base.rb#75
    def code_tracking_active?; end

    # This method is called from DI Remote handler to issue DI operations
    # to the probe manager (add or remove probes).
    #
    # When DI Remote is executing, Datadog.components should be initialized
    # and we should be able to reference it to get to the DI component.
    #
    # Given that we need the current_component anyway for code tracker,
    # perhaps we should delete the +component+ method and just use
    # +current_component+ in all cases.
    #
    # @api private
    #
    # source://datadog//lib/datadog/di.rb#31
    def component; end

    # DI code tracker is instantiated globally before the regular set of
    # components is created, but the code tracker needs to call out to the
    # "current" DI component to perform instrumentation when application
    # code is loaded. Because this call may happen prior to Datadog
    # components having been initialized, we maintain the "current component"
    # which contains a reference to the most recently instantiated
    # DI::Component. This way, if a DI component hasn't been instantiated,
    # we do not try to reference Datadog.components.
    # In other words, this method exists so that we never attempt to call
    # Datadog.components from the code tracker.
    #
    # @api private
    #
    # source://datadog//lib/datadog/di/base.rb#89
    def current_component; end

    # Deactivates code tracking. In normal usage of DI this method should
    # never be called, however it is used by DI's test suite to reset
    # state for individual tests.
    #
    # Note that deactivating tracking clears out the registry, losing
    # the ability to look up files that have been loaded into the process
    # already.
    #
    # @api private
    #
    # source://datadog//lib/datadog/di/base.rb#68
    def deactivate_tracking!; end

    # @api private
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/di.rb#13
    def enabled?; end

    # @api private
    #
    # source://datadog//lib/datadog/di/base.rb#108
    def remove_current_component(component); end
  end
end

# Tracks loaded Ruby code by source file and maintains a map from
# source file to the loaded code (instruction sequences).
# Also arranges for code in the loaded files to be instrumented by
# line probes that have already been received by the library.
#
# The loaded code is used to target line trace points when installing
# line probes which dramatically improves efficiency of line trace points.
#
# Note that, since most files will only be loaded one time (via the
# "require" mechanism), the code tracker needs to be global and not be
# recreated when the DI component is created.
#
# @api private
#
# source://datadog//lib/datadog/di/code_tracker.rb#22
class Datadog::DI::CodeTracker
  # @api private
  # @return [CodeTracker] a new instance of CodeTracker
  #
  # source://datadog//lib/datadog/di/code_tracker.rb#23
  def initialize; end

  # Returns whether this code tracker has been activated and is
  # tracking.
  #
  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/code_tracker.rb#112
  def active?; end

  # Clears the stored mapping from paths to compiled code.
  #
  # This method should normally never be called. It is meant to be
  # used only by the test suite.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/code_tracker.rb#186
  def clear; end

  # Returns an array of RubVM::InstructionSequence (i.e. the compiled code)
  # for the provided path.
  #
  # The argument can be a full path to a Ruby source code file or a
  # suffix (basename + one or more directories preceding the basename).
  # The idea with suffix matches is that file paths are likely to
  # be different between development and production environments and
  # the source control system uses relative paths and doesn't have
  # absolute paths at all.
  #
  # Suffix matches are not guaranteed to be correct, meaning there may
  # be multiple files with the same basename and they may all match a
  # given suffix. In such cases, this method will return all matching
  # paths (and all of these paths will be attempted to be instrumented
  # by upstream code).
  #
  # If the suffix matches one of the paths completely (which requires it
  # to be an absolute path), only the exactly matching path is returned.
  # Otherwise all known paths that end in the suffix are returned.
  # If no paths match, an empty array is returned.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/code_tracker.rb#138
  def iseqs_for_path_suffix(suffix); end

  # Starts tracking loaded code.
  #
  # This method should generally be called early in application boot
  # process, because any code loaded before code tracking is enabled
  # will not be instrumentable via line probes.
  #
  # Normally tracking should remain active for the lifetime of the
  # process and would not be ever stopped.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/code_tracker.rb#38
  def start; end

  # Stops tracking code that is being loaded.
  #
  # This method should ordinarily never be called - if a file is loaded
  # when code tracking is not active, this file will not be instrumentable
  # by line probes.
  #
  # This method is intended for test suite use only, where multiple
  # code tracker instances are created, to fully clean up the old instances.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/code_tracker.rb#171
  def stop; end

  private

  # Mapping from paths of loaded files to RubyVM::InstructionSequence
  # objects representing compiled code of those files.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/code_tracker.rb#196
  def registry; end

  # @api private
  #
  # source://datadog//lib/datadog/di/code_tracker.rb#199
  def registry_lock; end

  # @api private
  #
  # source://datadog//lib/datadog/di/code_tracker.rb#198
  def trace_point_lock; end
end

# Component for dynamic instrumentation.
#
# Only one instance of the Component should ever be active;
# if configuration is changed, the old distance should be shut down
# prior to the new instance being created.
#
# The Component instance stores all state related to DI, for example
# which probes have been retrieved via remote config,
# intalled tracepoints and so on. Component will clean up all
# resources and installed tracepoints upon shutdown.
#
# @api private
#
# source://datadog//lib/datadog/di/component.rb#15
class Datadog::DI::Component
  # @api private
  # @return [Component] a new instance of Component
  #
  # source://datadog//lib/datadog/di/component.rb#72
  def initialize(settings, agent_settings, logger, code_tracker: T.unsafe(nil), telemetry: T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#89
  def agent_settings; end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#92
  def code_tracker; end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#93
  def instrumenter; end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#90
  def logger; end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#116
  def parse_probe_spec_and_notify(probe_spec); end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#96
  def probe_manager; end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#95
  def probe_notification_builder; end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#94
  def probe_notifier_worker; end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#97
  def redactor; end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#98
  def serializer; end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#88
  def settings; end

  # Shuts down dynamic instrumentation.
  #
  # Removes all code hooks and stops background threads.
  #
  # Does not clear out the code tracker, because it's only populated
  # by code when code is compiled and therefore, if the code tracker
  # was replaced by a new instance, the new instance of it wouldn't have
  # any of the already loaded code tracked.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#108
  def shutdown!(replacement = T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/di/component.rb#91
  def telemetry; end

  class << self
    # @api private
    #
    # source://datadog//lib/datadog/di/component.rb#17
    def build(settings, agent_settings, logger, telemetry: T.unsafe(nil)); end

    # @api private
    #
    # source://datadog//lib/datadog/di/component.rb#32
    def build!(settings, agent_settings, logger, telemetry: T.unsafe(nil)); end

    # Checks whether the runtime environment is supported by
    # dynamic instrumentation. Currently we only require that, if Rails
    # is used, that Rails environment is not development because
    # DI does not currently support code unloading and reloading.
    #
    # @api private
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/di/component.rb#52
    def environment_supported?(settings, logger); end
  end
end

# Configuration for DI
#
# @api private
#
# source://datadog//lib/datadog/di/configuration.rb#6
module Datadog::DI::Configuration; end

# Settings
#
# @api private
#
# source://datadog//lib/datadog/di/configuration/settings.rb#7
module Datadog::DI::Configuration::Settings
  class << self
    # @api private
    #
    # source://datadog//lib/datadog/di/configuration/settings.rb#13
    def add_settings!(base); end

    # @api private
    # @private
    #
    # source://datadog//lib/datadog/di/configuration/settings.rb#8
    def extended(base); end
  end
end

# Contains local and instance variables used when evaluating
# expressions in DI Expression Language.
#
# @api private
#
# source://datadog//lib/datadog/di/context.rb#9
class Datadog::DI::Context
  # @api private
  # @return [Context] a new instance of Context
  #
  # source://datadog//lib/datadog/di/context.rb#10
  def initialize(probe:, settings:, serializer:, locals: T.unsafe(nil), target_self: T.unsafe(nil), path: T.unsafe(nil), caller_locations: T.unsafe(nil), serialized_entry_args: T.unsafe(nil), return_value: T.unsafe(nil), duration: T.unsafe(nil), exception: T.unsafe(nil)); end

  # TODO check how many stack frames we should be keeping/sending,
  # this should be all frames for enriched probes and no frames for
  # non-enriched probes?
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#41
  def caller_locations; end

  # How long the method took to execute, for a method probe
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#46
  def duration; end

  # Exception raised by the method, if any, for a method probe
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#48
  def exception; end

  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#57
  def fetch(var_name); end

  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#65
  def fetch_ivar(var_name); end

  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#34
  def locals; end

  # Actual path of the instrumented file.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#37
  def path; end

  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#31
  def probe; end

  # Return value for the method, for a method probe
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#44
  def return_value; end

  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#42
  def serialized_entry_args; end

  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#50
  def serialized_locals; end

  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#33
  def serializer; end

  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#32
  def settings; end

  # @api private
  #
  # source://datadog//lib/datadog/di/context.rb#35
  def target_self; end
end

# @api private
#
# source://datadog//lib/datadog/di/contrib.rb#7
module Datadog::DI::Contrib
  private

  # This method can be called more than once, to attempt to load
  # DI components that depend on third-party libraries after additional
  # dependencies are loaded (or potentially loaded).
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/contrib.rb#20
  def load_now; end

  # @api private
  #
  # source://datadog//lib/datadog/di/contrib.rb#8
  def load_now_or_later; end

  class << self
    # This method can be called more than once, to attempt to load
    # DI components that depend on third-party libraries after additional
    # dependencies are loaded (or potentially loaded).
    #
    # @api private
    #
    # source://datadog//lib/datadog/di/contrib.rb#20
    def load_now; end

    # @api private
    #
    # source://datadog//lib/datadog/di/contrib.rb#8
    def load_now_or_later; end
  end
end

# Railtie class initializes dynamic instrumentation contrib code
# in Rails environments.
#
# @api private
#
# source://datadog//lib/datadog/di/contrib/railtie.rb#8
class Datadog::DI::Contrib::Railtie < ::Rails::Railtie; end

# @api private
#
# source://datadog//lib/datadog/di/el/expression.rb#5
module Datadog::DI::EL; end

# DI Expression Language compiler.
#
# Converts AST in probe definitions into Expression objects.
#
# WARNING: this class produces strings that are then eval'd as
# Ruby code. Input ASTs are user-controlled. As such the compiler
# must sanitize and escape all input to avoid injection.
#
# Besides quotes and backslashes we must also escape # which is
# starting string interpolation (#{...}).
#
# @api private
#
# source://datadog//lib/datadog/di/el/compiler.rb#18
class Datadog::DI::EL::Compiler
  # @api private
  #
  # source://datadog//lib/datadog/di/el/compiler.rb#19
  def compile(ast); end

  private

  # @api private
  #
  # source://datadog//lib/datadog/di/el/compiler.rb#48
  def compile_partial(ast); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/compiler.rb#158
  def escape(needle); end

  # Returns a textual description of +target+ for use in exception
  # messages. +target+ could be any expression language expression.
  # WARNING: the result of this method is included in eval'd code,
  # it must be sanitized to avoid injection.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/el/compiler.rb#149
  def var_name_maybe(target); end
end

# @api private
#
# source://datadog//lib/datadog/di/el/compiler.rb#43
Datadog::DI::EL::Compiler::MULTI_ARG_METHODS = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://datadog//lib/datadog/di/el/compiler.rb#25
Datadog::DI::EL::Compiler::OPERATORS = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://datadog//lib/datadog/di/el/compiler.rb#34
Datadog::DI::EL::Compiler::SINGLE_ARG_METHODS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://datadog//lib/datadog/di/el/compiler.rb#38
Datadog::DI::EL::Compiler::TWO_ARG_METHODS = T.let(T.unsafe(nil), Array)

# Evaluator for expression language.
#
# @api private
#
# source://datadog//lib/datadog/di/el/evaluator.rb#9
class Datadog::DI::EL::Evaluator
  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#94
  def all(collection, &block); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#111
  def any(collection, &block); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#42
  def contains(haystack, needle); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#90
  def ends_with(haystack, needle); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#128
  def filter(collection, &block); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#56
  def getmember(object, field); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#60
  def index(array_or_hash, index_or_key); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#143
  def instanceof(object, cls_name); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#14
  def iref(var); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#27
  def is_empty(var, var_name); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#38
  def is_undefined(var, var_name); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#18
  def len(var, var_name); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#51
  def matches(haystack, needle); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#10
  def ref(var); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#83
  def starts_with(haystack, needle); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/evaluator.rb#76
  def substring(object, from, to); end
end

# Represents an Expression Language expression.
#
# @api private
#
# source://datadog//lib/datadog/di/el/expression.rb#9
class Datadog::DI::EL::Expression
  # @api private
  # @return [Expression] a new instance of Expression
  #
  # source://datadog//lib/datadog/di/el/expression.rb#10
  def initialize(dsl_expr, compiled_expr); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/expression.rb#29
  def dsl_expr; end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/expression.rb#32
  def evaluate(context); end

  # @api private
  #
  # source://datadog//lib/datadog/di/el/expression.rb#30
  def evaluator; end

  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/el/expression.rb#36
  def satisfied?(context); end
end

# Base class for Dynamic Instrumentation exceptions.
#
# None of these exceptions should be propagated out of DI to user
# applications, therefore these exceptions are not considered to be
# part of the public API of the library.
#
# @api private
#
# source://datadog//lib/datadog/di/error.rb#12
class Datadog::DI::Error < ::StandardError; end

# Failed to communicate to the local Datadog agent (e.g. to send
# probe status or a snapshot).
#
# @api private
#
# source://datadog//lib/datadog/di/error.rb#19
class Datadog::DI::Error::AgentCommunicationError < ::Datadog::DI::Error; end

# Variable name with invalid characters in an expression language
# expression.
#
# @api private
#
# source://datadog//lib/datadog/di/error.rb#69
class Datadog::DI::Error::BadVariableName < ::Datadog::DI::Error::InvalidExpression; end

# Attempting to instrument a method or file which does not exist.
#
# This could be due to the code that is referenced in the probe
# having not been loaded yet, or due to the probe referencing code
# that does not in fact exist anywhere (e.g. due to a misspelling).
#
# @api private
#
# source://datadog//lib/datadog/di/error.rb#27
class Datadog::DI::Error::DITargetNotDefined < ::Datadog::DI::Error; end

# Attempting to instrument a line and the file containing the line
# was loaded prior to code tracking being enabled.
#
# @api private
#
# source://datadog//lib/datadog/di/error.rb#32
class Datadog::DI::Error::DITargetNotInRegistry < ::Datadog::DI::Error; end

# Base class for exceptions arising when evaluating expression language
# expressions.
#
# @api private
#
# source://datadog//lib/datadog/di/error.rb#74
class Datadog::DI::Error::ExpressionEvaluationError < ::Datadog::DI::Error; end

# Base class for exceptions arising during expression language AST
# compilation into Ruby code.
#
# Expression language does not specify behavior in all cases,
# leaving some choices to the language implementation in the tracers.
# It is therefore possible that some technically valid expressions are
# prohibited by our implementation.
#
# It is also possible that the sanitizers/validators prohibit some
# esoteric constructs that are technically valid in Ruby,
# for example if instance variable name rules are relaxed to allow
# arbitrary characters in them as permitted in method names.
#
# @api private
#
# source://datadog//lib/datadog/di/error.rb#64
class Datadog::DI::Error::InvalidExpression < ::Datadog::DI::Error; end

# Probe does not contain a line number (i.e., is not a line probe).
#
# @api private
#
# source://datadog//lib/datadog/di/error.rb#14
class Datadog::DI::Error::MissingLineNumber < ::Datadog::DI::Error; end

# Raised when installing a line probe and multiple files match the
# specified path suffix.
# A probe must be installed into one file only, since UI only
# supports one instrumented location for a probe.
# If multiple files match, UI cannot properly render the data from
# all of them, and arbitrarily choosing one file may be not what the
# user intended. Instrumentation will fail when multiple files match
# and the user will need to make their suffix more precise.
#
# @api private
#
# source://datadog//lib/datadog/di/error.rb#49
class Datadog::DI::Error::MultiplePathsMatch < ::Datadog::DI::Error; end

# Raised when trying to install a probe whose installation failed
# earlier in the same process. This exception should contain the
# original exception report from initial installation attempt.
#
# @api private
#
# source://datadog//lib/datadog/di/error.rb#38
class Datadog::DI::Error::ProbePreviouslyFailed < ::Datadog::DI::Error; end

# Extends Datadog tracing with DI features
#
# @api private
#
# source://datadog//lib/datadog/di/extensions.rb#9
module Datadog::DI::Extensions
  class << self
    # Inject DI into global objects.
    #
    # @api private
    #
    # source://datadog//lib/datadog/di/extensions.rb#11
    def activate!; end
  end
end

# Arranges to invoke a callback when a particular Ruby method or
# line of code is executed.
#
# Method instrumentation is accomplished via module prepending.
# Unlike the alias_method_chain pattern, module prepending permits
# removing instrumentation with no virtually performance side-effects
# (the target class retains an empty included module, but no additional
# code is executed as part of target method).
#
# Method hooking works with explicitly defined methods and "virtual"
# methods defined via method_missing.
#
# Line instrumentation is normally accomplished with a targeted line
# trace point. This requires MRI and at least Ruby 2.6.
# For testing purposes, it is also possible to use untargeted trace
# points, but they have a huge performance penalty and should generally
# not be used in production.
#
# Targeted line trace points require tracking of loaded code; see
# the CodeTracker class for more details.
#
# Instrumentation state (i.e., the module or trace point used for
# instrumentation) is stored in the Probe instance. Thus, Instrumenter
# mutates attributes of Probes it is asked to install or remove.
# A previous version of the code attempted to maintain the instrumentation
# state within Instrumenter but this was very messy and hard to
# guarantee correctness of. With the state stored in Probes, it is
# straightforward to determine if a Probe has been successfully instrumented,
# and thus requires cleanup, and to properly clean it up.
#
# Note that the upstream code is responsible for generally storing Probes.
# This is normally accomplished by ProbeManager. ProbeManager stores all
# known probes, instrumented or not, and is responsible for calling
# +unhook+ of Instrumenter to clean up instrumentation when a user
# deletes a probe in UI or when DI is shut down.
#
# Given the need to store state, and also that there are several Probe
# attributes that affect how instrumentation is set up and that must be
# consulted very early in the callback invocation (e.g., to perform
# rate limiting correctly), Instrumenter takes Probe instances as
# arguments rather than e.g. file + line number or class + method name.
# As a result, Instrumenter is rather coupled to DI the product and is
# not trivially usable as a general-purpose Ruby instrumentation tool
# (however, Probe instances can be replaced by OpenStruct instances
# providing the same interface with not much effort).
#
# Instrumenter (this class) is responsible for building snapshots.
# This is because to capture values on method entry, those values need to
# be duplicated or serialized into immutable values to prevent their
# modification by the instrumented method. Therefore this class must
# do at least some serialization/snapshot building and to keep the code
# well-encapsulated, all serialization/snapshot building should thus be
# initiated from this class rather than downstream code.
#
# As a consequence of Instrumenter building snapshots, it should not
# expose TracePoint objects to any downstream code.
#
# @api private
#
# source://datadog//lib/datadog/di/instrumenter.rb#68
class Datadog::DI::Instrumenter
  # @api private
  # @return [Instrumenter] a new instance of Instrumenter
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#69
  def initialize(settings, serializer, logger, code_tracker: T.unsafe(nil), telemetry: T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#83
  def code_tracker; end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#446
  def hook(probe, &block); end

  # Instruments a particluar line in a source file.
  # Note that this method only works for physical files,
  # not for eval'd code, unless the eval'd code is associated with
  # a file name and client invokes this method with the correct
  # file name for the eval'd code.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#261
  def hook_line(probe, &block); end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#92
  def hook_method(probe, &block); end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#81
  def logger; end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#80
  def serializer; end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#79
  def settings; end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#82
  def telemetry; end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#457
  def unhook(probe); end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#437
  def unhook_line(probe); end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#243
  def unhook_method(probe); end

  private

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#487
  def lock; end

  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#489
  def raise_if_probe_in_loaded_features(probe); end

  # TODO test that this resolves qualified names e.g. A::B
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#510
  def symbolize_class_name(cls_name); end

  class << self
    # @api private
    #
    # source://datadog//lib/datadog/di/instrumenter.rb#469
    def get_local_variables(trace_point); end
  end
end

# This is a substitute for Thread::Backtrace::Location
# which does not have a public constructor.
# Used for the fabricated stack frame for the method itself
# for method probes (which use Module#prepend and thus aren't called
# from the method but from outside of the method).
#
# @api private
#
# source://datadog//lib/datadog/di/instrumenter.rb#90
class Datadog::DI::Instrumenter::Location < ::Struct
  # Returns the value of attribute label
  #
  # @return [Object] the current value of label
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#90
  def label; end

  # Sets the attribute label
  #
  # @param value [Object] the value to set the attribute label to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#90
  def label=(_); end

  # Returns the value of attribute lineno
  #
  # @return [Object] the current value of lineno
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#90
  def lineno; end

  # Sets the attribute lineno
  #
  # @param value [Object] the value to set the attribute lineno to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#90
  def lineno=(_); end

  # Returns the value of attribute path
  #
  # @return [Object] the current value of path
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#90
  def path; end

  # Sets the attribute path
  #
  # @param value [Object] the value to set the attribute path to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/di/instrumenter.rb#90
  def path=(_); end

  class << self
    # source://datadog//lib/datadog/di/instrumenter.rb#90
    def [](*_arg0); end

    # source://datadog//lib/datadog/di/instrumenter.rb#90
    def inspect; end

    # source://datadog//lib/datadog/di/instrumenter.rb#90
    def keyword_init?; end

    # source://datadog//lib/datadog/di/instrumenter.rb#90
    def members; end

    # source://datadog//lib/datadog/di/instrumenter.rb#90
    def new(*_arg0); end
  end
end

# @api private
#
# source://datadog//lib/datadog/di/base.rb#18
Datadog::DI::LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# Logger facade to add the +trace+ method.
#
# @api private
#
# source://datadog//lib/datadog/di/logger.rb#10
class Datadog::DI::Logger
  extend ::Forwardable

  # @api private
  # @return [Logger] a new instance of Logger
  #
  # source://datadog//lib/datadog/di/logger.rb#13
  def initialize(settings, target); end

  # source://datadog//lib/datadog/di/logger.rb#21
  def debug(*args, **_arg1, &block); end

  # @api private
  #
  # source://datadog//lib/datadog/di/logger.rb#18
  def settings; end

  # @api private
  #
  # source://datadog//lib/datadog/di/logger.rb#19
  def target; end

  # @api private
  #
  # source://datadog//lib/datadog/di/logger.rb#23
  def trace(&block); end
end

# Encapsulates probe information (as received via remote config)
# and state (e.g. whether the probe was installed, or executed).
#
# It is possible that remote configuration will specify an unsupported
# probe type or attribute, due to new DI functionality being added
# over time. We want to have predictable behavior in such cases, and
# since we can't guarantee that there will be enough information in
# a remote config payload to construct a functional probe, ProbeBuilder
# and remote config code must be prepared to deal with exceptions
# raised by Probe constructor in particular. Therefore, Probe constructor
# will raise an exception if it determines that there is not enough
# information (or conflicting information) in the arguments to create a
# functional probe, and upstream code is tasked with not spamming logs
# with notifications of such errors (and potentially limiting the
# attempts to construct probe from a given payload).
#
# Note that, while remote configuration provides line numbers as an
# array, the only supported line number configuration is a single line
# (this is the case for all languages currently). Therefore Probe
# only supports one line number, and ProbeBuilder is responsible for
# extracting that one line number out of the array received from RC.
#
# Note: only some of the parameter/attribute values are currently validated.
#
# @api private
#
# source://datadog//lib/datadog/di/probe.rb#34
class Datadog::DI::Probe
  # @api private
  # @return [Probe] a new instance of Probe
  #
  # source://datadog//lib/datadog/di/probe.rb#37
  def initialize(id:, type:, file: T.unsafe(nil), line_no: T.unsafe(nil), type_name: T.unsafe(nil), method_name: T.unsafe(nil), template: T.unsafe(nil), template_segments: T.unsafe(nil), capture_snapshot: T.unsafe(nil), max_capture_depth: T.unsafe(nil), max_capture_attribute_count: T.unsafe(nil), condition: T.unsafe(nil), rate_limit: T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/probe.rb#118
  def capture_snapshot?; end

  # The compiled condition for the probe, as a String.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#102
  def condition; end

  # TODO emitting_notified reads and writes should in theory be locked,
  # however since DI is only implemented for MRI in practice the missing
  # locking should not cause issues.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#196
  def emitting_notified=(_arg0); end

  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/probe.rb#197
  def emitting_notified?; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#205
  def executed_on_line!; end

  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/probe.rb#201
  def executed_on_line?; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#94
  def file; end

  # Returns whether the provided +path+ matches the user-designated
  # file (of a line probe).
  #
  # Delegates to Utils.path_can_match_spec? which performs fuzzy
  # matching. See the comments in utils.rb for details.
  #
  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/probe.rb#171
  def file_matches?(path); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#92
  def id; end

  # Instrumentation module for method probes.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#182
  def instrumentation_module; end

  # Instrumentation module for method probes.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#182
  def instrumentation_module=(_arg0); end

  # Line trace point for line probes. Normally this would be a targeted
  # trace point.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#186
  def instrumentation_trace_point; end

  # Line trace point for line probes. Normally this would be a targeted
  # trace point.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#186
  def instrumentation_trace_point=(_arg0); end

  # Actual path to the file instrumented by the probe, for line probes,
  # when code tracking is available and line trace point is targeted.
  # For untargeted line trace points instrumented path will be nil.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#191
  def instrumented_path; end

  # Actual path to the file instrumented by the probe, for line probes,
  # when code tracking is available and line trace point is targeted.
  # For untargeted line trace points instrumented path will be nil.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#191
  def instrumented_path=(_arg0); end

  # Returns whether the probe is a line probe.
  #
  # Method probes may still specify a file name (to aid in locating the
  # method or for stack traversal purposes?), therefore we do not check
  # for file name/path presence here and just consider the line number.
  #
  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/probe.rb#127
  def line?; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#95
  def line_no; end

  # Returns the line number associated with the probe, raising
  # Error::MissingLineNumber if the probe does not have a line number
  # associated with it.
  #
  # This method is used by instrumentation driver to ensure a line number
  # that is passed into the instrumentation logic is actually a line number
  # and not nil.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#146
  def line_no!; end

  # Source code location of the probe, for diagnostic reporting.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#154
  def location; end

  # Configured maximum capture attribute count. Can be nil in which case
  # the global default will be used.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#110
  def max_capture_attribute_count; end

  # Configured maximum capture depth. Can be nil in which case
  # the global default will be used.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#106
  def max_capture_depth; end

  # Returns whether the probe is a method probe.
  #
  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/probe.rb#135
  def method?; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#97
  def method_name; end

  # Rate limit in effect, in invocations per second. Always present.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#113
  def rate_limit; end

  # Rate limiter object. For internal DI use only.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#116
  def rate_limiter; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#98
  def template; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#99
  def template_segments; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#93
  def type; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe.rb#96
  def type_name; end
end

# @api private
#
# source://datadog//lib/datadog/di/probe.rb#35
Datadog::DI::Probe::KNOWN_TYPES = T.let(T.unsafe(nil), Array)

# Creates Probe instances from remote configuration payloads.
#
# Due to the dynamic instrumentation product evolving over time,
# it is possible that the payload corresponds to a type of probe that the
# current version of the library does not handle.
# For now ArgumentError is raised in such cases (by ProbeBuilder or
# Probe constructor), since generally DI is meant to rescue all exceptions
# internally and not propagate any exceptions to applications.
# A dedicated exception could be added in the future if there is a use case
# for it.
#
# @api private
#
# source://datadog//lib/datadog/di/probe_builder.rb#22
module Datadog::DI::ProbeBuilder
  private

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_builder.rb#29
  def build_from_remote_config(config); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_builder.rb#63
  def build_template_segments(segments); end

  class << self
    # @api private
    #
    # source://datadog//lib/datadog/di/probe_builder.rb#29
    def build_from_remote_config(config); end

    # @api private
    #
    # source://datadog//lib/datadog/di/probe_builder.rb#63
    def build_template_segments(segments); end
  end
end

# @api private
#
# source://datadog//lib/datadog/di/probe_builder.rb#23
Datadog::DI::ProbeBuilder::PROBE_TYPES = T.let(T.unsafe(nil), Hash)

# Stores probes received from remote config (that we can parse, in other
# words, whose type/attributes we support), requests needed instrumentation
# for the probes via Instrumenter, and stores pending probes (those which
# haven't yet been instrumented successfully due to their targets not
# existing) and failed probes (where we are certain the target will not
# ever be loaded, or otherwise become valid).
#
# @api private
#
# source://datadog//lib/datadog/di/probe_manager.rb#17
class Datadog::DI::ProbeManager
  # @api private
  # @return [ProbeManager] a new instance of ProbeManager
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#18
  def initialize(settings, instrumenter, probe_notification_builder, probe_notifier_worker, logger, telemetry: T.unsafe(nil)); end

  # Requests to install the specified probe.
  #
  # If the target of the probe does not exist, assume the relevant
  # code is not loaded yet (rather than that it will never be loaded),
  # and store the probe in a pending probe list. When classes are
  # defined, or files loaded, the probe will be checked against the
  # newly defined classes/loaded files, and will be installed if it
  # matches.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#95
  def add_probe(probe); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#51
  def clear_hooks; end

  # TODO test that close is called during component teardown and
  # the trace point is cleared
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#46
  def close; end

  # Class/module definition trace point (:end type).
  # Used to install hooks when the target classes/modules aren't yet
  # defined when the hook request is received.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#248
  def definition_trace_point; end

  # Probes that failed to instrument for reasons other than the target is
  # not yet loaded are added to this collection, so that we do not try
  # to instrument them every time remote configuration is processed.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#81
  def failed_probes; end

  # Installs pending line probes, if any, for the file of the specified
  # absolute path.
  #
  # This method is meant to be called from the script_compiled trace
  # point, which is invoked for each required or loaded file
  # (and also for eval'd code, but those invocations are filtered out).
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#210
  def install_pending_line_probes(path); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#66
  def installed_probes; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#62
  def instrumenter; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#41
  def logger; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#72
  def pending_probes; end

  # Entry point invoked from the instrumentation when the specfied probe
  # is invoked (that is, either its target method is invoked, or
  # execution reached its target file/line).
  #
  # This method is responsible for queueing probe status to be sent to the
  # backend (once per the probe's lifetime) and a snapshot corresponding
  # to the current invocation.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#232
  def probe_executed_callback(context); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#63
  def probe_notification_builder; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#64
  def probe_notifier_worker; end

  # Removes probes with ids other than in the specified list.
  #
  # This method is meant to be invoked from remote config processor.
  # Remote config contains the list of currently defined probes; any
  # probes not in that list have been removed by user and should be
  # de-instrumented from the application.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#143
  def remove_other_probes(probe_ids); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#61
  def settings; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#42
  def telemetry; end

  private

  # Installs pending method probes, if any, for the specified class.
  #
  # This method is meant to be called from the "end" trace point,
  # which is invoked for each class definition.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_manager.rb#177
  def install_pending_method_probes(cls); end
end

# Builds probe status notification and snapshot payloads.
#
# @api private
#
# source://datadog//lib/datadog/di/probe_notification_builder.rb#10
class Datadog::DI::ProbeNotificationBuilder
  # @api private
  # @return [ProbeNotificationBuilder] a new instance of ProbeNotificationBuilder
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#11
  def initialize(settings, serializer); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#31
  def build_emitting(probe); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#37
  def build_errored(probe, exc); end

  # Duration is in seconds.
  # path is the actual path of the instrumented file.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#45
  def build_executed(context); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#25
  def build_installed(probe); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#19
  def build_received(probe); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#52
  def build_snapshot(context); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#17
  def serializer; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#16
  def settings; end

  private

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#210
  def active_span; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#204
  def active_trace; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#155
  def build_status(probe, message:, status:); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#179
  def evaluate_template(template_segments, context); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#173
  def format_caller_locations(caller_locations); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notification_builder.rb#200
  def timestamp_now; end
end

# @api private
#
# source://datadog//lib/datadog/di/probe_notification_builder.rb#50
Datadog::DI::ProbeNotificationBuilder::MILLISECONDS = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://datadog//lib/datadog/di/probe_notification_builder.rb#49
Datadog::DI::ProbeNotificationBuilder::NANOSECONDS = T.let(T.unsafe(nil), Integer)

# Background worker thread for sending probe statuses and snapshots
# to the backend (via the agent).
#
# The loop inside the worker rescues all exceptions to prevent termination
# due to unhandled exceptions raised by any downstream code.
# This includes communication and protocol errors when sending the
# events to the agent.
#
# The worker groups the data to send into batches. The goal is to perform
# no more than one network operation per event type per second.
# There is also a limit on the length of the sending queue to prevent
# it from growing without bounds if upstream code generates an enormous
# number of events for some reason.
#
# Wake-up events are used (via ConditionVariable) to keep the thread
# asleep if there is no work to be done.
#
# @api private
#
# source://datadog//lib/datadog/di/probe_notifier_worker.rb#25
class Datadog::DI::ProbeNotifierWorker
  # @api private
  # @return [ProbeNotifierWorker] a new instance of ProbeNotifierWorker
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#26
  def initialize(settings, logger, agent_settings:, telemetry: T.unsafe(nil)); end

  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#211
  def add_snapshot(event); end

  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#211
  def add_status(event); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#46
  def agent_settings; end

  # Waits for background thread to send pending notifications.
  #
  # This method waits for the notification queue to become empty
  # rather than for a particular set of notifications to be sent out,
  # therefore, it should only be called when there is no parallel
  # activity (in another thread) that causes more notifications
  # to be generated.
  #
  # This method is used by the test suite to wait until notifications have
  # been sent out, and could be used for graceful stopping of the
  # worker thread.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#122
  def flush; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#44
  def logger; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#43
  def settings; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#48
  def start; end

  # Stops the background thread.
  #
  # Attempts a graceful stop with the specified timeout, then falls back
  # to killing the thread using Thread#kill.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#99
  def stop(timeout = T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#45
  def telemetry; end

  private

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#185
  def do_send_snapshot(batch); end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#177
  def do_send_status(batch); end

  # This method should be called while @lock is held.
  #
  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#167
  def io_in_progress?; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#171
  def last_sent; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#299
  def maybe_send; end

  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#247
  def maybe_send_snapshot; end

  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#247
  def maybe_send_status; end

  # Convenience method to keep line length reasonable in the rest of the file.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#162
  def min_send_interval; end

  # Determine how much longer the worker thread should sleep
  # so as not to send in less than min send interval since the last send.
  # Important: this method must be called when @lock is held.
  #
  # Returns the time remaining to sleep.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#290
  def set_sleep_remaining; end

  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#201
  def snapshot_queue; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#181
  def snapshot_transport; end

  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#201
  def status_queue; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#173
  def status_transport; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#189
  def tags; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#159
  def thread; end

  # @api private
  #
  # source://datadog//lib/datadog/di/probe_notifier_worker.rb#158
  def wake; end
end

# Provides logic to identify sensitive information in snapshots captured
# by dynamic instrumentation.
#
# Redaction can be performed based on identifier or attribute name,
# or class name of said identifier or attribute. Redaction does not take
# into account variable values.
#
# There is a built-in list of identifier names which will be subject to
# redaction. Additional names can be provided by the user via the
# settings.dynamic_instrumentation.redacted_identifiers setting or
# the DD_DYNAMIC_INSTRUMENTATION_REDACTED_IDENTIFIERS environment
# variable. Currently no class names are subject to redaction by default;
# class names can be provided via the
# settings.dynamic_instrumentation.redacted_type_names setting or
# DD_DYNAMIC_INSTRUMENTATION_REDACTED_TYPES environment variable.
#
# Redacted identifiers must match exactly to an attribute name, a key
# in a hash or a variable name. Redacted types can either be matched
# exactly or, if the name is suffixed with an asterisk (*), any class
# whose name contains the specified prefix will be subject to redaction.
#
# When specifying class (type) names to be redacted, user must specify
# fully-qualified names. For example, if `Token` or `Token*` are
# specified to be redacted, instances of ::Token will be redacted
# but instances of ::Foo::Token will not be. To redact the latter,
# specify `Foo::Token` or `::Foo::Token` as redacted types.
#
# This class does not perform redaction itself (i.e., value replacement
# with a placeholder). This replacement is performed by Serializer.
#
# @api private
#
# source://datadog//lib/datadog/di/redactor.rb#36
class Datadog::DI::Redactor
  # @api private
  # @return [Redactor] a new instance of Redactor
  #
  # source://datadog//lib/datadog/di/redactor.rb#37
  def initialize(settings); end

  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/redactor.rb#43
  def redact_identifier?(name); end

  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/redactor.rb#47
  def redact_type?(value); end

  # @api private
  #
  # source://datadog//lib/datadog/di/redactor.rb#41
  def settings; end

  private

  # Input can be a string or a symbol.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/redactor.rb#182
  def normalize(str); end

  # @api private
  #
  # source://datadog//lib/datadog/di/redactor.rb#58
  def redacted_identifiers; end

  # @api private
  #
  # source://datadog//lib/datadog/di/redactor.rb#68
  def redacted_type_names_regexp; end
end

# Copied from dd-trace-py
#
# @api private
#
# source://datadog//lib/datadog/di/redactor.rb#93
Datadog::DI::Redactor::DEFAULT_REDACTED_IDENTIFIERS = T.let(T.unsafe(nil), Array)

# Provides an interface expected by the core Remote subsystem to
# receive DI-specific remote configuration.
#
# In order to apply (i.e., act on) the configuration, we need the
# state stored under DI Component. Thus, this module forwards actual
# configuration application to the ProbeManager associated with the
# global DI Component.
#
# @api private
#
# source://datadog//lib/datadog/di/remote.rb#14
module Datadog::DI::Remote
  class << self
    # @api private
    #
    # source://datadog//lib/datadog/di/remote.rb#26
    def capabilities; end

    # @api private
    #
    # source://datadog//lib/datadog/di/remote.rb#20
    def products; end

    # @api private
    #
    # source://datadog//lib/datadog/di/remote.rb#126
    def receiver(products = T.unsafe(nil), &block); end

    # @api private
    #
    # source://datadog//lib/datadog/di/remote.rb#30
    def receivers(telemetry); end

    private

    # @api private
    # @raise [ReadError]
    #
    # source://datadog//lib/datadog/di/remote.rb#133
    def parse_content(content); end
  end
end

# @api private
#
# source://datadog//lib/datadog/di/remote.rb#15
class Datadog::DI::Remote::ReadError < ::StandardError; end

# Serializes captured snapshot to primitive types, which are subsequently
# serialized to JSON and sent to the backend.
#
# This class performs actual removal of sensitive values from the
# snapshots. It uses Redactor to determine which values are sensitive
# and need to be removed.
#
# Serializer normally ought not to invoke user (application) code,
# to guarantee predictable performance. However, objects like ActiveRecord
# models cannot be usefully serialized into primitive types without
# custom logic (for example, the attributes are more than 3 levels
# down from the top-level object which is the default capture depth,
# thus they won't be captured at all). To accommodate complex objects,
# there is an extension mechanism implemented permitting registration
# of serializer callbacks for arbitrary types. Applications and libraries
# definining such serializer callbacks should be very careful to
# have predictable performance and avoid exceptions and infinite loops
# and other such issues.
#
# All serialization methods take the names of the variables being
# serialized in order to be able to redact values.
#
# The result of serialization should not reference parameter values when
# the values are mutable (currently, this only applies to string values).
# Serializer will duplicate such mutable values, so that if method
# arguments are captured at entry and then modified during method execution,
# the serialized values from entry are correctly preserved.
# Alternatively, we could pass a parameter to the serialization methods
# which would control whether values are duplicated. This may be more
# efficient but there would be additional overhead from passing this
# parameter all the time and the API would get more complex.
#
# Note: "self" cannot be used as a parameter name in Ruby, therefore
# there should never be a conflict between instance variable
# serialization and method parameters.
#
# @api private
#
# source://datadog//lib/datadog/di/serializer.rb#44
class Datadog::DI::Serializer
  # @api private
  # @return [Serializer] a new instance of Serializer
  #
  # source://datadog//lib/datadog/di/serializer.rb#75
  def initialize(settings, redactor, telemetry: T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#85
  def combine_args(args, kwargs, target_self); end

  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#82
  def redactor; end

  # Serializes positional and keyword arguments to a method,
  # as obtained by a method probe.
  #
  # UI supports a single argument list only and does not distinguish
  # between positional and keyword arguments. We convert positional
  # arguments to keyword arguments ("arg1", "arg2", ...) and ensure
  # the positional arguments are listed first.
  #
  # Instance variables are technically a hash just like kwargs,
  # we take them as a separate parameter to avoid a hash merge
  # in upstream code.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#108
  def serialize_args(args, kwargs, target_self, depth: T.unsafe(nil), attribute_count: T.unsafe(nil)); end

  # Serializes a single named value.
  #
  # The name is needed to perform sensitive data redaction.
  #
  # In some cases, the value being serialized does not have a name
  # (for example, it is the return value of a method).
  # In this case +name+ can be nil.
  #
  # Returns a data structure comprised of only values of basic types
  # (integers, strings, arrays, hashes).
  #
  # Respects string length, collection size and traversal depth limits.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#139
  def serialize_value(value, name: T.unsafe(nil), depth: T.unsafe(nil), attribute_count: T.unsafe(nil), type: T.unsafe(nil)); end

  # This method is used for serializing arbitrary values into log messages.
  # Because the output is meant to be human-readable, we cannot use
  # the "normal" serialization format which is meant to be machine-readable.
  # Serialize objects with depth of 1 and include the class name.
  #
  # Note that this method does not (currently) utilize the custom
  # serializers that the "normal" serialization logic uses.
  #
  # This serializer differs from the RFC in two ways:
  # 1. We omit the middle of long strings rather than the end,
  #    and also the inner entries in arrays/hashes/objects.
  # 2. We use Ruby-ish syntax for hashes and objects.
  #
  # We also use the Ruby-like syntax for symbols, which don't exist
  # in other languages.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#290
  def serialize_value_for_message(value, depth = T.unsafe(nil)); end

  # Serializes variables captured by a line probe.
  #
  # These are normally local variables that exist on a particular line
  # of executed code.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#119
  def serialize_vars(vars, depth: T.unsafe(nil), attribute_count: T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#81
  def settings; end

  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#83
  def telemetry; end

  private

  # Returns the name for the specified class object.
  #
  # Ruby can have nameless classes, e.g. Class.new is a class object
  # with no name. We return a placeholder for such nameless classes.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#393
  def class_name(cls); end

  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#381
  def max_capture_attribute_count_for_message; end

  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#373
  def max_capture_collection_size_for_message; end

  # @api private
  #
  # source://datadog//lib/datadog/di/serializer.rb#400
  def serialize_string_or_symbol_for_message(value); end

  class << self
    # @api private
    #
    # source://datadog//lib/datadog/di/serializer.rb#71
    def register(condition: T.unsafe(nil), &block); end
  end
end

# @api private
#
# source://datadog//lib/datadog/di/serializer.rb#371
Datadog::DI::Serializer::MAX_MESSAGE_ATTRIBUTE_COUNT = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://datadog//lib/datadog/di/serializer.rb#370
Datadog::DI::Serializer::MAX_MESSAGE_COLLECTION_SIZE = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://datadog//lib/datadog/di/transport/http/client.rb#13
module Datadog::DI::Transport; end

# @api private
#
# source://datadog//lib/datadog/di/transport/diagnostics.rb#9
module Datadog::DI::Transport::Diagnostics; end

# @api private
#
# source://datadog//lib/datadog/di/transport/diagnostics.rb#10
class Datadog::DI::Transport::Diagnostics::EncodedParcel
  include ::Datadog::Core::Transport::Parcel
end

# @api private
#
# source://datadog//lib/datadog/di/transport/diagnostics.rb#14
class Datadog::DI::Transport::Diagnostics::Request < ::Datadog::Core::Transport::Request; end

# @api private
#
# source://datadog//lib/datadog/di/transport/diagnostics.rb#17
class Datadog::DI::Transport::Diagnostics::Transport
  # @api private
  # @return [Transport] a new instance of Transport
  #
  # source://datadog//lib/datadog/di/transport/diagnostics.rb#20
  def initialize(apis, default_api, logger:); end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/diagnostics.rb#18
  def apis; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/diagnostics.rb#18
  def client; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/diagnostics.rb#27
  def current_api; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/diagnostics.rb#18
  def current_api_id; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/diagnostics.rb#18
  def default_api; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/diagnostics.rb#18
  def logger; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/diagnostics.rb#31
  def send_diagnostics(payload); end
end

# Namespace for HTTP transport components
#
# @api private
#
# source://datadog//lib/datadog/di/transport/http/client.rb#14
module Datadog::DI::Transport::HTTP
  private

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http.rb#17
  def diagnostics(agent_settings:, logger:, api_version: T.unsafe(nil), headers: T.unsafe(nil)); end

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http.rb#37
  def input(agent_settings:, logger:, api_version: T.unsafe(nil), headers: T.unsafe(nil)); end

  class << self
    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # @api private
    #
    # source://datadog//lib/datadog/di/transport/http.rb#17
    def diagnostics(agent_settings:, logger:, api_version: T.unsafe(nil), headers: T.unsafe(nil)); end

    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # @api private
    #
    # source://datadog//lib/datadog/di/transport/http.rb#37
    def input(agent_settings:, logger:, api_version: T.unsafe(nil), headers: T.unsafe(nil)); end
  end
end

# Namespace for API components
#
# @api private
#
# source://datadog//lib/datadog/di/transport/http/api.rb#15
module Datadog::DI::Transport::HTTP::API
  private

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/api.rb#22
  def defaults; end

  class << self
    # @api private
    #
    # source://datadog//lib/datadog/di/transport/http/api.rb#22
    def defaults; end
  end
end

# Default API versions
#
# @api private
#
# source://datadog//lib/datadog/di/transport/http/api.rb#17
Datadog::DI::Transport::HTTP::API::DIAGNOSTICS = T.let(T.unsafe(nil), String)

# @api private
#
# source://datadog//lib/datadog/di/transport/http/api.rb#18
Datadog::DI::Transport::HTTP::API::INPUT = T.let(T.unsafe(nil), String)

# Routes, encodes, and sends DI data to the trace agent via HTTP.
#
# @api private
#
# source://datadog//lib/datadog/di/transport/http/client.rb#16
class Datadog::DI::Transport::HTTP::Client
  include ::Datadog::DI::Transport::HTTP::Diagnostics::Client
  include ::Datadog::DI::Transport::HTTP::Input::Client

  # @api private
  # @return [Client] a new instance of Client
  #
  # source://datadog//lib/datadog/di/transport/http/client.rb#19
  def initialize(api, logger:); end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/client.rb#17
  def api; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/client.rb#40
  def build_env(request); end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/client.rb#17
  def logger; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/client.rb#24
  def send_request(request, &block); end
end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/diagnostics.rb#11
module Datadog::DI::Transport::HTTP::Diagnostics; end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/diagnostics.rb#20
module Datadog::DI::Transport::HTTP::Diagnostics::API; end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/diagnostics.rb#41
class Datadog::DI::Transport::HTTP::Diagnostics::API::Endpoint < ::Datadog::Core::Transport::HTTP::API::Endpoint
  # @api private
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://datadog//lib/datadog/di/transport/http/diagnostics.rb#44
  def initialize(path, encoder); end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/diagnostics.rb#49
  def call(env, &block); end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/diagnostics.rb#42
  def encoder; end
end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/diagnostics.rb#21
class Datadog::DI::Transport::HTTP::Diagnostics::API::Instance < ::Datadog::Core::Transport::HTTP::API::Instance
  # @api private
  # @raise [Core::Transport::HTTP::API::Instance::EndpointNotSupportedError]
  #
  # source://datadog//lib/datadog/di/transport/http/diagnostics.rb#22
  def send_diagnostics(env); end
end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/diagnostics.rb#31
class Datadog::DI::Transport::HTTP::Diagnostics::API::Spec < ::Datadog::Core::Transport::HTTP::API::Spec
  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/diagnostics.rb#32
  def diagnostics; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/diagnostics.rb#32
  def diagnostics=(_arg0); end

  # @api private
  # @raise [Core::Transport::HTTP::API::Spec::EndpointNotDefinedError]
  #
  # source://datadog//lib/datadog/di/transport/http/diagnostics.rb#34
  def send_diagnostics(env, &block); end
end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/diagnostics.rb#12
module Datadog::DI::Transport::HTTP::Diagnostics::Client
  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/diagnostics.rb#13
  def send_diagnostics_payload(request); end
end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/input.rb#11
module Datadog::DI::Transport::HTTP::Input; end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/input.rb#20
module Datadog::DI::Transport::HTTP::Input::API; end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/input.rb#41
class Datadog::DI::Transport::HTTP::Input::API::Endpoint < ::Datadog::Core::Transport::HTTP::API::Endpoint
  # @api private
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://datadog//lib/datadog/di/transport/http/input.rb#47
  def initialize(path, encoder); end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/input.rb#52
  def call(env, &block); end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/input.rb#44
  def encoder; end
end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/input.rb#42
Datadog::DI::Transport::HTTP::Input::API::Endpoint::HEADER_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# @api private
#
# source://datadog//lib/datadog/di/transport/http/input.rb#21
class Datadog::DI::Transport::HTTP::Input::API::Instance < ::Datadog::Core::Transport::HTTP::API::Instance
  # @api private
  # @raise [Core::Transport::HTTP::API::Instance::EndpointNotSupportedError]
  #
  # source://datadog//lib/datadog/di/transport/http/input.rb#22
  def send_input(env); end
end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/input.rb#31
class Datadog::DI::Transport::HTTP::Input::API::Spec < ::Datadog::Core::Transport::HTTP::API::Spec
  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/input.rb#32
  def input; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/input.rb#32
  def input=(_arg0); end

  # @api private
  # @raise [Core::Transport::HTTP::API::Spec::EndpointNotDefinedError]
  #
  # source://datadog//lib/datadog/di/transport/http/input.rb#34
  def send_input(env, &block); end
end

# @api private
#
# source://datadog//lib/datadog/di/transport/http/input.rb#12
module Datadog::DI::Transport::HTTP::Input::Client
  # @api private
  #
  # source://datadog//lib/datadog/di/transport/http/input.rb#13
  def send_input_payload(request); end
end

# @api private
#
# source://datadog//lib/datadog/di/transport/input.rb#9
module Datadog::DI::Transport::Input; end

# @api private
#
# source://datadog//lib/datadog/di/transport/input.rb#10
class Datadog::DI::Transport::Input::EncodedParcel
  include ::Datadog::Core::Transport::Parcel
end

# @api private
#
# source://datadog//lib/datadog/di/transport/input.rb#14
class Datadog::DI::Transport::Input::Request < ::Datadog::Core::Transport::Request
  # @api private
  # @return [Request] a new instance of Request
  #
  # source://datadog//lib/datadog/di/transport/input.rb#17
  def initialize(parcel, serialized_tags); end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/input.rb#15
  def serialized_tags; end
end

# @api private
#
# source://datadog//lib/datadog/di/transport/input.rb#24
class Datadog::DI::Transport::Input::Transport
  # @api private
  # @return [Transport] a new instance of Transport
  #
  # source://datadog//lib/datadog/di/transport/input.rb#27
  def initialize(apis, default_api, logger:); end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/input.rb#25
  def apis; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/input.rb#25
  def client; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/input.rb#34
  def current_api; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/input.rb#25
  def current_api_id; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/input.rb#25
  def default_api; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/input.rb#25
  def logger; end

  # @api private
  #
  # source://datadog//lib/datadog/di/transport/input.rb#38
  def send_input(payload, tags); end
end

# @api private
#
# source://datadog//lib/datadog/di/utils.rb#8
module Datadog::DI::Utils
  private

  # Returns whether the provided +path+ matches the "probe path" in
  # +spec+. Attempts all of the fuzzy matches by stripping directories
  # from the front of +spec+. Does not consider othr known paths to
  # identify the case of (potentially) multiple matching paths for +spec+.
  #
  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/utils.rb#128
  def path_can_match_spec?(path, spec); end

  # Returns whether the provided +path+ matches the user-designated
  # file suffix (of a line probe).
  #
  # If suffix is an absolute path (i.e., it starts with a slash), the path
  # must be identical for it to match.
  #
  # If suffix is not an absolute path, the path matches if its suffix is
  # the provided suffix, at a path component boundary.
  #
  # @api private
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/di/utils.rb#93
  def path_matches_suffix?(path, suffix); end

  class << self
    # Returns whether the provided +path+ matches the "probe path" in
    # +spec+. Attempts all of the fuzzy matches by stripping directories
    # from the front of +spec+. Does not consider othr known paths to
    # identify the case of (potentially) multiple matching paths for +spec+.
    #
    # @api private
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/di/utils.rb#128
    def path_can_match_spec?(path, spec); end

    # Returns whether the provided +path+ matches the user-designated
    # file suffix (of a line probe).
    #
    # If suffix is an absolute path (i.e., it starts with a slash), the path
    # must be identical for it to match.
    #
    # If suffix is not an absolute path, the path matches if its suffix is
    # the provided suffix, at a path component boundary.
    #
    # @api private
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/di/utils.rb#93
    def path_matches_suffix?(path, suffix); end
  end
end

# Namespace for Datadog ErrorTracking.
#
# @api private
#
# source://datadog//lib/datadog/error_tracking/ext.rb#4
module Datadog::ErrorTracking; end

# The Collector is in charge, for a SpanOperation of storing the span events
# created when an error is handled. Each SpanOperation has a Collector as soon
# as a span event is created and the Collector has the same life time as the SpanOp.
#
# If an error is handled then rethrown, the SpanEvent corresponding to the error
# will be deleted. That is why we do not add directly the SpanEvent to the SpanOp.
#
# @api private
#
# source://datadog//lib/datadog/error_tracking/collector.rb#15
class Datadog::ErrorTracking::Collector
  # @api private
  # @return [Collector] a new instance of Collector
  #
  # source://datadog//lib/datadog/error_tracking/collector.rb#31
  def initialize; end

  # @api private
  #
  # source://datadog//lib/datadog/error_tracking/collector.rb#35
  def add_span_event(span_op, span_event, error); end

  # Up to ruby3.2, we are listening to :raise event. We need to ensure
  # that an error exiting the scope of a span is not handled in a parent span.
  # This function will propagate the span event to the parent span. If the
  # error is not handled in the parent span, it will be deleted by design.
  #
  # @api private
  #
  # source://datadog//lib/datadog/error_tracking/collector.rb#59
  def on_error(_span_op, error); end

  # @api private
  #
  # source://datadog//lib/datadog/error_tracking/collector.rb#82
  def span_events; end

  class << self
    # Proc called when the span_operation :after_stop event is published
    #
    # @api private
    #
    # source://datadog//lib/datadog/error_tracking/collector.rb#19
    def after_stop; end
  end
end

# @api private
#
# source://datadog//lib/datadog/error_tracking/collector.rb#17
Datadog::ErrorTracking::Collector::LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# @api private
#
# source://datadog//lib/datadog/error_tracking/collector.rb#16
Datadog::ErrorTracking::Collector::SPAN_EVENTS_LIMIT = T.let(T.unsafe(nil), Integer)

# Component for Error Tracking.
#
# Only one instance of the Component should ever be active.
#
# The component instance records every handled exceptions from the configured scopes
# (user, third_party packages, specified files or everything).
#
# source://datadog//lib/datadog/error_tracking/component.rb#15
class Datadog::ErrorTracking::Component
  # @return [Component] a new instance of Component
  #
  # source://datadog//lib/datadog/error_tracking/component.rb#48
  def initialize(tracer:, handled_errors:, handled_errors_include:); end

  # source://datadog//lib/datadog/error_tracking/component.rb#81
  def create_exc_tracker_trace_point(event); end

  # source://datadog//lib/datadog/error_tracking/component.rb#100
  def create_script_compiled_trace_point; end

  # Shuts down error tracker.
  #
  # Disables the TracePoints.
  #
  # source://datadog//lib/datadog/error_tracking/component.rb#141
  def shutdown!; end

  # Starts the TracePoints.
  #
  # Enables the script_compiled TracePoint if handled_errors_include is not empty.
  #
  # source://datadog//lib/datadog/error_tracking/component.rb#133
  def start; end

  private

  # source://datadog//lib/datadog/error_tracking/component.rb#162
  def add_instrumented_file(file_path); end

  # Generates a span event from the exception info.
  #
  # The event follows the otel semantics.
  # https://opentelemetry.io/docs/specs/otel/trace/exceptions/
  #
  # source://datadog//lib/datadog/error_tracking/component.rb#152
  def generate_span_event(exception); end

  class << self
    # source://datadog//lib/datadog/error_tracking/component.rb#19
    def build(settings, tracer, logger); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/error_tracking/component.rb#32
    def environment_supported?(logger); end
  end
end

# source://datadog//lib/datadog/error_tracking/component.rb#16
Datadog::ErrorTracking::Component::LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# Configuration for ErrorTracking
#
# source://datadog//lib/datadog/error_tracking/configuration.rb#6
module Datadog::ErrorTracking::Configuration; end

# Settings
#
# source://datadog//lib/datadog/error_tracking/configuration/settings.rb#9
module Datadog::ErrorTracking::Configuration::Settings
  class << self
    # source://datadog//lib/datadog/error_tracking/configuration/settings.rb#15
    def add_settings!(base); end

    # @private
    #
    # source://datadog//lib/datadog/error_tracking/configuration/settings.rb#10
    def extended(base); end
  end
end

# Error Tracking constants
#
# source://datadog//lib/datadog/error_tracking/ext.rb#6
module Datadog::ErrorTracking::Ext; end

# source://datadog//lib/datadog/error_tracking/ext.rb#12
Datadog::ErrorTracking::Ext::DEFAULT_HANDLED_ERRORS = T.let(T.unsafe(nil), T.untyped)

# source://datadog//lib/datadog/error_tracking/ext.rb#7
Datadog::ErrorTracking::Ext::ENV_HANDLED_ERRORS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/error_tracking/ext.rb#8
Datadog::ErrorTracking::Ext::ENV_HANDLED_ERRORS_INCLUDE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/error_tracking/ext.rb#9
Datadog::ErrorTracking::Ext::HANDLED_ERRORS_ALL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/error_tracking/ext.rb#11
Datadog::ErrorTracking::Ext::HANDLED_ERRORS_THIRD_PARTY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/error_tracking/ext.rb#10
Datadog::ErrorTracking::Ext::HANDLED_ERRORS_USER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/error_tracking/ext.rb#15
Datadog::ErrorTracking::Ext::RUBY_VERSION_WITH_RESCUE_EVENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/error_tracking/ext.rb#14
Datadog::ErrorTracking::Ext::SPAN_EVENTS_HAS_EXCEPTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/error_tracking/ext.rb#13
Datadog::ErrorTracking::Ext::VALID_HANDLED_ERRORS = T.let(T.unsafe(nil), Array)

# Extends Datadog tracing with ErrorTracking features
#
# source://datadog//lib/datadog/error_tracking/extensions.rb#9
module Datadog::ErrorTracking::Extensions
  class << self
    # Inject Error Tracking into global objects.
    #
    # source://datadog//lib/datadog/error_tracking/extensions.rb#11
    def activate!; end
  end
end

# Based on configuration, the TracePoint listening to :rescue or :raise
# may report more handled errors than we want to report. Therefore we need
# a function to filter the events. As the filter function both depends
# on configuration and is called numerous time, we generate it during
# during the initialization of the feature to have the best performance
# possible.
#
# @api private
#
# source://datadog//lib/datadog/error_tracking/filters.rb#13
module Datadog::ErrorTracking::Filters
  private

  # @api private
  #
  # source://datadog//lib/datadog/error_tracking/filters.rb#34
  def datadog_code?(file_path); end

  # @api private
  #
  # source://datadog//lib/datadog/error_tracking/filters.rb#43
  def file_included?(file_path, instrumented_files); end

  # Generate the proc used in the TracePoint
  #
  # @api private
  #
  # source://datadog//lib/datadog/error_tracking/filters.rb#48
  def generate_filter(to_instrument_scope, handled_errors_include = T.unsafe(nil)); end

  # @api private
  #
  # source://datadog//lib/datadog/error_tracking/filters.rb#16
  def get_gem_name(file_path); end

  # @api private
  #
  # source://datadog//lib/datadog/error_tracking/filters.rb#38
  def third_party_code?(file_path); end

  # @api private
  #
  # source://datadog//lib/datadog/error_tracking/filters.rb#30
  def user_code?(file_path); end

  class << self
    # @api private
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/error_tracking/filters.rb#34
    def datadog_code?(file_path); end

    # @api private
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/error_tracking/filters.rb#43
    def file_included?(file_path, instrumented_files); end

    # Generate the proc used in the TracePoint
    #
    # @api private
    #
    # source://datadog//lib/datadog/error_tracking/filters.rb#48
    def generate_filter(to_instrument_scope, handled_errors_include = T.unsafe(nil)); end

    # @api private
    #
    # source://datadog//lib/datadog/error_tracking/filters.rb#16
    def get_gem_name(file_path); end

    # @api private
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/error_tracking/filters.rb#38
    def third_party_code?(file_path); end

    # @api private
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/error_tracking/filters.rb#30
    def user_code?(file_path); end
  end
end

# Datadog::Kit holds public-facing APIs for higher level user-facing
# features, these features not belonging to a specific product. Contrary to
# Datadog::Core, Kit depends on products.
#
# source://datadog//lib/datadog/kit.rb#7
module Datadog::Kit; end

# Tracking identity via traces
#
# source://datadog//lib/datadog/kit/identity.rb#8
module Datadog::Kit::Identity
  class << self
    # Attach user information to the trace
    #
    #
    # @param email [String] Email of the authenticated user associated
    #   to the trace.
    # @param id [String] Mandatory. Username or client id extracted
    #   from the access token or Authorization header in the inbound request
    #   from outside the system.
    # @param name [String] User-friendly name. To be displayed in the
    #   UI if set.
    # @param others [Hash<Symbol, String>] Additional free-form
    #   user information to attach to the trace.
    # @param role [String] Actual/assumed role the client is making
    #   the request under extracted from token or application security
    #   context.
    # @param scope [String] Scopes or granted authorities the client
    #   currently possesses extracted from token or application security
    #   context. The value would come from the scope associated with an OAuth
    #   2.0 Access Token or an attribute value in a SAML 2.0 Assertion.
    # @param session_id [String] Session ID of the authenticated user.
    # @param span [SpanOperation] Span to attach data to. Defaults to
    #   active span on trace. Note that this should be a service entry span.
    #   When AppSec is enabled, the expected span and trace are automatically
    #   used as defaults.
    # @param trace [TraceOperation] Trace to attach data to. Defaults to
    #   active trace.
    # @raise [ArgumentError]
    #
    # source://datadog//lib/datadog/kit/identity.rb#39
    def set_user(trace = T.unsafe(nil), span = T.unsafe(nil), id:, email: T.unsafe(nil), name: T.unsafe(nil), session_id: T.unsafe(nil), role: T.unsafe(nil), scope: T.unsafe(nil), **others); end

    private

    # @raise [ArgumentError]
    # @yield [trace, span]
    #
    # source://datadog//lib/datadog/kit/identity.rb#87
    def set_trace_and_span_context(method, trace = T.unsafe(nil), span = T.unsafe(nil)); end
  end
end

# Datadog Continuous Profiler implementation: https://docs.datadoghq.com/profiler/
#
# source://datadog//lib/datadog/profiling/ext.rb#4
module Datadog::Profiling
  class << self
    # Returns an ever-increasing counter of the number of allocations observed by the profiler in this thread.
    #
    # Note 1: This counter may not start from zero on new threads. It should only be used to measure how many
    # allocations have happened between two calls to this API:
    # ```
    # allocations_before = Datadog::Profiling.allocation_count
    # do_some_work()
    # allocations_after = Datadog::Profiling.allocation_count
    # puts "Allocations during do_some_work: #{allocations_after - allocations_before}"
    # ```
    # (This is similar to some OS-based time representations.)
    #
    # Note 2: All fibers in the same thread will share the same counter values.
    # Note 3: This counter is not accurate when using the M:N scheduler.
    #
    # Only available when the profiler is running, and allocation-related features are not disabled via configuration.
    #
    # @return [Integer] number of allocations observed in the current thread.
    # @return [nil] when not available.
    #
    # source://datadog//lib/datadog/profiling.rb#57
    def allocation_count; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling.rb#63
    def enabled?; end

    # Starts the profiler, if the profiler is supported by in
    # this runtime environment and if the profiler has been enabled
    # in configuration.
    #
    # @return [Boolean] `true` if the profiler has successfully started, otherwise `false`.
    #
    # source://datadog//lib/datadog/profiling.rb#27
    def start_if_enabled; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling.rb#10
    def supported?; end

    # source://datadog//lib/datadog/profiling.rb#14
    def unsupported_reason; end

    # source://datadog//lib/datadog/profiling.rb#69
    def wait_until_running(timeout_seconds: T.unsafe(nil)); end

    private

    # All requires for the profiler should be directly added here; and everything should be loaded eagerly.
    # (Currently there's a leftovers that need to be cleaned up, but we should avoid other exceptions.)
    #
    # All of the profiler should be loaded and ready to go when this method returns `true`.
    #
    # source://datadog//lib/datadog/profiling.rb#137
    def load_profiling; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling.rb#89
    def native_library_compilation_skipped?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling.rb#109
    def native_library_failed_to_load?; end

    # source://datadog//lib/datadog/profiling.rb#80
    def replace_noop_allocation_count; end

    # source://datadog//lib/datadog/profiling.rb#123
    def try_loading_native_library; end

    # source://datadog//lib/datadog/profiling.rb#95
    def try_reading_skipped_reason_file(file_api = T.unsafe(nil)); end
  end
end

# source://datadog//lib/datadog/profiling/collectors/info.rb#9
module Datadog::Profiling::Collectors; end

# Collects library metadata for loaded files ($LOADED_FEATURES) in the Ruby VM.
# The output of this class is a list of libraries which have been require'd (in particular, this is
# not a list of ALL installed libraries).
#
# This metadata powers grouping and categorization of stack trace data.
#
# This class acts both as a collector (collecting data) as well as a recorder (records/serializes it)
#
# source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#16
class Datadog::Profiling::Collectors::CodeProvenance
  # @return [CodeProvenance] a new instance of CodeProvenance
  #
  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#17
  def initialize(standard_library_path: T.unsafe(nil), ruby_native_filename: T.unsafe(nil)); end

  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#44
  def generate_json; end

  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#37
  def refresh(loaded_files: T.unsafe(nil), loaded_specs: T.unsafe(nil)); end

  private

  # Returns the value of attribute libraries_by_name.
  #
  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#50
  def libraries_by_name; end

  # Returns the value of attribute libraries_by_path.
  #
  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#50
  def libraries_by_path; end

  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#56
  def record_library(library); end

  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#97
  def record_loaded_files(loaded_files); end

  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#76
  def record_loaded_specs(loaded_specs); end

  # Returns the value of attribute seen_files.
  #
  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#50
  def seen_files; end

  # Returns the value of attribute seen_libraries.
  #
  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#50
  def seen_libraries; end

  # Ruby hash maps are guaranteed to keep the insertion order of keys. Here, we sort @libraries_by_path so
  # that the hash can be iterated in reverse order of paths.
  #
  # Why we do this: We do this to make sure that if there are libraries with paths that are prefixes of other
  # libraries, e.g. '/home/foo' and '/home/foo/bar', we match to the longest path first.
  # When reverse sorting paths as strings, '/home/foo/bar' will come before '/home/foo'.
  #
  # This way, when we iterate the @libraries_by_path hash, we know the first hit will also be the longest.
  #
  # Alternatively/in the future we could instead use a trie to match paths, but I doubt for the data sizes we're
  # looking at that a trie is that much faster than using Ruby's built-in native collections.
  #
  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#72
  def sort_libraries_by_longest_path_first; end
end

# Represents metadata we have for a ruby gem
#
# Important note: This class gets encoded to JSON with the built-in JSON gem. But, we've found that in some
# buggy cases, some Ruby gems monkey patch the built-in JSON gem and forget to call #to_json, and instead
# encode this class instance-field-by-instance-field.
#
# Thus, this class was setup to match the JSON output. Take this into consideration if you are adding new
# fields. (Also, we have a spec for this)
#
# source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#118
class Datadog::Profiling::Collectors::CodeProvenance::Library
  # @return [Library] a new instance of Library
  #
  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#121
  def initialize(kind:, name:, version:, path:, extra_path: T.unsafe(nil)); end

  # Returns the value of attribute kind.
  #
  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#119
  def kind; end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#119
  def name; end

  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#134
  def path; end

  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#130
  def to_json(arg = T.unsafe(nil)); end

  # Returns the value of attribute version.
  #
  # source://datadog//lib/datadog/profiling/collectors/code_provenance.rb#119
  def version; end
end

# Used to trigger the periodic execution of Collectors::ThreadState, which implements all of the sampling logic
# itself; this class only implements the "when to do it" part.
# Almost all of this class is implemented as native code.
#
# Methods prefixed with _native_ are implemented in `collectors_cpu_and_wall_time_worker.c`
#
# source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#11
class Datadog::Profiling::Collectors::CpuAndWallTimeWorker
  # @return [CpuAndWallTimeWorker] a new instance of CpuAndWallTimeWorker
  #
  # source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#18
  def initialize(gc_profiling_enabled:, no_signals_workaround_enabled:, thread_context_collector:, dynamic_sampling_rate_overhead_target_percentage:, allocation_profiling_enabled:, allocation_counting_enabled:, gvl_profiling_enabled:, sighandler_sampling_enabled:, dynamic_sampling_rate_enabled: T.unsafe(nil), skip_idle_samples_for_testing: T.unsafe(nil), idle_sampling_helper: T.unsafe(nil)); end

  # source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#110
  def reset_after_fork; end

  # source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#64
  def start(on_failure_proc: T.unsafe(nil)); end

  # source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#114
  def stats; end

  # source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#118
  def stats_and_reset_not_thread_safe; end

  # source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#94
  def stop; end

  # Useful for testing, to e.g. make sure the profiler is running before we start running some code we want to observe
  #
  # source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#125
  def wait_until_running(timeout_seconds: T.unsafe(nil)); end

  private

  # Returns the value of attribute failure_exception.
  #
  # source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#14
  def failure_exception; end

  # Sets the attribute failure_exception
  #
  # @param value the value to set the attribute failure_exception to.
  #
  # source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#14
  def failure_exception=(_arg0); end

  # source://datadog//lib/datadog/profiling/collectors/cpu_and_wall_time_worker.rb#141
  def signal_running; end

  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_allocation_count; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_hold_signals; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_initialize(*_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_is_running?(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_reset_after_fork(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_resume_signals; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_sampling_loop(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_stats(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_stats_reset_not_thread_safe(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_stop(_arg0, _arg1); end
  end
end

module Datadog::Profiling::Collectors::CpuAndWallTimeWorker::Testing
  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_current_sigprof_signal_handler; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_delayed_error(_arg0, _arg1); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_gc_tracepoint(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_gvl_profiling_hook_active(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_install_testing_signal_handler; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_is_sigprof_blocked_in_current_thread; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_remove_testing_signal_handler; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_simulate_handle_sampling_signal; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_simulate_sample_from_postponed_job; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_trigger_sample; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_with_blocked_sigprof; end
  end
end

module Datadog::Profiling::Collectors::DiscreteDynamicSampler; end
module Datadog::Profiling::Collectors::DiscreteDynamicSampler::Testing; end

class Datadog::Profiling::Collectors::DiscreteDynamicSampler::Testing::Sampler
  # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
  def initialize(_arg0); end

  # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
  def _native_after_sample(_arg0); end

  # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
  def _native_reset(_arg0); end

  # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
  def _native_set_overhead_target_percentage(_arg0, _arg1); end

  # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
  def _native_should_sample(_arg0); end

  # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
  def _native_state_snapshot; end
end

# Used to pace the rate of profiling samples based on the last observed time for a sample.
# All of this module is implemented as native code.
#
# Methods prefixed with _native_ are implemented in `collectors_dynamic_sampling_rate.c`
#
# source://datadog//lib/datadog/profiling/collectors/dynamic_sampling_rate.rb#10
module Datadog::Profiling::Collectors::DynamicSamplingRate; end

module Datadog::Profiling::Collectors::DynamicSamplingRate::Testing
  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_after_sample(_arg0, _arg1, _arg2); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_get_sleep(_arg0, _arg1, _arg2); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_should_sample(_arg0, _arg1, _arg2); end
  end
end

# Used by the Collectors::CpuAndWallTimeWorker to gather samples when the Ruby process is idle.
# Almost all of this class is implemented as native code.
#
# Methods prefixed with _native_ are implemented in `collectors_idle_sampling_helper.c`
#
# source://datadog//lib/datadog/profiling/collectors/idle_sampling_helper.rb#10
class Datadog::Profiling::Collectors::IdleSamplingHelper
  # @return [IdleSamplingHelper] a new instance of IdleSamplingHelper
  #
  # source://datadog//lib/datadog/profiling/collectors/idle_sampling_helper.rb#17
  def initialize; end

  # source://datadog//lib/datadog/profiling/collectors/idle_sampling_helper.rb#22
  def start; end

  # source://datadog//lib/datadog/profiling/collectors/idle_sampling_helper.rb#53
  def stop; end

  private

  # Returns the value of attribute failure_exception.
  #
  # source://datadog//lib/datadog/profiling/collectors/idle_sampling_helper.rb#13
  def failure_exception; end

  # Sets the attribute failure_exception
  #
  # @param value the value to set the attribute failure_exception to.
  #
  # source://datadog//lib/datadog/profiling/collectors/idle_sampling_helper.rb#13
  def failure_exception=(_arg0); end

  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_idle_sampling_loop(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_reset(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_stop(_arg0); end
  end
end

module Datadog::Profiling::Collectors::IdleSamplingHelper::Testing
  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_idle_sampling_helper_request_action(_arg0); end
  end
end

# Collects information of relevance for profiler. This will get sent alongside
# the profile and show up in the UI or potentially influence processing in some way.
#
# Information is currently collected and frozen at construction time. A full collector
# could be seen as overkill for this case but it allows us to centralize information
# gathering and easily support more flexible/dynamic info collection in the future.
#
# source://datadog//lib/datadog/profiling/collectors/info.rb#16
class Datadog::Profiling::Collectors::Info
  # @return [Info] a new instance of Info
  #
  # source://datadog//lib/datadog/profiling/collectors/info.rb#17
  def initialize(settings); end

  # Returns the value of attribute info.
  #
  # source://datadog//lib/datadog/profiling/collectors/info.rb#27
  def info; end

  private

  # source://datadog//lib/datadog/profiling/collectors/info.rb#89
  def collect_application_info(settings); end

  # source://datadog//lib/datadog/profiling/collectors/info.rb#145
  def collect_gc_tuning_info; end

  # source://datadog//lib/datadog/profiling/collectors/info.rb#70
  def collect_platform_info; end

  # source://datadog//lib/datadog/profiling/collectors/info.rb#98
  def collect_profiler_info(settings); end

  # source://datadog//lib/datadog/profiling/collectors/info.rb#80
  def collect_runtime_info; end

  # The settings/option model isn't directly serializable because
  # of subsettings and options that link to full blown custom object
  # instances without proper serialization.
  # This method navigates a settings object recursively, converting
  # it into more basic types that are trivially convertible to JSON.
  #
  # source://datadog//lib/datadog/profiling/collectors/info.rb#125
  def collect_settings_recursively(v); end
end

# Ruby GC tuning environment variables
#
# source://datadog//lib/datadog/profiling/collectors/info.rb#32
Datadog::Profiling::Collectors::Info::RUBY_GC_TUNING_ENV_VARS = T.let(T.unsafe(nil), Array)

# Instead of trying to figure out real process start time by checking
# /proc or some other complex/non-portable way, approximate start time
# by time of requirement of this file.
#
# Note: this does not use Core::Utils::Time.now because this constant
# gets initialized before a user has a chance to configure the library.
#
# source://datadog//lib/datadog/profiling/collectors/info.rb#68
Datadog::Profiling::Collectors::Info::START_TIME = T.let(T.unsafe(nil), Time)

# Used to gather a stack trace from a given Ruby thread. Stores its output on a `StackRecorder`.
#
# This class is not empty; all of this class is implemented as native code.
#
# source://datadog//lib/datadog/profiling/collectors/stack.rb#9
class Datadog::Profiling::Collectors::Stack
  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_filenames_available?; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_ruby_native_filename; end
  end
end

module Datadog::Profiling::Collectors::Stack::Testing
  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_sample(*_arg0); end
  end
end

# Used to trigger sampling of threads, based on external "events", such as:
# * periodic timer for cpu-time and wall-time
# * VM garbage collection events
# * VM object allocation events
# Triggering of this component (e.g. watching for the above "events") is implemented by
# Collectors::CpuAndWallTimeWorker.
# The stack collection itself is handled using the Datadog::Profiling::Collectors::Stack.
# Almost all of this class is implemented as native code.
#
# Methods prefixed with _native_ are implemented in `collectors_thread_context.c`
#
# source://datadog//lib/datadog/profiling/collectors/thread_context.rb#16
class Datadog::Profiling::Collectors::ThreadContext
  # @return [ThreadContext] a new instance of ThreadContext
  #
  # source://datadog//lib/datadog/profiling/collectors/thread_context.rb#17
  def initialize(recorder:, max_frames:, tracer:, endpoint_collection_enabled:, timeline_enabled:, waiting_for_gvl_threshold_ns:, otel_context_enabled:, native_filenames_enabled:); end

  # source://datadog//lib/datadog/profiling/collectors/thread_context.rb#65
  def inspect; end

  # source://datadog//lib/datadog/profiling/collectors/thread_context.rb#72
  def reset_after_fork; end

  private

  # source://datadog//lib/datadog/profiling/collectors/thread_context.rb#78
  def safely_extract_context_key_from(tracer); end

  # source://datadog//lib/datadog/profiling/collectors/thread_context.rb#89
  def validate_native_filenames(native_filenames_enabled); end

  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_initialize(*_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_inspect(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_reset_after_fork(_arg0); end

    # source://datadog//lib/datadog/profiling/collectors/thread_context.rb#41
    def for_testing(recorder:, max_frames: T.unsafe(nil), tracer: T.unsafe(nil), endpoint_collection_enabled: T.unsafe(nil), timeline_enabled: T.unsafe(nil), waiting_for_gvl_threshold_ns: T.unsafe(nil), otel_context_enabled: T.unsafe(nil), native_filenames_enabled: T.unsafe(nil), **options); end
  end
end

module Datadog::Profiling::Collectors::ThreadContext::Testing
  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_apply_delta_to_cpu_time_at_previous_sample_ns(_arg0, _arg1, _arg2); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_gc_tracking(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_gvl_waiting_at_for(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_new_empty_thread; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_on_gc_finish(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_on_gc_start(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_on_gvl_running(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_on_gvl_waiting(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_per_thread_context(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_prepare_sample_inside_signal_handler(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_sample(_arg0, _arg1, _arg2); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_sample_after_gc(_arg0, _arg1); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_sample_after_gvl_running(_arg0, _arg1); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_sample_allocation(_arg0, _arg1, _arg2); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_sample_skipped_allocation_samples(_arg0, _arg1); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_stats(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_system_epoch_time_now_ns(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_thread_list; end
  end
end

# Responsible for wiring up the Profiler for execution
#
# source://datadog//lib/datadog/profiling/component.rb#6
module Datadog::Profiling::Component
  class << self
    # Passing in a `nil` tracer is supported and will disable the following profiling features:
    # * Profiling in the trace viewer, as well as scoping a profile down to a span
    # * Endpoint aggregation in the profiler UX, including normalization (resource per endpoint call)
    #
    # source://datadog//lib/datadog/profiling/component.rb#13
    def build_profiler_component(settings:, agent_settings:, optional_tracer:, logger:); end

    private

    # source://datadog//lib/datadog/profiling/component.rb#104
    def build_profiler_exporter(settings, recorder, worker, internal_metadata:); end

    # source://datadog//lib/datadog/profiling/component.rb#118
    def build_profiler_transport(settings, agent_settings); end

    # source://datadog//lib/datadog/profiling/component.rb#91
    def build_thread_context_collector(settings, recorder, optional_tracer, timeline_enabled); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/component.rb#430
    def dir_interruption_workaround_enabled?(settings, no_signals_workaround_enabled); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/component.rb#163
    def enable_allocation_profiling?(settings, logger); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/component.rb#128
    def enable_gc_profiling?(settings, logger); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/component.rb#436
    def enable_gvl_profiling?(settings, logger); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/component.rb#212
    def enable_heap_profiling?(settings, allocation_profiling_enabled, heap_sample_rate, logger); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/component.rb#238
    def enable_heap_size_profiling?(settings, heap_profiling_enabled, logger); end

    # @raise [ArgumentError]
    #
    # source://datadog//lib/datadog/profiling/component.rb#155
    def get_heap_sample_every(settings); end

    # Versions of libmysqlclient prior to 8.0.0 are known to have buggy handling of system call interruptions.
    # The profiler can sometimes cause system call interruptions, and so this combination can cause queries to fail.
    #
    # See https://bugs.mysql.com/bug.php?id=83109 and
    # https://docs.datadoghq.com/profiler/profiler_troubleshooting/ruby/#unexpected-run-time-failures-and-errors-from-ruby-gems-that-use-native-extensions-in-dd-trace-rb-1110
    # for details.
    #
    # The `mysql2` gem's `info` method can be used to determine which `libmysqlclient` version is in use, and thus to
    # detect if it's safe for the profiler to use signals or if we need to employ a fallback.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/component.rb#327
    def incompatible_libmysqlclient_version?(settings, logger); end

    # See https://github.com/datadog/dd-trace-rb/issues/2976 for details.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/component.rb#376
    def incompatible_passenger_version?; end

    # To add just a bit more complexity to our detection code, in https://github.com/DataDog/dd-trace-rb/issues/3334
    # a user reported that our code was incorrectly flagging the mariadb variant of libmysqlclient as being
    # incompatible. In fact we have no reports of the mariadb variant needing the "no signals" workaround,
    # so we flag it as compatible when it's in use.
    #
    # A problem is that there doesn't seem to be an obvious way to query the mysql2 gem on which kind of
    # libmysqlclient it's using, so we detect it by looking at the version.
    #
    # The info method for mysql2 with mariadb looks something like this:
    # `{:id=>30308, :version=>"3.3.8", :header_version=>"11.2.2"}`
    #
    # * The version seems to come from https://github.com/mariadb-corporation/mariadb-connector-c and the latest
    # one is 3.x.
    # * The header_version is what people usually see as the "mariadb version"
    #
    # As a comparison, for libmysql the info looks like:
    # * `{:id=>80035, :version=>"8.0.35", :header_version=>"8.0.35"}`
    #
    # Thus our detection is version 4 or older, because libmysqlclient 4 is almost 20 years old so it's most probably
    # not that one + header_version being 10 or newer, since according to https://endoflife.date/mariadb that's a
    # sane range for modern mariadb releases.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/component.rb#422
    def looks_like_mariadb?(info, libmysqlclient_version); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/component.rb#246
    def no_signals_workaround_enabled?(settings, logger); end

    # source://datadog//lib/datadog/profiling/component.rb#388
    def valid_overhead_target(overhead_target_percentage, logger); end
  end
end

# source://datadog//lib/datadog/profiling/component.rb#7
Datadog::Profiling::Component::ALLOCATION_WITH_RACTORS_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# This class exists to wrap a ddog_prof_EncodedProfile into a Ruby object
#
# This class is not empty; all of this class is implemented as native code.
#
# source://datadog//lib/datadog/profiling/encoded_profile.rb#8
class Datadog::Profiling::EncodedProfile
  # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
  def _native_bytes; end
end

# Exports profiling data gathered by the multiple recorders in a `Flush`.
#
# @ivoanjo: Note that the recorder that gathers pprof data is special, since we use its start/finish/empty? to
# decide if there's data to flush, as well as the timestamp for that data.
# I could've made the whole design more generic, but I'm unsure if we'll ever have more than a handful of
# recorders, so I've decided to make it specific until we actually need to support more recorders.
#
# source://datadog//lib/datadog/profiling/exporter.rb#15
class Datadog::Profiling::Exporter
  # @return [Exporter] a new instance of Exporter
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#34
  def initialize(pprof_recorder:, worker:, info_collector:, code_provenance_collector:, internal_metadata:, minimum_duration_seconds: T.unsafe(nil), time_provider: T.unsafe(nil), sequence_tracker: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#95
  def can_flush?; end

  # source://datadog//lib/datadog/profiling/exporter.rb#58
  def flush; end

  # source://datadog//lib/datadog/profiling/exporter.rb#99
  def reset_after_fork; end

  private

  # Returns the value of attribute code_provenance_collector.
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#21
  def code_provenance_collector; end

  # Returns the value of attribute created_at.
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#21
  def created_at; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#106
  def duration_below_threshold?(start, finish); end

  # Returns the value of attribute info_json.
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#21
  def info_json; end

  # Returns the value of attribute internal_metadata.
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#21
  def internal_metadata; end

  # Returns the value of attribute last_flush_finish_at.
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#21
  def last_flush_finish_at; end

  # Returns the value of attribute minimum_duration_seconds.
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#21
  def minimum_duration_seconds; end

  # Returns the value of attribute pprof_recorder.
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#21
  def pprof_recorder; end

  # Returns the value of attribute sequence_tracker.
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#21
  def sequence_tracker; end

  # Returns the value of attribute time_provider.
  #
  # source://datadog//lib/datadog/profiling/exporter.rb#21
  def time_provider; end
end

# Profiles with duration less than this will not be reported
#
# source://datadog//lib/datadog/profiling/exporter.rb#17
Datadog::Profiling::Exporter::PROFILE_DURATION_THRESHOLD_SECONDS = T.let(T.unsafe(nil), Integer)

# Monkey patches needed for profiler features and compatibility
#
# source://datadog//lib/datadog/profiling/ext.rb#5
module Datadog::Profiling::Ext; end

# Monkey patches for Dir.singleton_class (Ruby 3 version). See DirMonkeyPatches above for more details.
#
# source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#150
module Datadog::Profiling::Ext::DirClassMonkeyPatches
  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#151
  def [](*args, **kwargs, &block); end

  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#158
  def children(*args, **kwargs, &block); end

  # See note on methods that yield above.
  #
  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#166
  def each_child(*args, **kwargs, &block); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#189
  def empty?(*args, **kwargs, &block); end

  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#196
  def entries(*args, **kwargs, &block); end

  # See note on methods that yield above.
  #
  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#204
  def foreach(*args, **kwargs, &block); end

  # See note on methods that yield above.
  #
  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#228
  def glob(*args, **kwargs, &block); end

  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#254
  def home(*args, **kwargs, &block); end
end

# Monkey patches for Dir (Ruby 3 version). See DirMonkeyPatches above for more details.
#
# source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#338
module Datadog::Profiling::Ext::DirInstanceMonkeyPatches
  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#386
  def children(*args, **kwargs, &block); end

  # See note on methods that yield above.
  #
  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#340
  def each(*args, **kwargs, &block); end

  # See note on methods that yield above.
  #
  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#363
  def each_child(*args, **kwargs, &block); end

  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#400
  def pos(*args, **kwargs, &block); end

  # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#393
  def tell(*args, **kwargs, &block); end
end

# All Ruby versions as of this writing have bugs in the dir class implementation, causing issues such as
# https://github.com/DataDog/dd-trace-rb/issues/3450 .
# See also https://bugs.ruby-lang.org/issues/20586 for more details.
#
# This monkey patch for the Ruby `Dir` class works around these bugs for affected Ruby versions by temporarily
# blocking the profiler from interrupting system calls.
#
# A lot of these APIs do very similar things -- they're provided by Ruby as helpers so users don't need to keep
# reimplementing them but share the same underlying buggy code. And so our monkey patches are a bit repetitive
# as well.
# We don't DRY out this file to have minimal overhead.
#
# These monkey patches are applied by the profiler when the "dir_interruption_workaround_enabled" setting is
# enabled. See the profiling settings for more detail.
#
# source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#21
module Datadog::Profiling::Ext::DirMonkeyPatches
  class << self
    # source://datadog//lib/datadog/profiling/ext/dir_monkey_patches.rb#22
    def apply!; end
  end
end

# WARNING: This should not be used, only for internal testing
#
# source://datadog//lib/datadog/profiling/ext.rb#12
Datadog::Profiling::Ext::ENV_AGENTLESS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/profiling/ext.rb#6
Datadog::Profiling::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/profiling/ext.rb#9
Datadog::Profiling::Ext::ENV_ENDPOINT_COLLECTION_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/profiling/ext.rb#8
Datadog::Profiling::Ext::ENV_MAX_FRAMES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/profiling/ext.rb#7
Datadog::Profiling::Ext::ENV_UPLOAD_TIMEOUT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/profiling/ext.rb#13
module Datadog::Profiling::Ext::Transport; end

# source://datadog//lib/datadog/profiling/ext.rb#14
module Datadog::Profiling::Ext::Transport::HTTP; end

# source://datadog//lib/datadog/profiling/ext.rb#17
Datadog::Profiling::Ext::Transport::HTTP::CODE_PROVENANCE_FILENAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/profiling/ext.rb#15
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_PROFILER_VERSION = T.let(T.unsafe(nil), String)

# Entity class used to represent metadata for a given profile
#
# source://datadog//lib/datadog/profiling/flush.rb#8
class Datadog::Profiling::Flush
  # @return [Flush] a new instance of Flush
  #
  # source://datadog//lib/datadog/profiling/flush.rb#19
  def initialize(start:, finish:, encoded_profile:, code_provenance_file_name:, code_provenance_data:, tags_as_array:, internal_metadata:, info_json:); end

  # Returns the value of attribute code_provenance_data.
  #
  # source://datadog//lib/datadog/profiling/flush.rb#9
  def code_provenance_data; end

  # Returns the value of attribute code_provenance_file_name.
  #
  # source://datadog//lib/datadog/profiling/flush.rb#9
  def code_provenance_file_name; end

  # Returns the value of attribute encoded_profile.
  #
  # source://datadog//lib/datadog/profiling/flush.rb#9
  def encoded_profile; end

  # Returns the value of attribute finish.
  #
  # source://datadog//lib/datadog/profiling/flush.rb#9
  def finish; end

  # Returns the value of attribute info_json.
  #
  # source://datadog//lib/datadog/profiling/flush.rb#9
  def info_json; end

  # Returns the value of attribute internal_metadata_json.
  #
  # source://datadog//lib/datadog/profiling/flush.rb#9
  def internal_metadata_json; end

  # Returns the value of attribute start.
  #
  # source://datadog//lib/datadog/profiling/flush.rb#9
  def start; end

  # Returns the value of attribute tags_as_array.
  #
  # source://datadog//lib/datadog/profiling/flush.rb#9
  def tags_as_array; end
end

# Used to report profiling data to Datadog.
# Methods prefixed with _native_ are implemented in `http_transport.c`
#
# source://datadog//lib/datadog/profiling/http_transport.rb#10
class Datadog::Profiling::HttpTransport
  # @raise [ArgumentError]
  # @return [HttpTransport] a new instance of HttpTransport
  #
  # source://datadog//lib/datadog/profiling/http_transport.rb#13
  def initialize(agent_settings:, site:, api_key:, upload_timeout_seconds:); end

  # source://datadog//lib/datadog/profiling/http_transport.rb#28
  def export(flush); end

  # Returns the value of attribute exporter_configuration.
  #
  # source://datadog//lib/datadog/profiling/http_transport.rb#11
  def exporter_configuration; end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/profiling/http_transport.rb#58
  def agentless?(site, api_key); end

  # source://datadog//lib/datadog/profiling/http_transport.rb#62
  def config_without_api_key; end

  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_do_export(_arg0, _arg1, _arg2); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_validate_exporter(_arg0); end
  end
end

# This module contains classes and methods which are implemented using native code in the
# ext/datadog_profiling_native_extension folder, as well as some Ruby-level utilities that don't make sense to
# write using C
#
# source://datadog//lib/datadog/profiling/native_extension.rb#8
module Datadog::Profiling::NativeExtension
  class << self
    private

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def native_working?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/profiling/native_extension.rb#9
    def working?; end
  end
end

module Datadog::Profiling::NativeExtension::Testing
  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_ddtrace_rb_ractor_main_p; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_enforce_success(_arg0, _arg1); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_grab_gvl_and_raise(_arg0, _arg1, _arg2, _arg3); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_grab_gvl_and_raise_syserr(_arg0, _arg1, _arg2, _arg3); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_install_holding_the_gvl_signal_handler; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_is_current_thread_holding_the_gvl; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_malloc_stats; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_release_gvl_and_call_is_current_thread_holding_the_gvl; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_safe_object_info(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_trigger_holding_the_gvl_signal_handler_on(_arg0); end
  end
end

# Profiling entry point, which coordinates the worker and scheduler threads
#
# source://datadog//lib/datadog/profiling/profiler.rb#6
class Datadog::Profiling::Profiler
  include ::Datadog::Core::Utils::Forking::ClassExtensions
  include ::Datadog::Core::Utils::Forking

  # @return [Profiler] a new instance of Profiler
  #
  # source://datadog//lib/datadog/profiling/profiler.rb#15
  def initialize(*args, **kwargs, &block); end

  # source://datadog//lib/datadog/profiling/profiler.rb#30
  def shutdown!; end

  # source://datadog//lib/datadog/profiling/profiler.rb#20
  def start; end

  private

  # source://datadog//lib/datadog/profiling/profiler.rb#48
  def component_failed(failed_component); end

  # Returns the value of attribute scheduler.
  #
  # source://datadog//lib/datadog/profiling/profiler.rb#11
  def scheduler; end

  # source://datadog//lib/datadog/profiling/profiler.rb#43
  def stop_scheduler; end

  # source://datadog//lib/datadog/profiling/profiler.rb#39
  def stop_worker; end

  # Returns the value of attribute worker.
  #
  # source://datadog//lib/datadog/profiling/profiler.rb#11
  def worker; end
end

# Periodically (every interval, 60 seconds by default) takes a profile from the `Exporter` and reports it using the
# configured transport. Runs on its own background thread.
#
# source://datadog//lib/datadog/profiling/scheduler.rb#13
class Datadog::Profiling::Scheduler < ::Datadog::Core::Worker
  include ::Datadog::Core::Workers::IntervalLoop::PrependedMethods
  include ::Datadog::Core::Workers::Async::Thread::PrependedMethods
  include ::Datadog::Core::Workers::Polling::PrependedMethods
  include ::Datadog::Core::Workers::Polling
  include ::Datadog::Core::Workers::IntervalLoop
  include ::Datadog::Core::Workers::Async::Thread

  # @return [Scheduler] a new instance of Scheduler
  #
  # source://datadog//lib/datadog/profiling/scheduler.rb#31
  def initialize(exporter:, transport:, interval:, fork_policy: T.unsafe(nil), enabled: T.unsafe(nil)); end

  # Configure Workers::IntervalLoop to not report immediately when scheduler starts
  #
  # When a scheduler gets created (or reset), we don't want it to immediately try to flush; we want it to wait for
  # the loop wait time first. This avoids an issue where the scheduler reported a mostly-empty profile if the
  # application just started but this thread took a bit longer so there's already profiling data in the exporter.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/profiling/scheduler.rb#82
  def loop_wait_before_first_iteration?; end

  # This is called by the Profiler class whenever an issue happened in the profiler. This makes sure that even
  # if there is data to be flushed, we don't try to flush it.
  #
  # source://datadog//lib/datadog/profiling/scheduler.rb#88
  def mark_profiler_failed; end

  # source://datadog//lib/datadog/profiling/scheduler.rb#56
  def perform(*args); end

  # source://datadog//lib/datadog/profiling/scheduler.rb#96
  def reset_after_fork; end

  # source://datadog//lib/datadog/profiling/scheduler.rb#52
  def start(on_failure_proc: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/profiling/scheduler.rb#92
  def work_pending?; end

  private

  # Returns the value of attribute exporter.
  #
  # source://datadog//lib/datadog/profiling/scheduler.rb#24
  def exporter; end

  # source://datadog//lib/datadog/profiling/scheduler.rb#102
  def flush_and_wait; end

  # source://datadog//lib/datadog/profiling/scheduler.rb#112
  def flush_events; end

  # Returns the value of attribute profiler_failed.
  #
  # source://datadog//lib/datadog/profiling/scheduler.rb#24
  def profiler_failed; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/profiling/scheduler.rb#148
  def stop_requested?; end

  # Returns the value of attribute transport.
  #
  # source://datadog//lib/datadog/profiling/scheduler.rb#24
  def transport; end
end

# We sleep for at most this duration seconds before reporting data to avoid multi-process applications all
# reporting profiles at the exact same time
#
# source://datadog//lib/datadog/profiling/scheduler.rb#20
Datadog::Profiling::Scheduler::DEFAULT_FLUSH_JITTER_MAXIMUM_SECONDS = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/profiling/scheduler.rb#16
Datadog::Profiling::Scheduler::MINIMUM_INTERVAL_SECONDS = T.let(T.unsafe(nil), Integer)

# Used to generate the `profile_seq` tag, which effectively counts how many profiles we've attempted to report
# from a given runtime-id.
#
# Note that the above implies a few things:
# 1. The sequence number only gets incremented when we decide to report a profile and create a `Flush` for it
# 2. The `SequenceTracker` must live across profiler reconfigurations and resets, since no matter how many
#    profiler instances get created due to reconfiguration, the runtime-id is still the same, so the sequence number
#    should be kept and not restarted from 0
# 3. The `SequenceTracker` must be reset after a fork, since the runtime-id will change, and we want to start
#    counting from 0 again
#
# This is why this module is implemented as a singleton that we reuse, not as an instance that we recreate.
#
# Note that this module is not thread-safe, so it's up to the callers to make sure
# it's only used by a single thread at a time (which is what the `Profiling::Exporter`)
# is doing.
#
# source://datadog//lib/datadog/profiling/sequence_tracker.rb#23
module Datadog::Profiling::SequenceTracker
  extend ::Datadog::Core::Utils::Forking
  extend ::Datadog::Core::Utils::Forking::ClassExtensions

  class << self
    # source://datadog//lib/datadog/profiling/sequence_tracker.rb#27
    def get_next; end

    private

    # source://datadog//lib/datadog/profiling/sequence_tracker.rb#38
    def reset!; end
  end
end

# Stores stack samples in a native libdatadog data structure and expose Ruby-level serialization APIs
# Note that `record_sample` is only accessible from native code.
# Methods prefixed with _native_ are implemented in `stack_recorder.c`
#
# source://datadog//lib/datadog/profiling/stack_recorder.rb#10
class Datadog::Profiling::StackRecorder
  # @return [StackRecorder] a new instance of StackRecorder
  #
  # source://datadog//lib/datadog/profiling/stack_recorder.rb#11
  def initialize(cpu_time_enabled:, alloc_samples_enabled:, heap_samples_enabled:, heap_size_enabled:, heap_sample_every:, timeline_enabled:, heap_clean_after_gc_enabled:); end

  # source://datadog//lib/datadog/profiling/stack_recorder.rb#95
  def reset_after_fork; end

  # source://datadog//lib/datadog/profiling/stack_recorder.rb#62
  def serialize; end

  # source://datadog//lib/datadog/profiling/stack_recorder.rb#81
  def serialize!; end

  # source://datadog//lib/datadog/profiling/stack_recorder.rb#99
  def stats; end

  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_initialize(*_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_reset_after_fork(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_serialize(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_stats(_arg0); end

    # source://datadog//lib/datadog/profiling/stack_recorder.rb#40
    def for_testing(cpu_time_enabled: T.unsafe(nil), alloc_samples_enabled: T.unsafe(nil), heap_samples_enabled: T.unsafe(nil), heap_size_enabled: T.unsafe(nil), heap_sample_every: T.unsafe(nil), timeline_enabled: T.unsafe(nil), heap_clean_after_gc_enabled: T.unsafe(nil), **options); end
  end
end

module Datadog::Profiling::StackRecorder::Testing
  class << self
    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_active_slot(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_benchmark_intern(_arg0, _arg1, _arg2, _arg3); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_debug_heap_recorder(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_end_fake_slow_heap_serialization(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_heap_recorder_reset_last_update(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_is_object_recorded?(_arg0, _arg1); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_record_endpoint(_arg0, _arg1, _arg2); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_recorder_after_gc_step(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_slot_one_mutex_locked?(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_slot_two_mutex_locked?(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_start_fake_slow_heap_serialization(_arg0); end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_test_managed_string_storage_produces_valid_profiles; end

    # source://datadog//lib/datadog/profiling/load_native_extension.rb#4
    def _native_track_object(_arg0, _arg1, _arg2, _arg3); end
  end
end

# Builds a hash of default plus user tags to be included in a profile
#
# source://datadog//lib/datadog/profiling/tag_builder.rb#9
module Datadog::Profiling::TagBuilder
  include ::Datadog::Profiling::Ext::Transport::HTTP

  class << self
    # source://datadog//lib/datadog/profiling/tag_builder.rb#12
    def call(settings:, profile_seq:, profiler_version: T.unsafe(nil)); end
  end
end

# source://datadog//lib/datadog/profiling/tasks/setup.rb#8
module Datadog::Profiling::Tasks; end

# Takes care of restarting the profiler when the process forks
#
# source://datadog//lib/datadog/profiling/tasks/setup.rb#10
class Datadog::Profiling::Tasks::Setup
  # source://datadog//lib/datadog/profiling/tasks/setup.rb#13
  def run; end

  private

  # source://datadog//lib/datadog/profiling/tasks/setup.rb#28
  def setup_at_fork_hooks; end
end

# source://datadog//lib/datadog/profiling/tasks/setup.rb#11
Datadog::Profiling::Tasks::Setup::ACTIVATE_EXTENSIONS_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# Datadog APM tracing public API.
#
# The Datadog team ensures that public methods in this module
# only receive backwards compatible changes, and breaking changes
# will only occur in new major versions releases.
#
# source://datadog//lib/datadog/tracing/configuration/ext.rb#6
module Datadog::Tracing
  class << self
    # The active, unfinished span, representing the currently instrumented application section.
    #
    # The active span belongs to an {.active_trace}.
    #
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Datadog::Tracing::SpanOperation] the active span
    # @return [nil] if no trace is active, and thus no span is active
    #
    # source://datadog//lib/datadog/tracing.rb#72
    def active_span; end

    # The active, unfinished trace, representing the current instrumentation context.
    #
    # The active trace is fiber-local.
    #
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Datadog::Tracing::TraceSegment] the active trace
    # @return [nil] if no trace is active
    #
    # source://datadog//lib/datadog/tracing.rb#63
    def active_trace; end

    # Returns the baggage for the current trace.
    #
    # If there is no active trace, a new one is created.
    #
    # @return [Datadog::Tracing::Distributed::Baggage] The baggage for the current trace.
    #
    # source://datadog//lib/datadog/tracing.rb#135
    def baggage; end

    # @overload before_flush
    # @overload before_flush
    # @see file:docs/GettingStarted.md#configuring-the-transport-layer Configuring the transport layer
    #
    # source://datadog//lib/datadog/tracing.rb#161
    def before_flush(*processors, &processor_block); end

    # Setup a new trace to continue from where another
    # trace left off.
    #
    # Used to continue distributed or async traces.
    #
    # @param digest [Datadog::Tracing::TraceDigest] continue from the {Datadog::Tracing::TraceDigest}.
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Object] If a block is provided, the result of the block execution.
    # @return [Datadog::Tracing::TraceOperation] If no block, the active {Datadog::Tracing::TraceOperation}.
    # @yield Optional block where this {#continue_trace!} `digest` scope is active.
    #   If no block, the `digest` remains active after {#continue_trace!} returns.
    #
    # source://datadog//lib/datadog/tracing.rb#45
    def continue_trace!(digest, &block); end

    # Information about the currently active trace.
    #
    # The most common use cases are tagging log messages and metrics.
    #
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Datadog::Tracing::Correlation::Identifier] correlation object
    #
    # source://datadog//lib/datadog/tracing.rb#97
    def correlation; end

    # Is the tracer collecting telemetry data in this process?
    #
    # @return [Boolean] `true` if the tracer is collecting data in this process, otherwise `false`.
    #
    # source://datadog//lib/datadog/tracing.rb#167
    def enabled?; end

    # If an active trace is present, forces it to be retained by the Datadog backend.
    #
    # Any sampling logic will not be able to change this decision.
    #
    # If no trace is active, no action is taken.
    #
    # @return [void]
    #
    # source://datadog//lib/datadog/tracing.rb#82
    def keep!; end

    # Textual representation of {.correlation}, which can be
    # added to individual log lines in order to correlate them with the active
    # trace.
    #
    # Example:
    #
    # ```
    # MyLogger.log("#{Datadog::Tracing.log_correlation}] My message")
    # # dd.env=prod dd.service=auth dd.version=13.8 dd.trace_id=5458478252992251 dd.span_id=7117552347370098 My message
    # ```
    #
    # @return [String] correlation information; or an empty String if Tracing is disabled (`!enabled?`)
    #
    # source://datadog//lib/datadog/tracing.rb#123
    def log_correlation; end

    # The tracer's internal logger instance.
    # All tracing log output is handled by this object.
    #
    # The logger can be configured through {.configure},
    # through {Datadog::Core::Configuration::Settings::DSL::Logger} options.
    #
    # source://datadog//lib/datadog/tracing.rb#57
    def logger; end

    # If an active trace is present, forces it to be dropped and not stored by the Datadog backend.
    #
    # Any sampling logic will not be able to change this decision.
    #
    # If no trace is active, no action is taken.
    #
    # @return [void]
    #
    # source://datadog//lib/datadog/tracing.rb#90
    def reject!; end

    # Gracefully shuts down the tracer.
    #
    # The public tracing API will still respond to method calls as usual
    # but might not internally perform the expected internal work after shutdown.
    #
    # This avoids errors being raised across the host application
    # during shutdown while allowing for the graceful decommission of resources.
    #
    # {.shutdown!} cannot be reversed.
    #
    # source://datadog//lib/datadog/tracing.rb#153
    def shutdown!; end

    # Return a {Datadog::Tracing::SpanOperation span_op} and {Datadog::Tracing::TraceOperation trace_op}
    # that will trace an operation called `name`.
    #
    # You could trace your code using a <tt>do-block</tt> like:
    #
    # ```
    # tracer.trace('web.request') do |span_op, trace_op|
    #   span_op.service = 'my-web-site'
    #   span_op.resource = '/'
    #   span_op.set_tag('http.method', request.request_method)
    #   do_something()
    # end
    # ```
    #
    # The {#trace} method can also be used without a block in this way:
    # ```
    # span_op = tracer.trace('web.request', service: 'my-web-site')
    # do_something()
    # span_op.finish()
    # ```
    #
    # Remember that in this case, calling {Datadog::Tracing::SpanOperation#finish} is mandatory.
    #
    # When a Trace is started, {#trace} will store the created span; subsequent spans will
    # become its children and will inherit some properties:
    # ```
    # parent = tracer.trace('parent')   # has no parent span
    # child  = tracer.trace('child')    # is a child of 'parent'
    # child.finish()
    # parent.finish()
    # parent2 = tracer.trace('parent2') # has no parent span
    # parent2.finish()
    # ```
    #
    #
    # @param continue_from [Datadog::Tracing::TraceDigest] continue a trace from a {Datadog::Tracing::TraceDigest}.
    #   Used for linking traces that are executed asynchronously.
    # @param name [String] {Datadog::Tracing::Span} operation name.
    #   See {https://docs.datadoghq.com/tracing/guide/configuring-primary-operation/ Primary Operations in Services}.
    # @param on_error [Proc] a block that overrides error handling behavior for this operation.
    # @param resource [String] the resource this span refers, or `name` if it's missing
    # @param service [String] the service name for this span.
    # @param start_time [Time] time which the span should have started.
    # @param tags [Hash<String,String>] extra tags which should be added to the span.
    # @param the [Integer] id of the new span.
    # @param type [String] the type of the span. See {Datadog::Tracing::Metadata::Ext::AppTypes}.
    # @return [Object] If a block is provided, returns the result of the block execution.
    # @return [Datadog::Tracing::SpanOperation] If no block is provided, returns the active,
    #   unfinished {Datadog::Tracing::SpanOperation}.
    # @yield Optional block where new newly created {Datadog::Tracing::SpanOperation} captures the execution.
    # @yieldparam span_op [Datadog::Tracing::SpanOperation] the newly created and active [Datadog::Tracing::SpanOperation]
    # @yieldparam trace_op [Datadog::Tracing::TraceOperation] the active [Datadog::Tracing::TraceOperation]
    #
    # source://datadog//lib/datadog/tracing.rb#17
    def trace(name, continue_from: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), id: T.unsafe(nil), &block); end

    private

    # DEV: components hosts both tracing and profiling inner objects today
    #
    # source://datadog//lib/datadog/tracing.rb#177
    def components; end

    # source://datadog//lib/datadog/tracing.rb#181
    def tracer; end
  end
end

# Defines analytics behavior
#
# source://datadog//lib/datadog/tracing/analytics.rb#8
module Datadog::Tracing::Analytics
  class << self
    # source://datadog//lib/datadog/tracing/analytics.rb#16
    def set_measured(span_op, value = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/analytics.rb#10
    def set_sample_rate(span_op, sample_rate); end
  end
end

# Trace buffer that stores application traces, has a maximum size, and
# can be safely used concurrently with CRuby.
#
# @see Datadog::Core::Buffer::CRuby
#
# source://datadog//lib/datadog/tracing/buffer.rb#111
class Datadog::Tracing::CRubyTraceBuffer < ::Datadog::Core::Buffer::CRuby
  include ::Datadog::Tracing::MeasuredBuffer
end

# Common functions for supporting the `http.client_ip` span attribute.
#
# source://datadog//lib/datadog/tracing/client_ip.rb#11
module Datadog::Tracing::ClientIp
  class << self
    # source://datadog//lib/datadog/tracing/client_ip.rb#40
    def extract_client_ip(headers, remote_ip); end

    # Sets the `http.client_ip` tag on the given span.
    #
    # This function respects the user's settings: if they disable the client IP tagging,
    #   or provide a different IP header name.
    #
    # @param headers [HeaderCollection, #get, nil] A collection with the request headers.
    # @param remote_ip [String, nil] The remote IP the request associated with the span is sent to.
    # @param span [Span] The span that's associated with the request.
    #
    # source://datadog//lib/datadog/tracing/client_ip.rb#21
    def set_client_ip_tag(span, headers: T.unsafe(nil), remote_ip: T.unsafe(nil)); end

    # Forcefully sets the `http.client_ip` tag on the given span.
    #
    # This function ignores the user's `enabled` setting.
    #
    # @param headers [HeaderCollection, #get, nil] A collection with the request headers.
    # @param remote_ip [String, nil] The remote IP the request associated with the span is sent to.
    # @param span [Span] The span that's associated with the request.
    #
    # source://datadog//lib/datadog/tracing/client_ip.rb#34
    def set_client_ip_tag!(span, headers: T.unsafe(nil), remote_ip: T.unsafe(nil)); end

    private

    # source://datadog//lib/datadog/tracing/client_ip.rb#55
    def configuration; end
  end
end

# Tracing component
#
# source://datadog//lib/datadog/tracing/component.rb#14
module Datadog::Tracing::Component
  private

  # Build a post-sampler that limits the rate of traces to one per `seconds`.
  # E.g.: `build_rate_limit_post_sampler(seconds: 60)` will limit the rate to one trace per minute.
  #
  # @api private
  #
  # source://datadog//lib/datadog/tracing/component.rb#182
  def build_rate_limit_post_sampler(seconds:); end

  # source://datadog//lib/datadog/tracing/component.rb#63
  def build_sampler(settings); end

  # source://datadog//lib/datadog/tracing/component.rb#145
  def build_span_sampler(settings); end

  # @api private
  #
  # source://datadog//lib/datadog/tracing/component.rb#196
  def build_test_mode_sampler; end

  # @api private
  #
  # source://datadog//lib/datadog/tracing/component.rb#190
  def build_test_mode_trace_flush(settings); end

  # @api private
  #
  # source://datadog//lib/datadog/tracing/component.rb#206
  def build_test_mode_writer(settings, agent_settings); end

  # source://datadog//lib/datadog/tracing/component.rb#53
  def build_trace_flush(settings); end

  # source://datadog//lib/datadog/tracing/component.rb#17
  def build_tracer(settings, agent_settings, logger:); end

  # @api private
  #
  # source://datadog//lib/datadog/tracing/component.rb#172
  def build_tracer_tags(settings); end

  # TODO: Writer should be a top-level component.
  # It is currently part of the Tracer initialization
  # process, but can take a variety of options (including
  # a fully custom instance) that makes the Tracer
  # initialization process complex.
  #
  # source://datadog//lib/datadog/tracing/component.rb#102
  def build_writer(settings, agent_settings, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/component.rb#110
  def subscribe_to_writer_events!(writer, sampler_delegator, test_mode); end

  # Create new lambda for writer callback,
  # capture the current sampler in the callback closure.
  #
  # source://datadog//lib/datadog/tracing/component.rb#135
  def writer_update_priority_sampler_rates_callback(sampler); end

  class << self
    # Build a post-sampler that limits the rate of traces to one per `seconds`.
    # E.g.: `build_rate_limit_post_sampler(seconds: 60)` will limit the rate to one trace per minute.
    #
    # @api private
    #
    # source://datadog//lib/datadog/tracing/component.rb#182
    def build_rate_limit_post_sampler(seconds:); end

    # source://datadog//lib/datadog/tracing/component.rb#63
    def build_sampler(settings); end

    # source://datadog//lib/datadog/tracing/component.rb#145
    def build_span_sampler(settings); end

    # @api private
    #
    # source://datadog//lib/datadog/tracing/component.rb#196
    def build_test_mode_sampler; end

    # @api private
    #
    # source://datadog//lib/datadog/tracing/component.rb#190
    def build_test_mode_trace_flush(settings); end

    # @api private
    #
    # source://datadog//lib/datadog/tracing/component.rb#206
    def build_test_mode_writer(settings, agent_settings); end

    # source://datadog//lib/datadog/tracing/component.rb#53
    def build_trace_flush(settings); end

    # source://datadog//lib/datadog/tracing/component.rb#17
    def build_tracer(settings, agent_settings, logger:); end

    # @api private
    #
    # source://datadog//lib/datadog/tracing/component.rb#172
    def build_tracer_tags(settings); end

    # TODO: Writer should be a top-level component.
    # It is currently part of the Tracer initialization
    # process, but can take a variety of options (including
    # a fully custom instance) that makes the Tracer
    # initialization process complex.
    #
    # source://datadog//lib/datadog/tracing/component.rb#102
    def build_writer(settings, agent_settings, options = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/component.rb#110
    def subscribe_to_writer_events!(writer, sampler_delegator, test_mode); end

    # Create new lambda for writer callback,
    # capture the current sampler in the callback closure.
    #
    # source://datadog//lib/datadog/tracing/component.rb#135
    def writer_update_priority_sampler_rates_callback(sampler); end
  end
end

# Sampler wrapper component, to allow for hot-swapping
# the sampler instance used by the tracer.
# Swapping samplers happens during Dynamic Configuration.
#
# source://datadog//lib/datadog/tracing/component.rb#153
class Datadog::Tracing::Component::SamplerDelegatorComponent
  # @return [SamplerDelegatorComponent] a new instance of SamplerDelegatorComponent
  #
  # source://datadog//lib/datadog/tracing/component.rb#156
  def initialize(sampler); end

  # source://datadog//lib/datadog/tracing/component.rb#160
  def sample!(trace); end

  # Returns the value of attribute sampler.
  #
  # source://datadog//lib/datadog/tracing/component.rb#154
  def sampler; end

  # Sets the attribute sampler
  #
  # @param value the value to set the attribute sampler to.
  #
  # source://datadog//lib/datadog/tracing/component.rb#154
  def sampler=(_arg0); end

  # source://datadog//lib/datadog/tracing/component.rb#164
  def update(*args, **kwargs); end
end

# source://datadog//lib/datadog/tracing/component.rb#125
Datadog::Tracing::Component::WRITER_RECORD_ENVIRONMENT_INFORMATION_CALLBACK = T.let(T.unsafe(nil), Proc)

# source://datadog//lib/datadog/tracing/component.rb#131
Datadog::Tracing::Component::WRITER_RECORD_ENVIRONMENT_INFORMATION_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#7
module Datadog::Tracing::Configuration; end

# Tracing Dynamic Configuration,
# powered by the Remote Configuration platform.
#
# source://datadog//lib/datadog/tracing/configuration/dynamic/option.rb#6
module Datadog::Tracing::Configuration::Dynamic; end

# Dynamic configuration for `DD_LOGS_INJECTION`.
#
# source://datadog//lib/datadog/tracing/configuration/dynamic.rb#12
class Datadog::Tracing::Configuration::Dynamic::LogInjectionEnabled < ::Datadog::Tracing::Configuration::Dynamic::SimpleOption
  # @return [LogInjectionEnabled] a new instance of LogInjectionEnabled
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic.rb#13
  def initialize; end
end

# List of all tracing dynamic configuration options supported.
#
# source://datadog//lib/datadog/tracing/configuration/dynamic.rb#93
Datadog::Tracing::Configuration::Dynamic::OPTIONS = T.let(T.unsafe(nil), Array)

# Maps a remote dynamic configuration to a location configuration option.
#
# source://datadog//lib/datadog/tracing/configuration/dynamic/option.rb#8
class Datadog::Tracing::Configuration::Dynamic::Option
  # @param name [String] dynamic configuration option name. This must match the remote configuration payload.
  # @return [Option] a new instance of Option
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic/option.rb#12
  def initialize(name, env_var); end

  # Reconfigures the provided option, setting its value to `value`.
  #
  # @param value [Object, nil] the new value for this option
  # @raise [NotImplementedError]
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic/option.rb#20
  def call(value); end

  # Returns the value of attribute env_var.
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic/option.rb#9
  def env_var; end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic/option.rb#9
  def name; end
end

# A dynamic configuration option that can directly mapped to a `Datadog.configuration`
# option and changing such option is the only requirement to apply the configuration locally.
#
# source://datadog//lib/datadog/tracing/configuration/dynamic/option.rb#27
class Datadog::Tracing::Configuration::Dynamic::SimpleOption < ::Datadog::Tracing::Configuration::Dynamic::Option
  # DEV: `Datadog.configuration` cannot be an argument default value because
  # DEV: it is dynamic. Also, it is not yet declared when this method is parsed by Ruby.
  #
  # @param env_var [String] the canonical environment variable that represents this option.
  #   This is used for telemetry reporting.
  # @param name [String] dynamic configuration option name. This must match the remote configuration payload.
  # @param setting_key [Symbol] option from `Datadog.configuration.tracing` that will be modified
  # @return [SimpleOption] a new instance of SimpleOption
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic/option.rb#35
  def initialize(name, env_var, setting_key); end

  # Reconfigures the provided option, setting its value to `value`.
  #
  # @param value [Object, nil] the new value for this option
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic/option.rb#43
  def call(value); end

  protected

  # The base where `setting_key` will apply
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic/option.rb#64
  def configuration_object; end
end

# Dynamic configuration for `DD_TRACE_HEADER_TAGS`.
#
# source://datadog//lib/datadog/tracing/configuration/dynamic.rb#19
class Datadog::Tracing::Configuration::Dynamic::TracingHeaderTags < ::Datadog::Tracing::Configuration::Dynamic::SimpleOption
  # @return [TracingHeaderTags] a new instance of TracingHeaderTags
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic.rb#20
  def initialize; end

  # source://datadog//lib/datadog/tracing/configuration/dynamic.rb#24
  def call(tracing_header_tags); end
end

# Dynamic configuration for `DD_TRACE_SAMPLE_RATE`.
#
# source://datadog//lib/datadog/tracing/configuration/dynamic.rb#36
class Datadog::Tracing::Configuration::Dynamic::TracingSamplingRate < ::Datadog::Tracing::Configuration::Dynamic::SimpleOption
  # @return [TracingSamplingRate] a new instance of TracingSamplingRate
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic.rb#37
  def initialize; end

  # Ensures sampler is rebuilt and new configuration is applied
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic.rb#42
  def call(tracing_sampling_rate); end

  protected

  # source://datadog//lib/datadog/tracing/configuration/dynamic.rb#49
  def configuration_object; end
end

# Dynamic configuration for `DD_TRACE_SAMPLING_RULES`.
#
# source://datadog//lib/datadog/tracing/configuration/dynamic.rb#55
class Datadog::Tracing::Configuration::Dynamic::TracingSamplingRules < ::Datadog::Tracing::Configuration::Dynamic::SimpleOption
  # @return [TracingSamplingRules] a new instance of TracingSamplingRules
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic.rb#56
  def initialize; end

  # Ensures sampler is rebuilt and new configuration is applied
  #
  # source://datadog//lib/datadog/tracing/configuration/dynamic.rb#61
  def call(tracing_sampling_rules); end

  protected

  # source://datadog//lib/datadog/tracing/configuration/dynamic.rb#87
  def configuration_object; end
end

# Constants for configuration settings
# e.g. Env vars, default values, enums, etc...
#
# source://datadog//lib/datadog/tracing/configuration/ext.rb#10
module Datadog::Tracing::Configuration::Ext; end

# source://datadog//lib/datadog/tracing/configuration/ext.rb#24
module Datadog::Tracing::Configuration::Ext::Analytics; end

# source://datadog//lib/datadog/tracing/configuration/ext.rb#25
Datadog::Tracing::Configuration::Ext::Analytics::ENV_TRACE_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#103
module Datadog::Tracing::Configuration::Ext::ClientIp; end

# source://datadog//lib/datadog/tracing/configuration/ext.rb#104
Datadog::Tracing::Configuration::Ext::ClientIp::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#105
Datadog::Tracing::Configuration::Ext::ClientIp::ENV_HEADER_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#29
module Datadog::Tracing::Configuration::Ext::Correlation; end

# source://datadog//lib/datadog/tracing/configuration/ext.rb#30
Datadog::Tracing::Configuration::Ext::Correlation::ENV_LOGS_INJECTION_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#31
Datadog::Tracing::Configuration::Ext::Correlation::ENV_TRACE_ID_128_BIT_LOGGING_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#35
module Datadog::Tracing::Configuration::Ext::Distributed; end

# Sets both extract and inject propagation style tho the provided value.
# Has lower precedence than `DD_TRACE_PROPAGATION_STYLE_INJECT` or
# `DD_TRACE_PROPAGATION_STYLE_EXTRACT`.
#
# source://datadog//lib/datadog/tracing/configuration/ext.rb#56
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#60
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE_EXTRACT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#58
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE_INJECT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#69
Datadog::Tracing::Configuration::Ext::Distributed::ENV_X_DATADOG_TAGS_MAX_LENGTH = T.let(T.unsafe(nil), String)

# Strictly stop at the first successfully serialized style.
#
# source://datadog//lib/datadog/tracing/configuration/ext.rb#67
Datadog::Tracing::Configuration::Ext::Distributed::EXTRACT_FIRST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#39
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_B3_MULTI_HEADER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#40
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_B3_SINGLE_HEADER = T.let(T.unsafe(nil), String)

# W3C Baggage
#
# @see https://www.w3.org/TR/baggage/
#
# source://datadog//lib/datadog/tracing/configuration/ext.rb#47
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_BAGGAGE = T.let(T.unsafe(nil), String)

# Custom Datadog format
#
# source://datadog//lib/datadog/tracing/configuration/ext.rb#37
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_DATADOG = T.let(T.unsafe(nil), String)

# A no-op propagator. Compatible with OpenTelemetry's `none` propagator.
#
# @see https://opentelemetry.io/docs/concepts/sdk-configuration/general-sdk-configuration/#get_otel__propagators
#
# source://datadog//lib/datadog/tracing/configuration/ext.rb#64
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_NONE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#49
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_SUPPORTED = T.let(T.unsafe(nil), Array)

# W3C Trace Context
#
# source://datadog//lib/datadog/tracing/configuration/ext.rb#43
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_TRACE_CONTEXT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#13
Datadog::Tracing::Configuration::Ext::ENV_BAGGAGE_TAG_KEYS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#11
Datadog::Tracing::Configuration::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#12
Datadog::Tracing::Configuration::Ext::ENV_HEADER_TAGS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#15
Datadog::Tracing::Configuration::Ext::ENV_NATIVE_SPAN_EVENTS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#14
Datadog::Tracing::Configuration::Ext::ENV_TRACE_ID_128_BIT_GENERATION_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#73
module Datadog::Tracing::Configuration::Ext::NET; end

# source://datadog//lib/datadog/tracing/configuration/ext.rb#74
Datadog::Tracing::Configuration::Ext::NET::ENV_REPORT_HOSTNAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#78
module Datadog::Tracing::Configuration::Ext::Sampling; end

# source://datadog//lib/datadog/tracing/configuration/ext.rb#80
Datadog::Tracing::Configuration::Ext::Sampling::ENV_RATE_LIMIT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#81
Datadog::Tracing::Configuration::Ext::Sampling::ENV_RULES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#79
Datadog::Tracing::Configuration::Ext::Sampling::ENV_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#82
Datadog::Tracing::Configuration::Ext::Sampling::OTEL_TRACES_SAMPLER_ARG = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#85
module Datadog::Tracing::Configuration::Ext::Sampling::Span; end

# source://datadog//lib/datadog/tracing/configuration/ext.rb#86
Datadog::Tracing::Configuration::Ext::Sampling::Span::ENV_SPAN_SAMPLING_RULES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#87
Datadog::Tracing::Configuration::Ext::Sampling::Span::ENV_SPAN_SAMPLING_RULES_FILE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#18
module Datadog::Tracing::Configuration::Ext::SpanAttributeSchema; end

# source://datadog//lib/datadog/tracing/configuration/ext.rb#19
Datadog::Tracing::Configuration::Ext::SpanAttributeSchema::ENV_GLOBAL_DEFAULT_SERVICE_NAME_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#20
Datadog::Tracing::Configuration::Ext::SpanAttributeSchema::ENV_PEER_SERVICE_DEFAULTS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#21
Datadog::Tracing::Configuration::Ext::SpanAttributeSchema::ENV_PEER_SERVICE_MAPPING = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#92
module Datadog::Tracing::Configuration::Ext::Test; end

# source://datadog//lib/datadog/tracing/configuration/ext.rb#93
Datadog::Tracing::Configuration::Ext::Test::ENV_MODE_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#97
module Datadog::Tracing::Configuration::Ext::Transport; end

# source://datadog//lib/datadog/tracing/configuration/ext.rb#98
Datadog::Tracing::Configuration::Ext::Transport::ENV_DEFAULT_PORT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/ext.rb#99
Datadog::Tracing::Configuration::Ext::Transport::ENV_DEFAULT_URL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/configuration/http.rb#6
module Datadog::Tracing::Configuration::HTTP; end

# Datadog tracing supports capturing HTTP request and response headers as span tags.
#
# The provided configuration String for this feature has to be pre-processed to
# allow for ease of utilization by each HTTP integration.
#
# This class process configuration, stores the result, and provides methods to
# utilize this configuration.
#
# source://datadog//lib/datadog/tracing/configuration/http.rb#14
class Datadog::Tracing::Configuration::HTTP::HeaderTags
  # @param header_tags [Array<String>] The list of strings from DD_TRACE_HEADER_TAGS.
  # @return [HeaderTags] a new instance of HeaderTags
  #
  # source://datadog//lib/datadog/tracing/configuration/http.rb#16
  def initialize(header_tags); end

  # Receives a case insensitive hash with the request headers and returns
  # a list of tag names and values that can be set in a span.
  #
  # source://datadog//lib/datadog/tracing/configuration/http.rb#45
  def request_tags(headers); end

  # Receives a case insensitive hash with the response headers and returns
  # a list of tag names and values that can be set in a span.
  #
  # source://datadog//lib/datadog/tracing/configuration/http.rb#56
  def response_tags(headers); end

  # For easy configuration inspection,
  # print the original configuration setting.
  #
  # source://datadog//lib/datadog/tracing/configuration/http.rb#67
  def to_s; end
end

# Configuration settings for tracing.
#
# source://datadog//lib/datadog/tracing/configuration/settings.rb#18
module Datadog::Tracing::Configuration::Settings
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/configuration/settings.rb#19
    def extended(base); end
  end
end

# {Datadog::Tracing::Context} is used to keep track of a the active trace for the current
# execution flow. During each logical execution, the same {Datadog::Tracing::Context} is
# used to represent a single logical trace, even if the trace is built
# asynchronously.
#
# A single code execution may use multiple {Datadog::Tracing::Context} if part of the execution
# must not be related to the current tracing. As example, a delayed job may
# compose a standalone trace instead of being related to the same trace that
# generates the job itself. On the other hand, if it's part of the same
# {Datadog::Tracing::Context}, it will be related to the original trace.
#
# source://datadog//lib/datadog/tracing/context.rb#17
class Datadog::Tracing::Context
  include ::Datadog::Core::Utils::Forking::ClassExtensions
  include ::Datadog::Core::Utils::Forking

  # @return [Context] a new instance of Context
  #
  # source://datadog//lib/datadog/tracing/context.rb#23
  def initialize(*args, **kwargs, &block); end

  # Handles trace activation.
  #
  # Permits nil, allowing traces to be deactivated.
  #
  # If given a block, it will reset to the original
  # trace after the block completes.
  #
  # When restoring the original trace, if it is finished,
  # it will deactivate it. This prevents the context from
  # holding references to completed traces thereby releasing
  # its memory.
  #
  # source://datadog//lib/datadog/tracing/context.rb#40
  def activate!(trace); end

  # Returns the value of attribute active_trace.
  #
  # source://datadog//lib/datadog/tracing/context.rb#20
  def active_trace; end

  # Creates a copy of the context, when forked.
  #
  # source://datadog//lib/datadog/tracing/context.rb#55
  def fork_clone; end

  private

  # source://datadog//lib/datadog/tracing/context.rb#62
  def set_active_trace!(trace); end
end

# Out-of-the-box instrumentation for tracing
#
# source://datadog//lib/datadog/tracing/contrib/component.rb#5
module Datadog::Tracing::Contrib
  class << self
    # Auto-activate instrumentation
    #
    # source://datadog//lib/datadog/tracing/contrib/auto_instrument.rb#11
    def auto_instrument!; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#6
module Datadog::Tracing::Contrib::ActionCable; end

# source://datadog//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActionCable::Configuration; end

# Custom settings for the ActionCable integration
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActionCable::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#33
  def service_name=(value); end
end

# Defines basic behaviors for an event.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/event.rb#13
module Datadog::Tracing::Contrib::ActionCable::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/action_cable/event.rb#14
    def included(base); end
  end
end

# Class methods for events.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/event.rb#20
module Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/action_cable/event.rb#29
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/event.rb#21
  def span_options; end
end

# Defines collection of instrumented ActionCable events
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#12
module Datadog::Tracing::Contrib::ActionCable::Events
  private

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events.rb#22
  def all; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events.rb#30
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events.rb#26
  def subscriptions; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_cable/events.rb#22
    def all; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events.rb#30
    def subscribe!; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events.rb#26
    def subscriptions; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_cable/events.rb#14
Datadog::Tracing::Contrib::ActionCable::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for 'broadcast.action_cable' event.
#
# A single 'broadcast' event will trigger as many 'transmit' events
# as there are clients subscribed to a channel.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#17
module Datadog::Tracing::Contrib::ActionCable::Events::Broadcast
  include ::Datadog::Tracing::Contrib::ActionCable::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#24
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#37
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#28
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#32
  def span_type; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#24
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#37
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#28
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#32
    def span_type; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#20
Datadog::Tracing::Contrib::ActionCable::Events::Broadcast::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for 'perform_action.action_cable' event.
#
# An action, triggered by a WebSockets client, invokes a method
# in the server's channel instance.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#16
module Datadog::Tracing::Contrib::ActionCable::Events::PerformAction
  include ::Datadog::Tracing::Contrib::ActionCable::RootContextEvent
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::RootContextEvent::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#23
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#36
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#27
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#31
  def span_type; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#23
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#36
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#27
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#31
    def span_type; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#19
Datadog::Tracing::Contrib::ActionCable::Events::PerformAction::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for 'transmit.action_cable' event.
#
# A 'transmit' event sends a message to a single client subscribed to a channel.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#16
module Datadog::Tracing::Contrib::ActionCable::Events::Transmit
  include ::Datadog::Tracing::Contrib::ActionCable::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#23
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#36
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#27
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#31
  def span_type; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#23
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#36
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#27
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#31
    def span_type; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#19
Datadog::Tracing::Contrib::ActionCable::Events::Transmit::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActionCable integration constants
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#9
module Datadog::Tracing::Contrib::ActionCable::Ext; end

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#12
Datadog::Tracing::Contrib::ActionCable::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#13
Datadog::Tracing::Contrib::ActionCable::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#10
Datadog::Tracing::Contrib::ActionCable::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#14
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_ACTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#15
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_BROADCAST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#16
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_ON_OPEN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#17
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_TRANSMIT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#18
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_ACTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#19
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_BROADCAST_CODER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#20
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_CHANNEL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#21
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_CHANNEL_CLASS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#22
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#23
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_CONNECTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#24
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_ACTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#25
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_BROADCAST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#26
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_ON_OPEN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#27
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_TRANSMIT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/ext.rb#28
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_TRANSMIT_VIA = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#11
module Datadog::Tracing::Contrib::ActionCable::Instrumentation; end

# Instrumentation for when a Channel is subscribed to/unsubscribed from.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#35
module Datadog::Tracing::Contrib::ActionCable::Instrumentation::ActionCableChannel
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#36
    def included(base); end
  end
end

# Instrumentation for Channel hooks.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#55
class Datadog::Tracing::Contrib::ActionCable::Instrumentation::ActionCableChannel::Tracer
  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#56
    def trace(channel, hook); end
  end
end

# When a new WebSocket is open, we receive a Rack request resource name "GET -1".
# This module overrides the current Rack resource name to provide a meaningful name.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#14
module Datadog::Tracing::Contrib::ActionCable::Instrumentation::ActionCableConnection
  # source://datadog//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#15
  def on_open; end
end

# Description of ActionCable integration
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/integration.rb#13
class Datadog::Tracing::Contrib::ActionCable::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/action_cable/integration.rb#38
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/integration.rb#42
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/integration.rb#46
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/action_cable/integration.rb#32
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/integration.rb#20
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/action_cable/integration.rb#28
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/integration.rb#24
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_cable/integration.rb#16
Datadog::Tracing::Contrib::ActionCable::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'action_cable' module.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/patcher.rb#13
module Datadog::Tracing::Contrib::ActionCable::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_cable/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/action_cable/patcher.rb#18
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_cable/patcher.rb#22
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/action_cable/patcher.rb#18
    def target_version; end
  end
end

# Defines behavior for the first event of a thread execution.
#
# This event is not expected to be nested with other event,
# but to start a fresh tracing context.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/event.rb#39
module Datadog::Tracing::Contrib::ActionCable::RootContextEvent
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionCable::RootContextEvent::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/action_cable/event.rb#40
    def included(base); end
  end
end

# Class methods for events.
#
# source://datadog//lib/datadog/tracing/contrib/action_cable/event.rb#46
module Datadog::Tracing::Contrib::ActionCable::RootContextEvent::ClassMethods
  include ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/action_cable/event.rb#49
  def subscription(*args, **kwargs); end

  private

  # Context objects are thread-bound.
  # If an integration re-uses threads, context from a previous trace
  # could leak into the new trace. This "cleans" current context,
  # preventing such a leak.
  #
  # source://datadog//lib/datadog/tracing/contrib/action_cable/event.rb#61
  def ensure_clean_context!; end
end

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#6
module Datadog::Tracing::Contrib::ActionMailer; end

# source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActionMailer::Configuration; end

# Custom settings for the ActionMailer integration
#
# source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActionMailer::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#34
  def email_data; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#34
  def email_data=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#33
  def service_name=(value); end
end

# Defines basic behaviors for an ActionMailer event.
#
# source://datadog//lib/datadog/tracing/contrib/action_mailer/event.rb#12
module Datadog::Tracing::Contrib::ActionMailer::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/action_mailer/event.rb#13
    def included(base); end
  end
end

# Class methods for ActionMailer events.
#
# source://datadog//lib/datadog/tracing/contrib/action_mailer/event.rb#19
module Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/action_mailer/event.rb#26
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/event.rb#30
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/event.rb#20
  def span_options; end
end

# Defines collection of instrumented ActionMailer events
#
# source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#11
module Datadog::Tracing::Contrib::ActionMailer::Events
  private

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events.rb#19
  def all; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events.rb#27
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events.rb#23
  def subscriptions; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events.rb#19
    def all; end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events.rb#27
    def subscribe!; end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events.rb#23
    def subscriptions; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_mailer/events.rb#12
Datadog::Tracing::Contrib::ActionMailer::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for deliver.action_mailer event
#
# source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#13
module Datadog::Tracing::Contrib::ActionMailer::Events::Deliver
  include ::Datadog::Tracing::Contrib::ActionMailer::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#20
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#39
  def on_finish(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#33
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#24
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#28
  def span_type; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#20
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#39
    def on_finish(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#33
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#24
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#28
    def span_type; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#16
Datadog::Tracing::Contrib::ActionMailer::Events::Deliver::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for process.action_mailer event
#
# source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#13
module Datadog::Tracing::Contrib::ActionMailer::Events::Process
  include ::Datadog::Tracing::Contrib::ActionMailer::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#20
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#33
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#24
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#28
  def span_type; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#20
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#33
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#24
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#28
    def span_type; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_mailer/events/process.rb#16
Datadog::Tracing::Contrib::ActionMailer::Events::Process::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActionMailer integration constants
#
# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#9
module Datadog::Tracing::Contrib::ActionMailer::Ext; end

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#12
Datadog::Tracing::Contrib::ActionMailer::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#13
Datadog::Tracing::Contrib::ActionMailer::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#10
Datadog::Tracing::Contrib::ActionMailer::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#15
Datadog::Tracing::Contrib::ActionMailer::Ext::SPAN_DELIVER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#14
Datadog::Tracing::Contrib::ActionMailer::Ext::SPAN_PROCESS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#17
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_ACTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#26
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_BCC = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#27
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_CC = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#16
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#28
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_DATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#25
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_FROM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#18
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_MAILER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#19
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_MSG_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#20
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_OPERATION_DELIVER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#21
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_OPERATION_PROCESS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#29
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_PERFORM_DELIVERIES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#23
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_SUBJECT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_mailer/ext.rb#24
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_TO = T.let(T.unsafe(nil), String)

# Description of ActionMailer integration
#
# source://datadog//lib/datadog/tracing/contrib/action_mailer/integration.rb#13
class Datadog::Tracing::Contrib::ActionMailer::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/action_mailer/integration.rb#39
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/integration.rb#43
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/integration.rb#47
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/action_mailer/integration.rb#33
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/integration.rb#21
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/action_mailer/integration.rb#29
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/integration.rb#25
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_mailer/integration.rb#16
Datadog::Tracing::Contrib::ActionMailer::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'action_mailer' module.
#
# source://datadog//lib/datadog/tracing/contrib/action_mailer/patcher.rb#12
module Datadog::Tracing::Contrib::ActionMailer::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/action_mailer/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_mailer/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/action_mailer/patcher.rb#17
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#6
module Datadog::Tracing::Contrib::ActionPack; end

# source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#16
module Datadog::Tracing::Contrib::ActionPack::ActionController; end

# Instrumentation for ActionController components
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#18
module Datadog::Tracing::Contrib::ActionPack::ActionController::Instrumentation
  private

  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#50
  def finish_processing(payload); end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#21
  def start_processing(payload); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#50
    def finish_processing(payload); end

    # source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#21
    def start_processing(payload); end
  end
end

# Instrumentation for ActionController::Metal
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#96
module Datadog::Tracing::Contrib::ActionPack::ActionController::Instrumentation::Metal
  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#142
  def datadog_response_status; end

  # TODO: Refactor this method to avoid using async API that splits the logic
  # into two different methods (`start_processing` and `finish_processing`)
  #
  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#99
  def process_action(*args); end
end

# Patcher for ActionController components
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#12
module Datadog::Tracing::Contrib::ActionPack::ActionController::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#17
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#9
module Datadog::Tracing::Contrib::ActionPack::ActionDispatch; end

# Instrumentation for ActionDispatch components
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#11
module Datadog::Tracing::Contrib::ActionPack::ActionDispatch::Instrumentation
  private

  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#32
  def dispatcher_route?(route); end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#17
  def set_http_route_tags(route_spec, route_path); end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#32
    def dispatcher_route?(route); end

    # source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#17
    def set_http_route_tags(route_spec, route_path); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#13
Datadog::Tracing::Contrib::ActionPack::ActionDispatch::Instrumentation::FORMAT_SUFFIX = T.let(T.unsafe(nil), String)

# Instrumentation for ActionDispatch::Journey components
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#42
module Datadog::Tracing::Contrib::ActionPack::ActionDispatch::Instrumentation::Journey; end

# Since Rails 7.1 `Router#find_routes` makes the route computation lazy
# https://github.com/rails/rails/commit/35b280fcc2d5d474f9f2be3aca3ae7aa6bba66eb
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#65
module Datadog::Tracing::Contrib::ActionPack::ActionDispatch::Instrumentation::Journey::LazyRouter
  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#66
  def find_routes(req); end
end

# Instrumentation for ActionDispatch::Journey::Router for Rails versions older than 7.1
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#44
module Datadog::Tracing::Contrib::ActionPack::ActionDispatch::Instrumentation::Journey::Router
  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#45
  def find_routes(req); end
end

# source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/instrumentation.rb#12
Datadog::Tracing::Contrib::ActionPack::ActionDispatch::Instrumentation::SCRIPT_NAME_KEY = T.let(T.unsafe(nil), String)

# Patcher for ActionController components
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/patcher.rb#12
module Datadog::Tracing::Contrib::ActionPack::ActionDispatch::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/action_pack/action_dispatch/patcher.rb#17
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#12
module Datadog::Tracing::Contrib::ActionPack::Configuration; end

# Custom settings for the ActionPack integration
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#15
class Datadog::Tracing::Contrib::ActionPack::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#23
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#23
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#28
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#28
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#34
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#34
  def service_name=(value); end
end

# ActionPack integration constants
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#9
module Datadog::Tracing::Contrib::ActionPack::Ext; end

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#12
Datadog::Tracing::Contrib::ActionPack::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#13
Datadog::Tracing::Contrib::ActionPack::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#10
Datadog::Tracing::Contrib::ActionPack::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#14
Datadog::Tracing::Contrib::ActionPack::Ext::SPAN_ACTION_CONTROLLER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#15
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#19
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_DB_RUNTIME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#16
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_OPERATION_CONTROLLER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#17
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_ROUTE_ACTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#18
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_ROUTE_CONTROLLER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_pack/ext.rb#20
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_VIEW_RUNTIME = T.let(T.unsafe(nil), String)

# Describes the ActionPack integration
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/integration.rb#14
class Datadog::Tracing::Contrib::ActionPack::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/action_pack/integration.rb#39
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/integration.rb#43
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/integration.rb#47
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/action_pack/integration.rb#33
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/action_pack/integration.rb#21
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/action_pack/integration.rb#29
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/action_pack/integration.rb#25
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_pack/integration.rb#17
Datadog::Tracing::Contrib::ActionPack::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'action_pack' module.
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/patcher.rb#12
module Datadog::Tracing::Contrib::ActionPack::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_pack/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/action_pack/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_pack/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/action_pack/patcher.rb#17
    def target_version; end
  end
end

# Common utilities for ActionPack
#
# source://datadog//lib/datadog/tracing/contrib/action_pack/utils.rb#10
module Datadog::Tracing::Contrib::ActionPack::Utils
  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/action_pack/utils.rb#11
    def exception_is_error?(exception); end

    # source://datadog//lib/datadog/tracing/contrib/action_pack/utils.rb#23
    def set_analytics_sample_rate(span); end

    private

    # source://datadog//lib/datadog/tracing/contrib/action_pack/utils.rb#32
    def datadog_configuration; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#6
module Datadog::Tracing::Contrib::ActionView; end

# source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActionView::Configuration; end

# Custom settings for the ActionView integration
#
# source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActionView::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#33
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#34
  def template_base_path; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#34
  def template_base_path=(value); end
end

# Defines basic behavior for an ActionView event.
#
# source://datadog//lib/datadog/tracing/contrib/action_view/event.rb#10
module Datadog::Tracing::Contrib::ActionView::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionView::Event::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/action_view/event.rb#11
    def included(base); end
  end
end

# Class methods for ActionView events.
#
# source://datadog//lib/datadog/tracing/contrib/action_view/event.rb#17
module Datadog::Tracing::Contrib::ActionView::Event::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/action_view/event.rb#18
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/event.rb#22
  def record_exception(span, payload); end
end

# Defines collection of instrumented ActionView events
#
# source://datadog//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#13
module Datadog::Tracing::Contrib::ActionView::Events
  private

  # source://datadog//lib/datadog/tracing/contrib/action_view/events.rb#19
  def all; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/events.rb#27
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/events.rb#23
  def subscriptions; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_view/events.rb#19
    def all; end

    # source://datadog//lib/datadog/tracing/contrib/action_view/events.rb#27
    def subscribe!; end

    # source://datadog//lib/datadog/tracing/contrib/action_view/events.rb#23
    def subscriptions; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_view/events.rb#12
Datadog::Tracing::Contrib::ActionView::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for render_partial.action_view event
#
# source://datadog//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#15
module Datadog::Tracing::Contrib::ActionView::Events::RenderPartial
  include ::Datadog::Tracing::Contrib::ActionView::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionView::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#22
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#30
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#26
  def span_name; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#22
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#30
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#26
    def span_name; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#18
Datadog::Tracing::Contrib::ActionView::Events::RenderPartial::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for render_template.action_view event
#
# source://datadog//lib/datadog/tracing/contrib/action_view/events/render_template.rb#15
module Datadog::Tracing::Contrib::ActionView::Events::RenderTemplate
  include ::Datadog::Tracing::Contrib::ActionView::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionView::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_template.rb#22
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_template.rb#30
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_template.rb#26
  def span_name; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_template.rb#22
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_template.rb#30
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/action_view/events/render_template.rb#26
    def span_name; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_view/events/render_template.rb#18
Datadog::Tracing::Contrib::ActionView::Events::RenderTemplate::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActionView integration constants
#
# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#9
module Datadog::Tracing::Contrib::ActionView::Ext; end

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#12
Datadog::Tracing::Contrib::ActionView::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#13
Datadog::Tracing::Contrib::ActionView::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#10
Datadog::Tracing::Contrib::ActionView::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#14
Datadog::Tracing::Contrib::ActionView::Ext::SPAN_RENDER_PARTIAL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#15
Datadog::Tracing::Contrib::ActionView::Ext::SPAN_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#16
Datadog::Tracing::Contrib::ActionView::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#17
Datadog::Tracing::Contrib::ActionView::Ext::TAG_LAYOUT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#18
Datadog::Tracing::Contrib::ActionView::Ext::TAG_OPERATION_RENDER_PARTIAL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#19
Datadog::Tracing::Contrib::ActionView::Ext::TAG_OPERATION_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/action_view/ext.rb#20
Datadog::Tracing::Contrib::ActionView::Ext::TAG_TEMPLATE_NAME = T.let(T.unsafe(nil), String)

# Describes the ActionView integration
#
# source://datadog//lib/datadog/tracing/contrib/action_view/integration.rb#14
class Datadog::Tracing::Contrib::ActionView::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/action_view/integration.rb#46
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/integration.rb#50
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/integration.rb#54
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/action_view/integration.rb#40
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/action_view/integration.rb#21
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/action_view/integration.rb#36
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/action_view/integration.rb#25
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/action_view/integration.rb#17
Datadog::Tracing::Contrib::ActionView::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of ActionView module.
#
# source://datadog//lib/datadog/tracing/contrib/action_view/patcher.rb#14
module Datadog::Tracing::Contrib::ActionView::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/action_view/patcher.rb#23
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/patcher.rb#27
  def patch_renderer; end

  # source://datadog//lib/datadog/tracing/contrib/action_view/patcher.rb#19
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/action_view/patcher.rb#23
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/action_view/patcher.rb#27
    def patch_renderer; end

    # source://datadog//lib/datadog/tracing/contrib/action_view/patcher.rb#19
    def target_version; end
  end
end

# common utilities for Rails
#
# source://datadog//lib/datadog/tracing/contrib/action_view/utils.rb#10
module Datadog::Tracing::Contrib::ActionView::Utils
  private

  # in Rails the template name includes the template full path
  # and it's better to avoid storing such information. This method
  # returns the relative path from `views/` or the template name
  # if a `views/` folder is not in the template full path. A wrong
  # usage ensures that this method will not crash the tracing system.
  #
  # source://datadog//lib/datadog/tracing/contrib/action_view/utils.rb#18
  def normalize_template_name(name); end

  class << self
    # in Rails the template name includes the template full path
    # and it's better to avoid storing such information. This method
    # returns the relative path from `views/` or the template name
    # if a `views/` folder is not in the template full path. A wrong
    # usage ensures that this method will not crash the tracing system.
    #
    # source://datadog//lib/datadog/tracing/contrib/action_view/utils.rb#18
    def normalize_template_name(name); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#6
module Datadog::Tracing::Contrib::ActiveJob; end

# source://datadog//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActiveJob::Configuration; end

# Custom settings for the DelayedJob integration
#
# source://datadog//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActiveJob::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#33
  def service_name=(value); end
end

# Defines basic behaviors for an ActiveJob event.
#
# source://datadog//lib/datadog/tracing/contrib/active_job/event.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/active_job/event.rb#13
    def included(base); end
  end
end

# Class methods for ActiveJob events.
#
# source://datadog//lib/datadog/tracing/contrib/active_job/event.rb#19
module Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/active_job/event.rb#26
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/event.rb#30
  def set_common_tags(span, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_job/event.rb#20
  def span_options; end
end

# Defines collection of instrumented ActiveJob events
#
# source://datadog//lib/datadog/tracing/contrib/active_job/events/discard.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Events
  private

  # source://datadog//lib/datadog/tracing/contrib/active_job/events.rb#27
  def all; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events.rb#35
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events.rb#31
  def subscriptions; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_job/events.rb#27
    def all; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events.rb#35
    def subscribe!; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events.rb#31
    def subscriptions; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_job/events.rb#16
Datadog::Tracing::Contrib::ActiveJob::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for discard.active_job event
#
# source://datadog//lib/datadog/tracing/contrib/active_job/events/discard.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::Discard
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/discard.rb#21
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/discard.rb#29
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/discard.rb#25
  def span_name; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_job/events/discard.rb#21
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/discard.rb#29
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/discard.rb#25
    def span_name; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_job/events/discard.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::Discard::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for enqueue.active_job event
#
# source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::Enqueue
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#21
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#29
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#25
  def span_name; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#21
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#29
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#25
    def span_name; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::Enqueue::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for enqueue_at.active_job event
#
# source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueAt
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#21
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#29
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#25
  def span_name; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#21
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#29
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#25
    def span_name; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueAt::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for enqueue_retry.active_job event
#
# source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueRetry
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#21
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#29
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#25
  def span_name; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#21
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#29
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#25
    def span_name; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueRetry::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for perform.active_job event
#
# source://datadog//lib/datadog/tracing/contrib/active_job/events/perform.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::Perform
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/perform.rb#21
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/perform.rb#29
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/perform.rb#25
  def span_name; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_job/events/perform.rb#21
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/perform.rb#29
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/perform.rb#25
    def span_name; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_job/events/perform.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::Perform::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for retry_stopped.active_job event
#
# source://datadog//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::RetryStopped
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#21
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#29
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#25
  def span_name; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#21
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#29
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#25
    def span_name; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::RetryStopped::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#8
module Datadog::Tracing::Contrib::ActiveJob::Ext; end

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#11
Datadog::Tracing::Contrib::ActiveJob::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#12
Datadog::Tracing::Contrib::ActiveJob::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#9
Datadog::Tracing::Contrib::ActiveJob::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#14
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_DISCARD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#15
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_ENQUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#16
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_ENQUEUE_RETRY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#17
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_PERFORM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#18
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_RETRY_STOPPED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#28
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_ADAPTER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#20
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#29
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_ERROR = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#30
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_EXECUTIONS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#31
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#32
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_PRIORITY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#33
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#34
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_RETRY_WAIT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#35
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_SCHEDULED_AT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#21
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_DISCARD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#22
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_ENQUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#23
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_ENQUEUE_AT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#24
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_ENQUEUE_RETRY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#25
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_PERFORM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_job/ext.rb#26
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_RETRY_STOPPED = T.let(T.unsafe(nil), String)

# Describes the ActiveJob integration
#
# source://datadog//lib/datadog/tracing/contrib/active_job/integration.rb#13
class Datadog::Tracing::Contrib::ActiveJob::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/active_job/integration.rb#38
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/integration.rb#42
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/integration.rb#46
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_job/integration.rb#32
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/integration.rb#20
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_job/integration.rb#28
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/integration.rb#24
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_job/integration.rb#16
Datadog::Tracing::Contrib::ActiveJob::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Active Job log injection wrapped around job execution
#
# source://datadog//lib/datadog/tracing/contrib/active_job/log_injection.rb#8
module Datadog::Tracing::Contrib::ActiveJob::LogInjection
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/active_job/log_injection.rb#9
    def included(base); end
  end
end

# Patcher enables patching of 'active_job' module.
#
# source://datadog//lib/datadog/tracing/contrib/active_job/patcher.rb#13
module Datadog::Tracing::Contrib::ActiveJob::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_job/patcher.rb#27
  def inject_log_correlation; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/active_job/patcher.rb#18
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_job/patcher.rb#27
    def inject_log_correlation; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/patcher.rb#22
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/active_job/patcher.rb#18
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#6
module Datadog::Tracing::Contrib::ActiveModelSerializers; end

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActiveModelSerializers::Configuration; end

# Custom settings for the ActiveModelSerializers integration
#
# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActiveModelSerializers::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#14
  def enabled=(value); end
end

# Defines basic behaviors for an ActiveModelSerializers event.
#
# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/event.rb#13
module Datadog::Tracing::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/event.rb#14
    def included(base); end
  end
end

# Class methods for ActiveModelSerializers events.
# Note, they share the same process method and before_trace method.
#
# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/event.rb#21
module Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/event.rb#26
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/event.rb#30
  def set_common_tags(span, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/event.rb#22
  def span_options; end

  private

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/event.rb#54
  def resource(serializer); end
end

# Defines collection of instrumented ActiveModelSerializers events
#
# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#11
module Datadog::Tracing::Contrib::ActiveModelSerializers::Events
  private

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events.rb#19
  def all; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events.rb#27
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events.rb#23
  def subscriptions; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events.rb#19
    def all; end

    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events.rb#27
    def subscribe!; end

    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events.rb#23
    def subscriptions; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events.rb#12
Datadog::Tracing::Contrib::ActiveModelSerializers::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for render.active_model_serializers event
#
# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#13
module Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Render
  include ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#25
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#33
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#29
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#20
  def supported?; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#25
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#33
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#29
    def span_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#20
    def supported?; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#16
Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Render::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for !serialize.active_model_serializers event
#
# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#12
module Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Serialize
  include ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#27
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#35
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#31
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#19
  def supported?; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#27
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#35
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#31
    def span_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#19
    def supported?; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#15
Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Serialize::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActiveModelSerializers integration constants
#
# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#9
module Datadog::Tracing::Contrib::ActiveModelSerializers::Ext; end

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#12
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#13
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#10
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#14
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::SPAN_RENDER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#15
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::SPAN_SERIALIZE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#16
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_ADAPTER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#17
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#18
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_OPERATION_RENDER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#19
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_OPERATION_SERIALIZE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#20
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_SERIALIZER = T.let(T.unsafe(nil), String)

# Description of ActiveModelSerializers integration
#
# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#12
class Datadog::Tracing::Contrib::ActiveModelSerializers::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#15
Datadog::Tracing::Contrib::ActiveModelSerializers::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'active_model_serializers' module.
#
# source://datadog//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#12
module Datadog::Tracing::Contrib::ActiveModelSerializers::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#25
  def get_option(option); end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#25
    def get_option(option); end

    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#17
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#6
module Datadog::Tracing::Contrib::ActiveRecord; end

# source://datadog//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#7
module Datadog::Tracing::Contrib::ActiveRecord::Configuration; end

# The `makara` gem has the concept of **role**, which can be
# inferred from the configuration `name`, in the form of:
# `master/0`, `replica/0`, `replica/1`, etc.
# The first part of this string is the database role.
#
# This allows the matching of a connection based on its role,
# instead of connection-specific information.
#
# source://datadog//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#15
module Datadog::Tracing::Contrib::ActiveRecord::Configuration::MakaraResolver
  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#16
  def normalize_for_config(active_record_config); end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#22
  def normalize_for_resolve(active_record_config); end
end

# Converts Symbols, Strings, and Hashes to a normalized connection settings Hash.
#
# When matching using a Hash, these are the valid fields:
# ```
# {
#   adapter: ...,
#   host: ...,
#   port: ...,
#   database: ...,
#   username: ...,
#   role: ...,
# }
# ```
#
# Partial matching is supported: not including certain fields or setting them to `nil`
# will cause them to matching all values for that field. For example: `database: nil`
# will match any database, given the remaining fields match.
#
# Any fields not listed above are discarded.
#
# When more than one configuration could be matched, the last one to match is selected,
# based on addition order (`#add`).
#
# source://datadog//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#34
class Datadog::Tracing::Contrib::ActiveRecord::Configuration::Resolver < ::Datadog::Tracing::Contrib::Configuration::Resolver
  include ::Datadog::Tracing::Contrib::ActiveRecord::Configuration::MakaraResolver
  include ::Datadog::Tracing::Contrib::Configuration::CachingResolver

  # @return [Resolver] a new instance of Resolver
  #
  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#38
  def initialize(*args, cache_limit: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#44
  def active_record_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#48
  def add(matcher, value); end

  # Extract only fields we'd like to match
  # from the ActiveRecord configuration.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#135
  def normalize_for_config(active_record_config); end

  # Extract only fields we'd like to match
  # from the ActiveRecord configuration.
  # Both resolvers perform the same operations for this implementation, but can be specialized
  #
  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#146
  def normalize_for_resolve(active_record_config); end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#57
  def resolve(value); end

  protected

  # `::ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver` exists from 4+ til from 6.0.x
  #
  # `::ActiveRecord::DatabaseConfigurations` was introduced from 6+,
  # but from 6.1.x, it was refactored to encapsulates the resolving logic, hence removing the resolver
  #
  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#112
  def connection_resolver; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#88
  def parse_matcher(matcher); end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#123
  def resolve_connection_key(key); end
end

# Custom settings for the ActiveRecord integration
#
# source://datadog//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#14
class Datadog::Tracing::Contrib::ActiveRecord::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#22
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#22
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#28
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#28
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#15
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#15
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#34
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#34
  def service_name=(value); end
end

# Defines basic behaviors for an ActiveRecord event.
#
# source://datadog//lib/datadog/tracing/contrib/active_record/event.rb#10
module Datadog::Tracing::Contrib::ActiveRecord::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/active_record/event.rb#11
    def included(base); end
  end
end

# Class methods for ActiveRecord events.
#
# source://datadog//lib/datadog/tracing/contrib/active_record/event.rb#17
module Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/active_record/event.rb#22
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/event.rb#18
  def span_options; end
end

# Defines collection of instrumented ActiveRecord events
#
# source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#13
module Datadog::Tracing::Contrib::ActiveRecord::Events
  private

  # source://datadog//lib/datadog/tracing/contrib/active_record/events.rb#19
  def all; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/events.rb#27
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/events.rb#23
  def subscriptions; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_record/events.rb#19
    def all; end

    # source://datadog//lib/datadog/tracing/contrib/active_record/events.rb#27
    def subscribe!; end

    # source://datadog//lib/datadog/tracing/contrib/active_record/events.rb#23
    def subscriptions; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_record/events.rb#12
Datadog::Tracing::Contrib::ActiveRecord::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for instantiation.active_record event
#
# source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#15
module Datadog::Tracing::Contrib::ActiveRecord::Events::Instantiation
  include ::Datadog::Tracing::Contrib::ActiveRecord::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#27
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#35
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#31
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#22
  def supported?; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#27
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#35
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#31
    def span_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#22
    def supported?; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#18
Datadog::Tracing::Contrib::ActiveRecord::Events::Instantiation::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for sql.active_record event
#
# source://datadog//lib/datadog/tracing/contrib/active_record/events/sql.rb#17
module Datadog::Tracing::Contrib::ActiveRecord::Events::SQL
  include ::Datadog::Tracing::Contrib::ActiveRecord::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_record/events/sql.rb#25
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/events/sql.rb#33
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_record/events/sql.rb#29
  def span_name; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_record/events/sql.rb#25
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_record/events/sql.rb#33
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_record/events/sql.rb#29
    def span_name; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_record/events/sql.rb#20
Datadog::Tracing::Contrib::ActiveRecord::Events::SQL::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/events/sql.rb#21
Datadog::Tracing::Contrib::ActiveRecord::Events::SQL::PAYLOAD_CACHE = T.let(T.unsafe(nil), String)

# ActiveRecord integration constants
#
# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#9
module Datadog::Tracing::Contrib::ActiveRecord::Ext; end

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#12
Datadog::Tracing::Contrib::ActiveRecord::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#13
Datadog::Tracing::Contrib::ActiveRecord::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#10
Datadog::Tracing::Contrib::ActiveRecord::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#14
Datadog::Tracing::Contrib::ActiveRecord::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#15
Datadog::Tracing::Contrib::ActiveRecord::Ext::SPAN_INSTANTIATION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#16
Datadog::Tracing::Contrib::ActiveRecord::Ext::SPAN_SQL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#17
Datadog::Tracing::Contrib::ActiveRecord::Ext::SPAN_TYPE_INSTANTIATION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#18
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#21
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_DB_CACHED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#22
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_DB_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#23
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_DB_VENDOR = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#24
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_INSTANTIATION_CLASS_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#25
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_INSTANTIATION_RECORD_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#19
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_OPERATION_INSTANTIATION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_record/ext.rb#20
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_OPERATION_SQL = T.let(T.unsafe(nil), String)

# Describes the ActiveRecord integration
#
# source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#17
class Datadog::Tracing::Contrib::ActiveRecord::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#43
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#47
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#51
  def patcher; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#59
  def reset_resolver_cache; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#55
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#37
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#25
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#33
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#29
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_record/integration.rb#20
Datadog::Tracing::Contrib::ActiveRecord::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'active_record' module.
#
# source://datadog//lib/datadog/tracing/contrib/active_record/patcher.rb#11
module Datadog::Tracing::Contrib::ActiveRecord::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_record/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/active_record/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_record/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/active_record/patcher.rb#16
    def target_version; end
  end
end

# Common utilities for Rails
#
# source://datadog//lib/datadog/tracing/contrib/active_record/utils.rb#11
module Datadog::Tracing::Contrib::ActiveRecord::Utils
  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_record/utils.rb#22
    def adapter_host; end

    # source://datadog//lib/datadog/tracing/contrib/active_record/utils.rb#14
    def adapter_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_record/utils.rb#26
    def adapter_port; end

    # Returns the connection configuration hash from the
    # current connection
    #
    # Since Rails 6.0, we have direct access to the object,
    # while older versions of Rails only provide us the
    # connection id.
    #
    # @see https://github.com/rails/rails/pull/34602
    #
    # source://datadog//lib/datadog/tracing/contrib/active_record/utils.rb#38
    def connection_config(connection = T.unsafe(nil), connection_id = T.unsafe(nil)); end

    # JRuby does not enable {ObjectSpace._id2ref} by default,
    # as it has large performance impact:
    # https://github.com/jruby/jruby/wiki/PerformanceTuning/cf155dd9#dont-enable-objectspace
    #
    # This fallback code does not support the makara gem,
    # as its connections don't live in the ActiveRecord
    # connection pool.
    #
    # source://datadog//lib/datadog/tracing/contrib/active_record/utils.rb#64
    def connection_from_id(connection_id); end

    # source://datadog//lib/datadog/tracing/contrib/active_record/utils.rb#18
    def database_name; end

    # @return [Hash]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_record/utils.rb#117
    def db_config(connection_pool); end

    # @return [Hash]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_record/utils.rb#101
    def default_connection_config; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_record/utils.rb#12
Datadog::Tracing::Contrib::ActiveRecord::Utils::EMPTY_CONFIG = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#6
module Datadog::Tracing::Contrib::ActiveSupport; end

# source://datadog//lib/datadog/tracing/contrib/active_support/cache/event.rb#9
module Datadog::Tracing::Contrib::ActiveSupport::Cache; end

# Defines basic behaviors for an ActiveSupport event.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/event.rb#11
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Cache::Event::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/event.rb#12
    def included(base); end
  end
end

# Class methods for ActiveRecord events.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/event.rb#18
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Event::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/event.rb#23
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/event.rb#19
  def span_options; end
end

# Defines collection of instrumented ActiveSupport events
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#12
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Events
  private

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events.rb#18
  def all; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events.rb#26
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events.rb#22
  def subscriptions; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events.rb#18
    def all; end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events.rb#26
    def subscribe!; end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events.rb#22
    def subscriptions; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_support/cache/events.rb#12
Datadog::Tracing::Contrib::ActiveSupport::Cache::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for instantiation.active_record event
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#14
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Events::Cache
  include ::Datadog::Tracing::Contrib::ActiveSupport::Cache::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Cache::Event::ClassMethods

  private

  # The name of the `store` is never saved by Rails.
  # ActiveSupport looks up stores by converting a symbol into a 'require' path,
  # then "camelizing" it for a `const_get` call:
  # ```
  # require "active_support/cache/#{store}"
  # ActiveSupport::Cache.const_get(store.to_s.camelize)
  # ```
  # We can reverse engineer
  # the original symbol by converting the class name to snake case:
  # e.g. ActiveSupport::Cache::RedisStore -> active_support/cache/redis_store
  # In this case, `redis_store` is the store name.
  #
  # Because there's no API retrieve only the class name
  # (only `RedisStore`, and not `ActiveSupport::Cache::RedisStore`)
  # the easiest way to retrieve the store symbol is to convert the fully qualified
  # name using the Rails-provided method `#underscore`, which is the reverse of `#camelize`,
  # then extracting the last part of it.
  #
  # Also, this method caches the store name, given this value will be retrieve
  # multiple times and involves string manipulation.
  #
  # @see https://github.com/rails/rails/blob/261975dbef77731d2c76f907f1076c5132ebc0e4/activesupport/lib/active_support/cache.rb#L139-L149
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#136
  def cache_backend(store); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#25
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#70
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#101
  def set_cache_key(span, key, multi_key); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#29
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#33
  def span_options; end

  # Acts as this module's initializer.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#20
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#48
  def trace?(event, payload); end

  class << self
    # The name of the `store` is never saved by Rails.
    # ActiveSupport looks up stores by converting a symbol into a 'require' path,
    # then "camelizing" it for a `const_get` call:
    # ```
    # require "active_support/cache/#{store}"
    # ActiveSupport::Cache.const_get(store.to_s.camelize)
    # ```
    # We can reverse engineer
    # the original symbol by converting the class name to snake case:
    # e.g. ActiveSupport::Cache::RedisStore -> active_support/cache/redis_store
    # In this case, `redis_store` is the store name.
    #
    # Because there's no API retrieve only the class name
    # (only `RedisStore`, and not `ActiveSupport::Cache::RedisStore`)
    # the easiest way to retrieve the store symbol is to convert the fully qualified
    # name using the Rails-provided method `#underscore`, which is the reverse of `#camelize`,
    # then extracting the last part of it.
    #
    # Also, this method caches the store name, given this value will be retrieve
    # multiple times and involves string manipulation.
    #
    # @see https://github.com/rails/rails/blob/261975dbef77731d2c76f907f1076c5132ebc0e4/activesupport/lib/active_support/cache.rb#L139-L149
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#136
    def cache_backend(store); end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#25
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#70
    def on_start(span, event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#101
    def set_cache_key(span, key, multi_key); end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#29
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#33
    def span_options; end

    # Acts as this module's initializer.
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#20
    def subscribe!; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#48
    def trace?(event, payload); end
  end
end

# DEV: Look for other uses of `ActiveSupport::Cache::Store#instrument`, to find other useful event keys.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/events/cache.rb#40
Datadog::Tracing::Contrib::ActiveSupport::Cache::Events::Cache::MAPPING = T.let(T.unsafe(nil), Hash)

# DEV-3.0: Backwards compatibility code for the 2.x gem series.
# DEV-3.0:
# DEV-3.0: `ActiveSupport::Cache` is now instrumented by subscribing to ActiveSupport::Notifications events.
# DEV-3.0: The implementation is located at {Datadog::Tracing::Contrib::ActiveSupport::Cache::Events::Cache}.
# DEV-3.0: The events emitted provide richer introspection points (e.g. events for cache misses on `#fetch`) while
# DEV-3.0: also ensuring we are using Rails' public API for improved compatibility.
# DEV-3.0:
# DEV-3.0: But a few operations holds us back:
# DEV-3.0: 1. `ActiveSupport::Cache::Store#fetch`:
# DEV-3.0:   This method does not have an event that can produce an equivalent span to today's 2.x implementation.
# DEV-3.0:   In 2.x, `#fetch` produces two separate, *nested* spans: one for the `#read` operation and
# DEV-3.0:   another for the `#write` operation that is called internally by `#fetch` when the cache key needs
# DEV-3.0:   to be populated on a cache miss.
# DEV-3.0:   But the ActiveSupport events emitted by `#fetch` provide two *sibling* events for the`#read` and
# DEV-3.0:   `#write` operations.
# DEV-3.0:   Moving from nested spans to sibling spans would be a breaking change. One notable difference is
# DEV-3.0:   that if the nested `#write` operation fails 2.x, the `#read` span is marked as an error. This would
# DEV-3.0:   not be the case with sibling spans, and would be a very visible change.
# DEV-3.0: 2. `ActiveSupport::Cache::Store#read_multi` & `ActiveSupport::Cache::Store#fetch_multi`:
# DEV-3.0:   ActiveSupport events were introduced in ActiveSupport 5.2.0 for these methods.
# DEV-3.0:
# DEV-3.0: At the end of the day, moving to ActiveSupport events is the better approach, but we have to retain
# DEV-3.0: this last few monkey patches (and all the supporting code) to avoid a breaking change for now.
#
# Defines the deprecate  monkey-patch instrumentation for `ActiveSupport::Cache::Store#fetch`
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#38
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation
  private

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#99
  def enabled?; end

  # In most of the cases, `#fetch()` and `#read()` calls are nested.
  # Instrument both does not add any value.
  # This method checks if these two operations are nested.
  #
  # DEV-3.0: We should not have these checks in the 3.x series because ActiveSupport events provide more
  # DEV-3.0: legible nested spans. While using ActiveSupport events, the nested spans actually provide meaningful
  # DEV-3.0: information.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#82
  def nested_multiread?; end

  # In most of the cases, `#fetch()` and `#read()` calls are nested.
  # Instrument both does not add any value.
  # This method checks if these two operations are nested.
  #
  # DEV-3.0: We should not have these checks in the 3.x series because ActiveSupport events provide more
  # DEV-3.0: legible nested spans. While using ActiveSupport events, the nested spans actually provide meaningful
  # DEV-3.0: information.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#76
  def nested_read?; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#87
  def set_cache_key(span, single_key, multi_key); end

  # @param action [String] type of cache operation. Will be set as the span resource.
  # @param key [Object] redis cache key. Used for actions with a single key locator.
  # @param multi_key [Array<Object>] list of redis cache keys. Used for actions with a multiple key locators.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#44
  def trace(action, store, key: T.unsafe(nil), multi_key: T.unsafe(nil)); end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#99
    def enabled?; end

    # In most of the cases, `#fetch()` and `#read()` calls are nested.
    # Instrument both does not add any value.
    # This method checks if these two operations are nested.
    #
    # DEV-3.0: We should not have these checks in the 3.x series because ActiveSupport events provide more
    # DEV-3.0: legible nested spans. While using ActiveSupport events, the nested spans actually provide meaningful
    # DEV-3.0: information.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#82
    def nested_multiread?; end

    # In most of the cases, `#fetch()` and `#read()` calls are nested.
    # Instrument both does not add any value.
    # This method checks if these two operations are nested.
    #
    # DEV-3.0: We should not have these checks in the 3.x series because ActiveSupport events provide more
    # DEV-3.0: legible nested spans. While using ActiveSupport events, the nested spans actually provide meaningful
    # DEV-3.0: information.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#76
    def nested_read?; end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#87
    def set_cache_key(span, single_key, multi_key); end

    # @param action [String] type of cache operation. Will be set as the span resource.
    # @param key [Object] redis cache key. Used for actions with a single key locator.
    # @param multi_key [Array<Object>] list of redis cache keys. Used for actions with a multiple key locators.
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#44
    def trace(action, store, key: T.unsafe(nil), multi_key: T.unsafe(nil)); end
  end
end

# Defines the the legacy monkey-patching instrumentation for ActiveSupport cache fetch
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#154
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::Fetch
  include ::Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::InstanceMethods

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#157
  def fetch(*args, &block); end
end

# Defines the the legacy monkey-patching instrumentation for ActiveSupport cache fetch_multi
# DEV-3.0: ActiveSupport::Notifications events were introduced in ActiveSupport 5.2.0 for this method.
# DEV-3.0: As long as we support ActiveSupport < 5.2.0, we have to keep this method.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#167
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::FetchMulti
  include ::Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::InstanceMethods

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#170
  def fetch_multi(*args, **options, &block); end
end

# Instance methods injected into the cache client
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#104
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::InstanceMethods
  private

  # The name of the store is never saved.
  # ActiveSupport looks up stores by converting a symbol into a 'require' path,
  # then "camelizing" it for a `const_get` call:
  # ```
  # require "active_support/cache/#{store}"
  # ActiveSupport::Cache.const_get(store.to_s.camelize)
  # ```
  # As `self` is the store object, we can reverse engineer
  # the original symbol by converting the class name to snake case:
  # e.g. ActiveSupport::Cache::RedisStore -> active_support/cache/redis_store
  # In this case, `redis_store` is the store name.
  #
  # Because there's no API retrieve only the class name
  # (only `RedisStore`, and not `ActiveSupport::Cache::RedisStore`)
  # the easiest way to retrieve the store symbol is to convert the fully qualified
  # name using the Rails-provided method `#underscore`, which is the reverse of `#camelize`,
  # then extracting the last part of it.
  #
  # Also, this method caches the store name, given this value will be retrieve
  # multiple times and involves string manipulation.
  #
  # @see https://github.com/rails/rails/blob/261975dbef77731d2c76f907f1076c5132ebc0e4/activesupport/lib/active_support/cache.rb#L139-L149
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#129
  def dd_store_name; end
end

# Save the original, user-supplied cache key, before it gets normalized.
#
# Normalized keys can include internal implementation detail,
# for example FileStore keys include temp directory names, which
# changes on every run, making it impossible to group by the cache key afterward.
# Also, the user is never exposed to the normalized key, and only sets/gets using the
# original key.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#195
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::PreserveOriginalKey
  # Ensure we don't pollute the default Store instance `options` in {PreserveOriginalKey#normalize_key}.
  # In most cases, `merged_options` returns a new hash,
  # but we check for cases where it reuses the instance hash.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#210
  def merged_options(call_options); end

  # Stores the original keys in the options hash, as an array of keys.
  # It's important to keep all the keys for multi-key operations.
  # For single-key operations, the key is stored as an array of a single element.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#199
  def normalize_key(key, options); end
end

# Defines the the legacy monkey-patching instrumentation for ActiveSupport cache read_multi
# DEV-3.0: ActiveSupport::Notifications events were introduced in ActiveSupport 5.2.0 for this method.
# DEV-3.0: As long as we support ActiveSupport < 5.2.0, we have to keep this method.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#143
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::ReadMulti
  include ::Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::InstanceMethods

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#146
  def read_multi(*keys, **options, &block); end
end

# Backports the payload[:store] key present since Rails 6.1:
# https://github.com/rails/rails/commit/6fa747f2946ee244b2aab0cd8c3c064f05d950a5
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#180
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::Store
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#181
  def instrument(operation, key, options = T.unsafe(nil)); end
end

# Patcher enables patching of 'active_support' module.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#13
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Cache::Redis::Patcher

  private

  # This method is overwritten by
  # `datadog/tracing/contrib/active_support/cache/redis.rb`
  # with more complex behavior.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#43
  def cache_store_class(meth); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#47
  def patch_legacy_cache_store; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#18
  def target_version; end

  class << self
    # This method is overwritten by
    # `datadog/tracing/contrib/active_support/cache/redis.rb`
    # with more complex behavior.
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#43
    def cache_store_class(meth); end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#22
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#47
    def patch_legacy_cache_store; end

    # source://datadog//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#18
    def target_version; end
  end
end

# Support for Redis with ActiveSupport
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/redis.rb#12
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Redis; end

# Patching behavior for Redis with ActiveSupport
#
# source://datadog//lib/datadog/tracing/contrib/active_support/cache/redis.rb#14
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Redis::Patcher
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/redis.rb#42
  def cache_store_class(meth); end

  # Patches the Rails built-in Redis cache backend `redis_cache_store`, added in Rails 5.2.
  # We avoid loading the RedisCacheStore class, as it invokes the statement `gem "redis", ">= 4.0.1"` which
  # fails if the application is using an old version of Redis, or not using Redis at all.
  #
  # @return [Boolean]
  # @see https://github.com/rails/rails/blob/d0dcb8fa6073a0c4d42600c15e82e3bb386b27d3/activesupport/lib/active_support/cache/redis_cache_store.rb#L4
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/redis.rb#36
  def patch_redis_cache_store?(meth); end

  # For Rails < 5.2 w/ redis-activesupport...
  # When Redis is used, we can't only patch Cache::Store as it is
  # Cache::RedisStore, a sub-class of it that is used, in practice.
  # We need to do a per-method monkey patching as some of them might
  # be redefined, and some of them not. The latest version of redis-activesupport
  # redefines write but leaves untouched read and delete:
  # https://github.com/redis-store/redis-activesupport/blob/v4.1.5/lib/active_support/cache/redis_store.rb
  #
  # For Rails >= 5.2 w/o redis-activesupport...
  # ActiveSupport includes a Redis cache store internally, and does not require these overrides.
  # https://github.com/rails/rails/blob/master/activesupport/lib/active_support/cache/redis_cache_store.rb
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/cache/redis.rb#26
  def patch_redis_store?(meth); end
end

# source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActiveSupport::Configuration; end

# Custom settings for the ActiveSupport integration
#
# source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActiveSupport::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#44
  def cache_key; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#44
  def cache_key=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#33
  def cache_service; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#33
  def cache_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#58
  def cache_store; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#58
  def cache_store=(value); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#14
  def enabled=(value); end
end

# ActiveSupport integration constants
#
# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#9
module Datadog::Tracing::Contrib::ActiveSupport::Ext; end

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#12
Datadog::Tracing::Contrib::ActiveSupport::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#13
Datadog::Tracing::Contrib::ActiveSupport::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#10
Datadog::Tracing::Contrib::ActiveSupport::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#14
Datadog::Tracing::Contrib::ActiveSupport::Ext::QUANTIZE_CACHE_MAX_KEY_SIZE = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#15
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_DELETE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#16
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_GET = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#17
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_MGET = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#19
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_MSET = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#18
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_SET = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#20
Datadog::Tracing::Contrib::ActiveSupport::Ext::SERVICE_CACHE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#21
Datadog::Tracing::Contrib::ActiveSupport::Ext::SPAN_CACHE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#22
Datadog::Tracing::Contrib::ActiveSupport::Ext::SPAN_TYPE_CACHE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#23
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_CACHE_BACKEND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#24
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_CACHE_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#25
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_CACHE_KEY_MULTI = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#26
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/active_support/ext.rb#27
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_OPERATION_CACHE = T.let(T.unsafe(nil), String)

# Describes the ActiveSupport integration
#
# source://datadog//lib/datadog/tracing/contrib/active_support/integration.rb#15
class Datadog::Tracing::Contrib::ActiveSupport::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/integration.rb#40
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/integration.rb#44
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/integration.rb#48
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/integration.rb#34
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/active_support/integration.rb#22
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/integration.rb#30
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/active_support/integration.rb#26
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/active_support/integration.rb#18
Datadog::Tracing::Contrib::ActiveSupport::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#7
module Datadog::Tracing::Contrib::ActiveSupport::Notifications; end

# Defines behaviors for an ActiveSupport::Notifications event.
# Compose this into a module or class, then define
# #event_name, #span_name, and #process. You can then
# invoke Event.subscribe! to more easily subscribe to an event.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#14
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#15
    def included(base); end
  end
end

# Redefines some class behaviors for a Subscriber to make
# it a bit simpler for an Event.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#23
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#73
  def on_finish(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#70
  def on_start(_span, _event, _id, _payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#65
  def payload_exception(payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#81
  def record_exception(span, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#60
  def report_if_exception(span, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#56
  def span_options; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#39
  def subscribe(pattern = T.unsafe(nil), span_name = T.unsafe(nil), span_options = T.unsafe(nil)); end

  # Publicly exposes protected method `subscribe!`
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#25
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#29
  def subscription(span_name = T.unsafe(nil), span_options = T.unsafe(nil), on_start: T.unsafe(nil), on_finish: T.unsafe(nil), trace: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#52
  def supported?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/event.rb#77
  def trace?(_event, _payload); end
end

# For classes that listen to ActiveSupport::Notification events.
# Creates subscriptions that are wrapped with tracing.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#13
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#14
    def included(base); end
  end
end

# Class methods that are implemented in the inheriting class.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#19
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  # Returns whether subscriptions have been activated, via #subscribe!
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#26
  def subscribed?; end

  # Returns a list of subscriptions created for this class.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#21
  def subscriptions; end

  protected

  # Defines a callback for when subscribe! is called.
  # Should contain subscription setup, defined by the inheriting class.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#34
  def on_subscribe(&block); end

  # Creates a subscription and immediately activates it.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#48
  def subscribe(pattern, span_name, span_options = T.unsafe(nil), on_start: T.unsafe(nil), on_finish: T.unsafe(nil), trace: T.unsafe(nil)); end

  # Runs the on_subscribe callback once, to activate subscriptions.
  # Should be triggered by the inheriting class.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#40
  def subscribe!; end

  # Creates a subscription without activating it.
  # Subscription is added to the inheriting class' list of subscriptions.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#62
  def subscription(span_name, span_options = T.unsafe(nil), on_start: T.unsafe(nil), on_finish: T.unsafe(nil), trace: T.unsafe(nil)); end

  private

  # Returns the value of attribute on_subscribe_block.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#76
  def on_subscribe_block; end

  # Returns the value of attribute subscribed.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#76
  def subscribed; end
end

# An ActiveSupport::Notification subscription that wraps events with tracing.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#9
class Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscription
  # @param on_finish [Proc] a block to run when the event has finished processing,
  #   possibly including more information in the `payload` argument.
  # @param on_start [Proc] a block to run when the event is fired,
  #   might not include all required information in the `payload` argument.
  # @param span_name [String] the operation name for the span
  # @param span_options [Hash] span_options to pass during span creation
  # @param trace [Proc] whether to trace the event. Defaults to returning `true`.
  # @raise [ArgumentError]
  # @return [Subscription] a new instance of Subscription
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#21
  def initialize(span_name, span_options, on_start: T.unsafe(nil), on_finish: T.unsafe(nil), trace: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#46
  def after_trace(&block); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#42
  def before_trace(&block); end

  # Called by ActiveSupport on event finish
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#38
  def finish(name, id, payload); end

  # Returns the value of attribute span_name.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#10
  def span_name; end

  # Sets the attribute span_name
  #
  # @param value the value to set the attribute span_name to.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#10
  def span_name=(_arg0); end

  # Returns the value of attribute span_options.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#10
  def span_options; end

  # Sets the attribute span_options
  #
  # @param value the value to set the attribute span_options to.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#10
  def span_options=(_arg0); end

  # Called by ActiveSupport on event start
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#33
  def start(name, id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#50
  def subscribe(pattern); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#57
  def unsubscribe(pattern); end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#65
  def unsubscribe_all; end

  protected

  # Returns the value of attribute callbacks.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#74
  def callbacks; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#95
  def finish_span(name, id, payload, finish = T.unsafe(nil)); end

  # Returns the value of attribute on_finish.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#74
  def on_finish; end

  # Returns the value of attribute on_start.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#74
  def on_start; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#79
  def start_span(name, id, payload, start = T.unsafe(nil)); end

  # Pattern => ActiveSupport:Notifications::Subscribers
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#112
  def subscribers; end
end

# Wrapper for subscription callbacks
#
# source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#134
class Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscription::Callbacks
  # @return [Callbacks] a new instance of Callbacks
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#137
  def initialize; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#141
  def add(key, &block); end

  # Returns the value of attribute blocks.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#135
  def blocks; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#145
  def run(event, key, *args); end

  private

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#157
  def blocks_for(key); end
end

# Wrapper for subscription handler
#
# source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#117
class Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscription::Handler
  # @return [Handler] a new instance of Handler
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#120
  def initialize(block); end

  # Returns the value of attribute block.
  #
  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#118
  def block; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#124
  def run(span, name, id, payload); end
end

# Patcher enables patching of 'active_support' module.
#
# source://datadog//lib/datadog/tracing/contrib/active_support/patcher.rb#11
module Datadog::Tracing::Contrib::ActiveSupport::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/active_support/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/active_support/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/active_support/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/active_support/patcher.rb#16
    def target_version; end
  end
end

# Defines analytics behavior for integrations
#
# source://datadog//lib/datadog/tracing/contrib/analytics.rb#9
module Datadog::Tracing::Contrib::Analytics
  private

  # Checks whether analytics should be enabled.
  # `flag` is a truthy/falsey value that represents a setting on the integration.
  #
  # source://datadog//lib/datadog/tracing/contrib/analytics.rb#19
  def enabled?(flag = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/analytics.rb#27
  def set_measured(span, value = T.unsafe(nil)); end

  # Applies Analytics sampling rate, if applicable for this Contrib::Configuration.
  #
  # source://datadog//lib/datadog/tracing/contrib/analytics.rb#13
  def set_rate!(span, configuration); end

  # source://datadog//lib/datadog/tracing/contrib/analytics.rb#23
  def set_sample_rate(span, sample_rate); end

  class << self
    # Checks whether analytics should be enabled.
    # `flag` is a truthy/falsey value that represents a setting on the integration.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/analytics.rb#19
    def enabled?(flag = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/analytics.rb#27
    def set_measured(span, value = T.unsafe(nil)); end

    # Applies Analytics sampling rate, if applicable for this Contrib::Configuration.
    #
    # source://datadog//lib/datadog/tracing/contrib/analytics.rb#13
    def set_rate!(span, configuration); end

    # source://datadog//lib/datadog/tracing/contrib/analytics.rb#23
    def set_sample_rate(span, sample_rate); end
  end
end

# Extensions for auto instrumentation added to the base library
# AutoInstrumentation enables all integration
#
# source://datadog//lib/datadog/tracing/contrib/auto_instrument.rb#24
module Datadog::Tracing::Contrib::AutoInstrument
  class << self
    # source://datadog//lib/datadog/tracing/contrib/auto_instrument.rb#25
    def patch_all!; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#6
module Datadog::Tracing::Contrib::Aws; end

# source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Aws::Configuration; end

# Custom settings for the AWS integration
#
# source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Aws::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#22
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#22
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#28
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#28
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#15
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#15
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#44
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#44
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#34
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/aws/configuration/settings.rb#34
  def service_name=(value); end
end

# AWS integration constants
#
# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#9
module Datadog::Tracing::Contrib::Aws::Ext; end

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#16
Datadog::Tracing::Contrib::Aws::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#14
Datadog::Tracing::Contrib::Aws::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#15
Datadog::Tracing::Contrib::Aws::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#10
Datadog::Tracing::Contrib::Aws::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#12
Datadog::Tracing::Contrib::Aws::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#11
Datadog::Tracing::Contrib::Aws::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#36
Datadog::Tracing::Contrib::Aws::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#17
Datadog::Tracing::Contrib::Aws::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#18
Datadog::Tracing::Contrib::Aws::Ext::TAG_AGENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#28
Datadog::Tracing::Contrib::Aws::Ext::TAG_AWS_ACCOUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#25
Datadog::Tracing::Contrib::Aws::Ext::TAG_AWS_REGION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#27
Datadog::Tracing::Contrib::Aws::Ext::TAG_AWS_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#35
Datadog::Tracing::Contrib::Aws::Ext::TAG_BUCKET_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#19
Datadog::Tracing::Contrib::Aws::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#20
Datadog::Tracing::Contrib::Aws::Ext::TAG_DEFAULT_AGENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#21
Datadog::Tracing::Contrib::Aws::Ext::TAG_HOST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#22
Datadog::Tracing::Contrib::Aws::Ext::TAG_OPERATION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#23
Datadog::Tracing::Contrib::Aws::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#24
Datadog::Tracing::Contrib::Aws::Ext::TAG_PATH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#29
Datadog::Tracing::Contrib::Aws::Ext::TAG_QUEUE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#26
Datadog::Tracing::Contrib::Aws::Ext::TAG_REGION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#33
Datadog::Tracing::Contrib::Aws::Ext::TAG_RULE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#34
Datadog::Tracing::Contrib::Aws::Ext::TAG_STATE_MACHINE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#32
Datadog::Tracing::Contrib::Aws::Ext::TAG_STREAM_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#31
Datadog::Tracing::Contrib::Aws::Ext::TAG_TABLE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/aws/ext.rb#30
Datadog::Tracing::Contrib::Aws::Ext::TAG_TOPIC_NAME = T.let(T.unsafe(nil), String)

# Description of AWS integration
#
# source://datadog//lib/datadog/tracing/contrib/aws/integration.rb#12
class Datadog::Tracing::Contrib::Aws::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/aws/integration.rb#39
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/aws/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/aws/integration.rb#35
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/aws/integration.rb#19
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/aws/integration.rb#31
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/aws/integration.rb#23
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/aws/integration.rb#15
Datadog::Tracing::Contrib::Aws::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'aws' module.
#
# source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#11
module Datadog::Tracing::Contrib::Aws::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#32
  def add_plugin(*targets); end

  # source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#54
  def get_option(option); end

  # source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#36
  def loaded_constants; end

  # source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#32
    def add_plugin(*targets); end

    # source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#54
    def get_option(option); end

    # source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#36
    def loaded_constants; end

    # source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/aws/patcher.rb#16
    def target_version; end
  end
end

# Initialization hooks for Contrib integrations
#
# source://datadog//lib/datadog/tracing/contrib/component.rb#7
module Datadog::Tracing::Contrib::Component
  class << self
    # Invoke all registered callbacks with the given configuration.
    #
    # @param config [Datadog::Core::Configuration::Settings] the configuration to pass to callbacks
    #
    # source://datadog//lib/datadog/tracing/contrib/component.rb#19
    def configure(config); end

    # Register a callback to be invoked when components are reconfigured.
    #
    # @param callback [Proc] the callback to invoke
    # @param name [String] the name of the integration
    # @yieldparam config [Datadog::Core::Configuration::Settings] the configuration to pass to callbacks
    #
    # source://datadog//lib/datadog/tracing/contrib/component.rb#13
    def register(name, &callback); end

    private

    # Unregister a callback. This is only used for testing.
    #
    # @param name [String] the name of the integration
    #
    # source://datadog//lib/datadog/tracing/contrib/component.rb#31
    def unregister(name); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#8
module Datadog::Tracing::Contrib::ConcurrentRuby; end

# source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ConcurrentRuby::Configuration; end

# Custom settings for the ConcurrentRuby integration
#
# source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ConcurrentRuby::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/configuration/settings.rb#14
  def enabled=(value); end
end

# ConcurrentRuby integration constants
#
# source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/ext.rb#9
module Datadog::Tracing::Contrib::ConcurrentRuby::Ext; end

# source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/ext.rb#10
Datadog::Tracing::Contrib::ConcurrentRuby::Ext::APP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/ext.rb#11
Datadog::Tracing::Contrib::ConcurrentRuby::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Describes the ConcurrentRuby integration
#
# source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#12
class Datadog::Tracing::Contrib::ConcurrentRuby::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#36
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#40
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#32
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#19
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#27
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#23
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#15
Datadog::Tracing::Contrib::ConcurrentRuby::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'Future' and 'Async' classes.
#
# source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#10
module Datadog::Tracing::Contrib::ConcurrentRuby::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # Propagate tracing context in Concurrent::Async
  #
  # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#29
  def async_patch; end

  # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#19
  def patch; end

  # Propagate tracing context in Concurrent::Future
  #
  # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#37
  def patch_future; end

  # Propagate tracing context in Concurrent::Promises::Future
  #
  # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#42
  def patch_promises_future; end

  # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#15
  def target_version; end

  class << self
    # Propagate tracing context in Concurrent::Async
    #
    # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#29
    def async_patch; end

    # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#19
    def patch; end

    # Propagate tracing context in Concurrent::Future
    #
    # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#37
    def patch_future; end

    # Propagate tracing context in Concurrent::Promises::Future
    #
    # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#42
    def patch_promises_future; end

    # source://datadog//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#15
    def target_version; end
  end
end

# Defines configurable behavior for integrations.
#
# This module is responsible for coordination between
# the configuration resolver and default configuration
# fallback.
#
# source://datadog//lib/datadog/tracing/contrib/configurable.rb#14
module Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/configurable.rb#15
    def included(base); end
  end
end

# Configurable instance behavior for integrations
#
# source://datadog//lib/datadog/tracing/contrib/configurable.rb#20
module Datadog::Tracing::Contrib::Configurable::InstanceMethods
  # Get matching configuration by matcher.
  # If no match, returns the default configuration instance.
  #
  # source://datadog//lib/datadog/tracing/contrib/configurable.rb#23
  def configuration(matcher = T.unsafe(nil)); end

  # Returns all registered matchers and their respective configurations.
  #
  # source://datadog//lib/datadog/tracing/contrib/configurable.rb#38
  def configurations; end

  # Create or update configuration associated with `matcher` with
  # the provided `options` and `&block`.
  #
  # source://datadog//lib/datadog/tracing/contrib/configurable.rb#44
  def configure(matcher = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Returns the integration-specific configuration object.
  #
  # If one does not exist, invoke {.new_configuration} a memoize
  # its value.
  #
  # @return [Datadog::Tracing::Contrib::Configuration::Settings] the memoized integration-specific settings object
  #
  # source://datadog//lib/datadog/tracing/contrib/configurable.rb#69
  def default_configuration; end

  # Resets all configuration options
  #
  # source://datadog//lib/datadog/tracing/contrib/configurable.rb#58
  def reset_configuration!; end

  # Resolves the matching configuration for integration-specific value.
  # If no match, returns the default configuration instance.
  #
  # source://datadog//lib/datadog/tracing/contrib/configurable.rb#31
  def resolve(value); end

  protected

  # Returns a new configuration object for this integration.
  #
  # This method normally needs to be overridden for each integration
  # as their settings, defaults and environment variables are
  # specific for each integration.
  #
  # @return [Datadog::Tracing::Contrib::Configuration::Settings] a new, integration-specific settings object
  #
  # source://datadog//lib/datadog/tracing/contrib/configurable.rb#82
  def new_configuration; end

  # Overridable configuration resolver.
  #
  # This resolver is responsible for performing the matching
  # of `#configure(matcher)` `matcher`s with `value`s provided
  # in subsequent calls to `#resolve(value)`.
  #
  # By default, the `value` in `#resolve(value)` must be equal
  # to the `matcher` object provided in `#configure(matcher)`
  # to retrieve the associated configuration.
  #
  # source://datadog//lib/datadog/tracing/contrib/configurable.rb#95
  def resolver; end
end

# source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#6
module Datadog::Tracing::Contrib::Configuration; end

# The {CachingResolver} is a mixin that provides caching functionality to the {Resolver} class.
# This is useful when {Resolver#resolve} values that are expensive to compute.
# This is a size-limited, FIFO cache.
#
# @example
#   class MyResolver < Datadog::Tracing::Contrib::Configuration::Resolver
#   prepend Datadog::Tracing::Contrib::Configuration::CachingResolver
#   # ...
#   end
#
# source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#92
module Datadog::Tracing::Contrib::Configuration::CachingResolver
  # @param cache_limit [Integer] maximum number of entries to cache
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#94
  def initialize(*args, cache_limit: T.unsafe(nil)); end

  # Adds a new `matcher`, associating with it a `value`.
  #
  # This `value` is returned when `#resolve` is called
  # with a matching value for this matcher. When multiple
  # matchers would match, `#resolve` returns the latest
  # added one.
  #
  # The `matcher` can be transformed internally by the
  # `#parse_matcher` method before being stored.
  #
  # The `value` can also be retrieved by calling `#get`
  # with the same `matcher` added by this method.
  #
  # @param matcher [Object] integration-specific matcher
  # @param value [Object] arbitrary value to be associated with `matcher`
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#115
  def add(matcher, value); end

  # Clears the internal cache.
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#121
  def reset_cache; end

  # Matches an arbitrary value against the configured
  # matchers previously set with `#add`.
  #
  # If multiple matchers would match, returns the latest one.
  #
  # @param value [Object] integration-specific value
  # @return [Object] matching `value` configured at `#add`, or `nil` if none match
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#102
  def resolve(value); end
end

# Resolves an integration-specific matcher to an associated
# object.
#
# Integrations that perform any configuration matching
# based on patterns might want to override this class
# to provide richer matching. For example, match configuration
# based on: HTTP request parameters, request headers,
# async queue name.
#
# When overriding this class, for simple use cases, only
# overriding `#parse_matcher` might suffice. See
# `#parse_matcher`'s documentation for more information.
#
# source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#19
class Datadog::Tracing::Contrib::Configuration::Resolver
  # @return [Resolver] a new instance of Resolver
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#22
  def initialize; end

  # Adds a new `matcher`, associating with it a `value`.
  #
  # This `value` is returned when `#resolve` is called
  # with a matching value for this matcher. When multiple
  # matchers would match, `#resolve` returns the latest
  # added one.
  #
  # The `matcher` can be transformed internally by the
  # `#parse_matcher` method before being stored.
  #
  # The `value` can also be retrieved by calling `#get`
  # with the same `matcher` added by this method.
  #
  # @param matcher [Object] integration-specific matcher
  # @param value [Object] arbitrary value to be associated with `matcher`
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#41
  def add(matcher, value); end

  # Returns the value of attribute configurations.
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#20
  def configurations; end

  # Retrieves the stored value for a `matcher`
  # previously stored by `#add`.
  #
  # @param matcher [Object] integration-specific matcher
  # @return [Object] previously stored `value` from `#add`, or `nil` if not found
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#50
  def get(matcher); end

  # Matches an arbitrary value against the configured
  # matchers previously set with `#add`.
  #
  # If multiple matchers would match, returns the latest one.
  #
  # @param value [Object] integration-specific value
  # @return [Object] matching `value` configured at `#add`, or `nil` if none match
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#61
  def resolve(value); end

  protected

  # Converts `matcher` into an appropriate key
  # for the internal Hash storage.
  #
  # It's recommended to override this method,
  # instead of the public methods, if the
  # integration can simply convert both
  # `matcher` (provided to `#add`) and `value`
  # (provided to `#resolve`) to the same value.
  #
  # @param matcher [Object] integration-specific matcher
  # @return [Object] processed matcher
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolver.rb#78
  def parse_matcher(matcher); end
end

# Resolves a value to a configuration key
#
# source://datadog//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#10
module Datadog::Tracing::Contrib::Configuration::Resolvers; end

# Matches Strings and Regexps against `object.to_s` objects
# and Procs against plain objects.
#
# source://datadog//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#13
class Datadog::Tracing::Contrib::Configuration::Resolvers::PatternResolver < ::Datadog::Tracing::Contrib::Configuration::Resolver
  # source://datadog//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#14
  def resolve(value); end

  protected

  # source://datadog//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#31
  def parse_matcher(matcher); end
end

# Common settings for all integrations
#
# source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Configuration::Settings
  include ::Datadog::Core::Configuration::Base
  include ::Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Options::InstanceMethods
  include ::Datadog::Core::Configuration::Base::InstanceMethods
  extend ::Datadog::Core::Configuration::Options::ClassMethods
  extend ::Datadog::Core::Configuration::Base::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#32
  def [](name); end

  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#36
  def []=(name, value); end

  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#15
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#15
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#16
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#16
  def analytics_sample_rate=(value); end

  # @yield [_self]
  # @yieldparam _self [Datadog::Tracing::Contrib::Configuration::Settings] the object that the method was called on
  #
  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#24
  def configure(options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#17
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#17
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#20
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/configuration/settings.rb#20
  def service_name=(value); end
end

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#6
module Datadog::Tracing::Contrib::Dalli; end

# source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Dalli::Configuration; end

# Custom settings for the Dalli integration
#
# source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Dalli::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#48
  def command_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#48
  def command_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#43
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#43
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#33
  def service_name=(value); end
end

# Dalli integration constants
#
# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#9
module Datadog::Tracing::Contrib::Dalli::Ext; end

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#25
Datadog::Tracing::Contrib::Dalli::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#16
Datadog::Tracing::Contrib::Dalli::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#17
Datadog::Tracing::Contrib::Dalli::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# DEV: This is named `*_MEMCACHED_*` because the spans it refer to are `memcached.*` and this variable
# DEV: is a global flag that affects all memcached spans generated by any Datadog product.
#
# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#20
Datadog::Tracing::Contrib::Dalli::Ext::ENV_COMMAND_ENABLED = T.let(T.unsafe(nil), String)

# DEV: Even though this is the dalli integration, all spans are named `memcached.*`.
# DEV: This happens because such spans have special treatment in backend, with memcached-specific handling.
# DEV: If add support for the `memcached` gem (not popular as of 2023), we'll have issues with span naming
# DEV: conflicts.
#
# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#14
Datadog::Tracing::Contrib::Dalli::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#22
Datadog::Tracing::Contrib::Dalli::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#21
Datadog::Tracing::Contrib::Dalli::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#32
Datadog::Tracing::Contrib::Dalli::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#24
Datadog::Tracing::Contrib::Dalli::Ext::QUANTIZE_MAX_CMD_LENGTH = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#26
Datadog::Tracing::Contrib::Dalli::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#27
Datadog::Tracing::Contrib::Dalli::Ext::SPAN_TYPE_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#28
Datadog::Tracing::Contrib::Dalli::Ext::TAG_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#29
Datadog::Tracing::Contrib::Dalli::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#30
Datadog::Tracing::Contrib::Dalli::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/dalli/ext.rb#31
Datadog::Tracing::Contrib::Dalli::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Instruments every interaction with the memcached server
#
# source://datadog//lib/datadog/tracing/contrib/dalli/instrumentation.rb#14
module Datadog::Tracing::Contrib::Dalli::Instrumentation
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/dalli/instrumentation.rb#15
    def included(base); end
  end
end

# InstanceMethods - implementing instrumentation
#
# source://datadog//lib/datadog/tracing/contrib/dalli/instrumentation.rb#20
module Datadog::Tracing::Contrib::Dalli::Instrumentation::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/dalli/instrumentation.rb#21
  def request(op, *args); end

  private

  # source://datadog//lib/datadog/tracing/contrib/dalli/instrumentation.rb#67
  def datadog_configuration; end
end

# Description of Dalli integration
#
# source://datadog//lib/datadog/tracing/contrib/dalli/integration.rb#12
class Datadog::Tracing::Contrib::Dalli::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/dalli/integration.rb#41
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/dalli/integration.rb#45
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/dalli/integration.rb#29
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/dalli/integration.rb#33
    def dalli_class; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/dalli/integration.rb#25
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/dalli/integration.rb#21
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/dalli/integration.rb#16
Datadog::Tracing::Contrib::Dalli::Integration::DALLI_PROTOCOL_BINARY_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://datadog//lib/datadog/tracing/contrib/dalli/integration.rb#15
Datadog::Tracing::Contrib::Dalli::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'dalli' module.
#
# source://datadog//lib/datadog/tracing/contrib/dalli/patcher.rb#12
module Datadog::Tracing::Contrib::Dalli::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/dalli/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/dalli/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/dalli/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/dalli/patcher.rb#17
    def target_version; end
  end
end

# Quantize contains dalli-specic quantization tools.
#
# source://datadog//lib/datadog/tracing/contrib/dalli/quantize.rb#10
module Datadog::Tracing::Contrib::Dalli::Quantize
  private

  # source://datadog//lib/datadog/tracing/contrib/dalli/quantize.rb#13
  def format_command(operation, args); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/dalli/quantize.rb#13
    def format_command(operation, args); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#6
module Datadog::Tracing::Contrib::DelayedJob; end

# source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#10
module Datadog::Tracing::Contrib::DelayedJob::Configuration; end

# Custom settings for the DelayedJob integration
#
# source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#13
class Datadog::Tracing::Contrib::DelayedJob::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#37
  def client_service_name; end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#37
  def client_service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#41
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#41
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#33
  def service_name=(value); end
end

# DelayedJob integration constants
#
# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#9
module Datadog::Tracing::Contrib::DelayedJob::Ext; end

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#12
Datadog::Tracing::Contrib::DelayedJob::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#13
Datadog::Tracing::Contrib::DelayedJob::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#10
Datadog::Tracing::Contrib::DelayedJob::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#15
Datadog::Tracing::Contrib::DelayedJob::Ext::SPAN_ENQUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#14
Datadog::Tracing::Contrib::DelayedJob::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#16
Datadog::Tracing::Contrib::DelayedJob::Ext::SPAN_RESERVE_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#17
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_ATTEMPTS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#21
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#18
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#22
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_OPERATION_ENQUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#23
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#24
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_OPERATION_RESERVE_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#19
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_PRIORITY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/delayed_job/ext.rb#20
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_QUEUE = T.let(T.unsafe(nil), String)

# Description of DelayedJob integration
#
# source://datadog//lib/datadog/tracing/contrib/delayed_job/integration.rb#12
class Datadog::Tracing::Contrib::DelayedJob::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/integration.rb#32
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/delayed_job/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/delayed_job/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/delayed_job/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/delayed_job/integration.rb#15
Datadog::Tracing::Contrib::DelayedJob::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'delayed_job' module.
#
# source://datadog//lib/datadog/tracing/contrib/delayed_job/patcher.rb#10
module Datadog::Tracing::Contrib::DelayedJob::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/patcher.rb#25
  def add_instrumentation(klass); end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/patcher.rb#19
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/patcher.rb#29
  def patch_server_internals; end

  # source://datadog//lib/datadog/tracing/contrib/delayed_job/patcher.rb#15
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/delayed_job/patcher.rb#25
    def add_instrumentation(klass); end

    # source://datadog//lib/datadog/tracing/contrib/delayed_job/patcher.rb#19
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/delayed_job/patcher.rb#29
    def patch_server_internals; end

    # source://datadog//lib/datadog/tracing/contrib/delayed_job/patcher.rb#15
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#6
module Datadog::Tracing::Contrib::Elasticsearch; end

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Elasticsearch::Configuration; end

# Custom settings for the Elasticsearch integration
#
# source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Elasticsearch::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#53
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#53
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#48
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#48
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#33
  def quantize; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#33
  def quantize=(value); end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#38
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#38
  def service_name=(value); end
end

# Elasticsearch integration constants
#
# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#9
module Datadog::Tracing::Contrib::Elasticsearch::Ext; end

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#16
Datadog::Tracing::Contrib::Elasticsearch::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#14
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#15
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#10
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#12
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#11
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#26
Datadog::Tracing::Contrib::Elasticsearch::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#17
Datadog::Tracing::Contrib::Elasticsearch::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#18
Datadog::Tracing::Contrib::Elasticsearch::Ext::SPAN_TYPE_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#19
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_BODY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#23
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#20
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#24
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#21
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_PARAMS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#25
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/ext.rb#22
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_URL = T.let(T.unsafe(nil), String)

# Description of Elasticsearch integration
#
# source://datadog//lib/datadog/tracing/contrib/elasticsearch/integration.rb#12
class Datadog::Tracing::Contrib::Elasticsearch::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/integration.rb#39
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/elasticsearch/integration.rb#35
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/elasticsearch/integration.rb#29
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/elasticsearch/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/integration.rb#15
Datadog::Tracing::Contrib::Elasticsearch::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'elasticsearch' module.
#
# source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#15
module Datadog::Tracing::Contrib::Elasticsearch::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#24
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#20
  def target_version; end

  # `Elasticsearch` namespace renamed to `Elastic` in version 8.0.0 of the transport gem:
  #
  # @see https://github.com/elastic/elastic-transport-ruby/commit/ef804cbbd284f2a82d825221f87124f8b5ff823c
  #
  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#161
  def transport_module; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#24
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#20
    def target_version; end

    # `Elasticsearch` namespace renamed to `Elastic` in version 8.0.0 of the transport gem:
    #
    # @see https://github.com/elastic/elastic-transport-ruby/commit/ef804cbbd284f2a82d825221f87124f8b5ff823c
    #
    # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#161
    def transport_module; end
  end
end

# Patches Elasticsearch::Transport::Client module
#
# source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#36
module Datadog::Tracing::Contrib::Elasticsearch::Patcher::Client
  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#133
  def datadog_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#39
  def perform_request(*args); end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#121
  def tag_body(body, span); end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#114
  def tag_params(params, span); end
end

# Patch to support both `elasticsearch` and `elastic-transport` versions
#
# source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#141
module Datadog::Tracing::Contrib::Elasticsearch::Patcher::DatadogPin
  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#146
  def datadog_pin; end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#142
  def datadog_pin=(pin); end

  # source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#150
  def pin_candidate(candidate = T.unsafe(nil)); end
end

# source://datadog//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#33
Datadog::Tracing::Contrib::Elasticsearch::Patcher::SELF_DEPRECATION_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#6
module Datadog::Tracing::Contrib::Ethon; end

# source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Ethon::Configuration; end

# Custom settings for the Ethon integration
#
# source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Ethon::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#33
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#33
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#47
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#47
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#37
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#37
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#35
  def split_by_domain; end

  # source://datadog//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#35
  def split_by_domain=(value); end
end

# Ethon integration constants
#
# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#9
module Datadog::Tracing::Contrib::Ethon::Ext; end

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#17
Datadog::Tracing::Contrib::Ethon::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#15
Datadog::Tracing::Contrib::Ethon::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#16
Datadog::Tracing::Contrib::Ethon::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#10
Datadog::Tracing::Contrib::Ethon::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#12
Datadog::Tracing::Contrib::Ethon::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#11
Datadog::Tracing::Contrib::Ethon::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#20
Datadog::Tracing::Contrib::Ethon::Ext::NOT_APPLICABLE_METHOD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#24
Datadog::Tracing::Contrib::Ethon::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#19
Datadog::Tracing::Contrib::Ethon::Ext::SPAN_MULTI_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#18
Datadog::Tracing::Contrib::Ethon::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#21
Datadog::Tracing::Contrib::Ethon::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#23
Datadog::Tracing::Contrib::Ethon::Ext::TAG_OPERATION_MULTI_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ethon/ext.rb#22
Datadog::Tracing::Contrib::Ethon::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of Ethon integration
#
# source://datadog//lib/datadog/tracing/contrib/ethon/integration.rb#13
class Datadog::Tracing::Contrib::Ethon::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/ethon/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/ethon/integration.rb#37
  def patcher; end

  # source://datadog//lib/datadog/tracing/contrib/ethon/integration.rb#41
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/ethon/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/ethon/integration.rb#25
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/ethon/integration.rb#21
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/ethon/integration.rb#16
Datadog::Tracing::Contrib::Ethon::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'ethon' module.
#
# source://datadog//lib/datadog/tracing/contrib/ethon/patcher.rb#10
module Datadog::Tracing::Contrib::Ethon::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/ethon/patcher.rb#19
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/ethon/patcher.rb#15
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/ethon/patcher.rb#19
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/ethon/patcher.rb#15
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#6
module Datadog::Tracing::Contrib::Excon; end

# source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#13
module Datadog::Tracing::Contrib::Excon::Configuration; end

# Custom settings for the Excon integration
#
# source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#16
class Datadog::Tracing::Contrib::Excon::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#24
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#24
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#30
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#30
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#36
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#36
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#17
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#17
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#42
  def error_status_codes; end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#42
  def error_status_codes=(value); end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#38
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#38
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#65
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#65
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#55
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#55
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#53
  def split_by_domain; end

  # source://datadog//lib/datadog/tracing/contrib/excon/configuration/settings.rb#53
  def split_by_domain=(value); end
end

# Excon integration constants
#
# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#9
module Datadog::Tracing::Contrib::Excon::Ext; end

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#18
Datadog::Tracing::Contrib::Excon::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#15
Datadog::Tracing::Contrib::Excon::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#16
Datadog::Tracing::Contrib::Excon::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#10
Datadog::Tracing::Contrib::Excon::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#17
Datadog::Tracing::Contrib::Excon::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#12
Datadog::Tracing::Contrib::Excon::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#11
Datadog::Tracing::Contrib::Excon::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#22
Datadog::Tracing::Contrib::Excon::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#19
Datadog::Tracing::Contrib::Excon::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#20
Datadog::Tracing::Contrib::Excon::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/excon/ext.rb#21
Datadog::Tracing::Contrib::Excon::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of Excon integration
#
# source://datadog//lib/datadog/tracing/contrib/excon/integration.rb#13
class Datadog::Tracing::Contrib::Excon::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/excon/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/excon/integration.rb#37
  def patcher; end

  # source://datadog//lib/datadog/tracing/contrib/excon/integration.rb#41
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/excon/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/excon/integration.rb#25
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/excon/integration.rb#21
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/excon/integration.rb#16
Datadog::Tracing::Contrib::Excon::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'excon' module.
#
# source://datadog//lib/datadog/tracing/contrib/excon/patcher.rb#10
module Datadog::Tracing::Contrib::Excon::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/excon/patcher.rb#24
  def add_middleware; end

  # source://datadog//lib/datadog/tracing/contrib/excon/patcher.rb#19
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/excon/patcher.rb#15
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/excon/patcher.rb#24
    def add_middleware; end

    # source://datadog//lib/datadog/tracing/contrib/excon/patcher.rb#19
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/excon/patcher.rb#15
    def target_version; end
  end
end

# Contrib specific constants
#
# source://datadog//lib/datadog/tracing/contrib/ext.rb#7
module Datadog::Tracing::Contrib::Ext; end

# source://datadog//lib/datadog/tracing/contrib/ext.rb#9
module Datadog::Tracing::Contrib::Ext::DB; end

# source://datadog//lib/datadog/tracing/contrib/ext.rb#29
Datadog::Tracing::Contrib::Ext::DB::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# Name of the database. This is *not* the database hostname.
#
# For databases which support such a concept, the default schema/database/namespace
# as configured in the connection string.
#
# If the tracer is already tracking changes to the default schema/database throughout the lifetime of
# the session (i.e. the client executes USE {NEW_SCHEMA} and now the default schema has changed from what
# was set upon connection initialization), then ideally this attribute reflects the current value.
# If the tracer is not already tracking changes then just leaving it to the default value set upon
# initialization is OK.
#
# This is the equivalent of OTels `db.namespace`
#
# @see https://opentelemetry.io/docs/specs/semconv/database/database-spans/#common-attributes
#
# source://datadog//lib/datadog/tracing/contrib/ext.rb#23
Datadog::Tracing::Contrib::Ext::DB::TAG_INSTANCE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#28
Datadog::Tracing::Contrib::Ext::DB::TAG_ROW_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#27
Datadog::Tracing::Contrib::Ext::DB::TAG_STATEMENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#26
Datadog::Tracing::Contrib::Ext::DB::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#25
Datadog::Tracing::Contrib::Ext::DB::TAG_USER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#49
module Datadog::Tracing::Contrib::Ext::Messaging; end

# source://datadog//lib/datadog/tracing/contrib/ext.rb#52
Datadog::Tracing::Contrib::Ext::Messaging::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#51
Datadog::Tracing::Contrib::Ext::Messaging::TAG_DESTINATION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#50
Datadog::Tracing::Contrib::Ext::Messaging::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#57
module Datadog::Tracing::Contrib::Ext::Metadata; end

# Set equal to the global service when contrib span.service is overriden
#
# source://datadog//lib/datadog/tracing/contrib/ext.rb#65
Datadog::Tracing::Contrib::Ext::Metadata::TAG_BASE_SERVICE = T.let(T.unsafe(nil), String)

# Value of tag from which peer.service value was remapped from
#
# source://datadog//lib/datadog/tracing/contrib/ext.rb#62
Datadog::Tracing::Contrib::Ext::Metadata::TAG_PEER_SERVICE_REMAP = T.let(T.unsafe(nil), String)

# Name of tag from which where peer.service information was extracted from
#
# source://datadog//lib/datadog/tracing/contrib/ext.rb#59
Datadog::Tracing::Contrib::Ext::Metadata::TAG_PEER_SERVICE_SOURCE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#35
module Datadog::Tracing::Contrib::Ext::RPC; end

# source://datadog//lib/datadog/tracing/contrib/ext.rb#43
module Datadog::Tracing::Contrib::Ext::RPC::GRPC; end

# source://datadog//lib/datadog/tracing/contrib/ext.rb#45
Datadog::Tracing::Contrib::Ext::RPC::GRPC::TAG_FULL_METHOD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#44
Datadog::Tracing::Contrib::Ext::RPC::GRPC::TAG_STATUS_CODE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#39
Datadog::Tracing::Contrib::Ext::RPC::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#38
Datadog::Tracing::Contrib::Ext::RPC::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#37
Datadog::Tracing::Contrib::Ext::RPC::TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/ext.rb#36
Datadog::Tracing::Contrib::Ext::RPC::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Extensions that can be added to the base library
# Adds registry, configuration access for integrations.
#
# DEV: The Registry should probably be part of the core tracer
# as it represents a global tracer repository that is strongly intertwined
# with the tracer lifecycle and deeply modifies the tracer initialization
# process.
# Most of this file should probably live inside the tracer core.
#
# source://datadog//lib/datadog/tracing/contrib/extensions.rb#20
module Datadog::Tracing::Contrib::Extensions
  class << self
    # source://datadog//lib/datadog/tracing/contrib/extensions.rb#21
    def extend!; end
  end
end

# Configuration methods for Datadog module.
#
# source://datadog//lib/datadog/tracing/contrib/extensions.rb#58
module Datadog::Tracing::Contrib::Extensions::Configuration
  # TODO: Is is not possible to separate this configuration method
  # TODO: from core datadog parts ()e.g. the registry).
  # TODO: Today this method sits here in the `Datadog::Tracing::Contrib::Extensions` namespace
  # TODO: but cannot empirically constraints to the contrib domain only.
  # TODO: We should promote most of this logic to core parts of datadog.
  #
  # source://datadog//lib/datadog/tracing/contrib/extensions.rb#64
  def configure(&block); end
end

# Extensions for Datadog::Core::Configuration::Settings
#
# source://datadog//lib/datadog/tracing/contrib/extensions.rb#110
module Datadog::Tracing::Contrib::Extensions::Configuration::Settings
  # For the provided `integration_name`, resolves a matching configuration
  # for the provided integration from an integration-specific `key`.
  #
  # How the matching is performed is integration-specific.
  #
  # @example
  #   Datadog.configuration.tracing[:integration_name]
  # @example
  #   Datadog.configuration.tracing[:integration_name][:sub_configuration]
  # @param integration_name [Symbol] the integration name
  # @param key [Object] the integration-specific lookup key
  # @return [Datadog::Tracing::Contrib::Configuration::Settings]
  #
  # source://datadog//lib/datadog/tracing/contrib/extensions.rb#209
  def [](integration_name, key = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/extensions.rb#233
  def fetch_integration(name); end

  # source://datadog//lib/datadog/tracing/contrib/extensions.rb#243
  def ignore_integration_load_errors=(value); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/extensions.rb#239
  def ignore_integration_load_errors?; end

  # Applies instrumentation for the provided `integration_name`.
  #
  # Options may be provided, that are specific to that instrumentation.
  # See the instrumentation's settings file for a list of available options.
  #
  # @example
  #   Datadog.configure { |c| c.tracing.instrument :integration_name }
  # @example
  #   Datadog.configure { |c| c.tracing.instrument :integration_name, option_key: :option_value }
  # @param integration_name [Symbol] the integration name
  # @param options [Hash] the integration-specific configuration settings
  # @return [Datadog::Tracing::Contrib::Integration]
  #
  # source://datadog//lib/datadog/tracing/contrib/extensions.rb#178
  def instrument(integration_name, options = T.unsafe(nil), &block); end

  # This method is only for logging/debugging/telemetry purposes (e.g. iteration) in the
  # `@instrumented_integrations` hash.
  #
  # source://datadog//lib/datadog/tracing/contrib/extensions.rb#222
  def instrumented_integrations; end

  # source://datadog//lib/datadog/tracing/contrib/extensions.rb#215
  def integrations_pending_activation; end

  # source://datadog//lib/datadog/tracing/contrib/extensions.rb#227
  def reset!; end

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/extensions.rb#120
    def included(base); end
  end
end

# Used to avoid concurrency issues between registering integrations (e.g. mutation) and reporting the
# current integrations for logging/debugging/telemetry purposes (e.g. iteration) in the
# `@instrumented_integrations` hash.
#
# See https://github.com/DataDog/dd-trace-rb/issues/2851 for details on the original issue.
#
# source://datadog//lib/datadog/tracing/contrib/extensions.rb#118
Datadog::Tracing::Contrib::Extensions::Configuration::Settings::INSTRUMENTED_INTEGRATIONS_LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# source://datadog//lib/datadog/tracing/contrib/extensions.rb#111
class Datadog::Tracing::Contrib::Extensions::Configuration::Settings::InvalidIntegrationError < ::StandardError; end

# Helper methods for Datadog module.
#
# source://datadog//lib/datadog/tracing/contrib/extensions.rb#33
module Datadog::Tracing::Contrib::Extensions::Helpers
  # The global integration registry.
  #
  # This registry holds a reference to all integrations available
  # to the tracer.
  #
  # Integrations registered in the {.registry} can be activated as follows:
  #
  # ```
  # Datadog.configure do |c|
  #   c.tracing.instrument :my_registered_integration, **my_options
  # end
  # ```
  #
  # New integrations can be registered by implementing the {Datadog::Tracing::Contrib::Integration} interface.
  #
  # @return [Datadog::Tracing::Contrib::Registry]
  #
  # source://datadog//lib/datadog/tracing/contrib/extensions.rb#52
  def registry; end
end

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#6
module Datadog::Tracing::Contrib::Faraday; end

# source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Faraday::Configuration; end

# Custom settings for the Faraday integration
#
# source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Faraday::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#27
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#27
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#33
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#33
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#39
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#39
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#20
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#20
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#45
  def error_status_codes; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#45
  def error_status_codes=(value); end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#41
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#41
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#68
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#68
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#58
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#58
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#56
  def split_by_domain; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#56
  def split_by_domain=(value); end
end

# source://datadog//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#16
Datadog::Tracing::Contrib::Faraday::Configuration::Settings::DEFAULT_ERROR_HANDLER = T.let(T.unsafe(nil), Proc)

# Handles installation of our middleware if the user has *not*
# already explicitly configured our middleware for this correction.
#
# Wraps Faraday::Connection#initialize:
# https://github.com/lostisland/faraday/blob/ff9dc1d1219a1bbdba95a9a4cf5d135b97247ee2/lib/faraday/connection.rb#L62-L92
#
# source://datadog//lib/datadog/tracing/contrib/faraday/connection.rb#12
module Datadog::Tracing::Contrib::Faraday::Connection
  # source://datadog//lib/datadog/tracing/contrib/faraday/connection.rb#13
  def initialize(*args, &block); end
end

# Faraday integration constants
#
# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#9
module Datadog::Tracing::Contrib::Faraday::Ext; end

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#18
Datadog::Tracing::Contrib::Faraday::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#16
Datadog::Tracing::Contrib::Faraday::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#17
Datadog::Tracing::Contrib::Faraday::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#10
Datadog::Tracing::Contrib::Faraday::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#13
Datadog::Tracing::Contrib::Faraday::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#12
Datadog::Tracing::Contrib::Faraday::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#11
Datadog::Tracing::Contrib::Faraday::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#22
Datadog::Tracing::Contrib::Faraday::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#19
Datadog::Tracing::Contrib::Faraday::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#20
Datadog::Tracing::Contrib::Faraday::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/faraday/ext.rb#21
Datadog::Tracing::Contrib::Faraday::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of Faraday integration
#
# source://datadog//lib/datadog/tracing/contrib/faraday/integration.rb#13
class Datadog::Tracing::Contrib::Faraday::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/faraday/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/integration.rb#37
  def patcher; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/integration.rb#41
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/faraday/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/faraday/integration.rb#25
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/faraday/integration.rb#21
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/faraday/integration.rb#16
Datadog::Tracing::Contrib::Faraday::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'faraday' module.
#
# source://datadog//lib/datadog/tracing/contrib/faraday/patcher.rb#13
module Datadog::Tracing::Contrib::Faraday::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/faraday/patcher.rb#33
  def add_default_middleware!; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/patcher.rb#29
  def register_middleware!; end

  # source://datadog//lib/datadog/tracing/contrib/faraday/patcher.rb#18
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/faraday/patcher.rb#33
    def add_default_middleware!; end

    # source://datadog//lib/datadog/tracing/contrib/faraday/patcher.rb#22
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/faraday/patcher.rb#29
    def register_middleware!; end

    # source://datadog//lib/datadog/tracing/contrib/faraday/patcher.rb#18
    def target_version; end
  end
end

# Handles installation of our middleware if the user has *not*
# already explicitly configured it for this correction.
#
# RackBuilder class was introduced in faraday 0.9.0:
# https://github.com/lostisland/faraday/commit/77d7546d6d626b91086f427c56bc2cdd951353b3
#
# source://datadog//lib/datadog/tracing/contrib/faraday/rack_builder.rb#12
module Datadog::Tracing::Contrib::Faraday::RackBuilder
  # source://datadog//lib/datadog/tracing/contrib/faraday/rack_builder.rb#13
  def adapter(*args); end
end

# `gRPC` integration public API
#
# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#6
module Datadog::Tracing::Contrib::GRPC
  class << self
    # Extract distributed headers from the given request
    #
    # @param data [Hash] the request to extract from
    # @return [Datadog::Tracing::TraceDigest, nil] the extracted trace digest or nil if none was found
    #
    # source://datadog//lib/datadog/tracing/contrib/grpc.rb#25
    def extract(data); end

    # Inject distributed headers into the given request
    #
    # @param data [Hash] the request to inject
    # @param digest [Datadog::Tracing::TraceDigest] the trace to inject
    #
    # source://datadog//lib/datadog/tracing/contrib/grpc.rb#16
    def inject(digest, data); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#10
module Datadog::Tracing::Contrib::GRPC::Configuration; end

# Custom settings for the gRPC integration
#
# source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#13
class Datadog::Tracing::Contrib::GRPC::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#33
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#33
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#50
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#50
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#45
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#45
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#35
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#35
  def service_name=(value); end
end

# source://datadog//lib/datadog/tracing/contrib/grpc/distributed/fetcher.rb#9
module Datadog::Tracing::Contrib::GRPC::Distributed; end

# Retrieves values from the gRPC metadata.
# One metadata key can be associated with multiple values.
#
# @see https://github.com/grpc/grpc-go/blob/56ac86fa0f3940cb79946ce2c6e56f7ee7ecae84/Documentation/grpc-metadata.md#constructing-metadata
#
# source://datadog//lib/datadog/tracing/contrib/grpc/distributed/fetcher.rb#14
class Datadog::Tracing::Contrib::GRPC::Distributed::Fetcher < ::Datadog::Tracing::Distributed::Fetcher
  # source://datadog//lib/datadog/tracing/contrib/grpc/distributed/fetcher.rb#15
  def [](key); end
end

# Extracts and injects propagation through gRPC metadata.
#
# @see https://github.com/grpc/grpc-go/blob/v1.50.1/Documentation/grpc-metadata.md
#
# source://datadog//lib/datadog/tracing/contrib/grpc/distributed/propagation.rb#19
class Datadog::Tracing::Contrib::GRPC::Distributed::Propagation < ::Datadog::Tracing::Distributed::Propagation
  # @return [Propagation] a new instance of Propagation
  #
  # source://datadog//lib/datadog/tracing/contrib/grpc/distributed/propagation.rb#20
  def initialize(propagation_style_inject:, propagation_style_extract:, propagation_extract_first:); end
end

# gRPC integration constants
#
# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#9
module Datadog::Tracing::Contrib::GRPC::Ext; end

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#16
Datadog::Tracing::Contrib::GRPC::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#14
Datadog::Tracing::Contrib::GRPC::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#15
Datadog::Tracing::Contrib::GRPC::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#10
Datadog::Tracing::Contrib::GRPC::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#12
Datadog::Tracing::Contrib::GRPC::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#11
Datadog::Tracing::Contrib::GRPC::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#24
Datadog::Tracing::Contrib::GRPC::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#17
Datadog::Tracing::Contrib::GRPC::Ext::SPAN_CLIENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#18
Datadog::Tracing::Contrib::GRPC::Ext::SPAN_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#19
Datadog::Tracing::Contrib::GRPC::Ext::TAG_CLIENT_DEADLINE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#20
Datadog::Tracing::Contrib::GRPC::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#21
Datadog::Tracing::Contrib::GRPC::Ext::TAG_OPERATION_CLIENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#22
Datadog::Tracing::Contrib::GRPC::Ext::TAG_OPERATION_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grpc/ext.rb#23
Datadog::Tracing::Contrib::GRPC::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Description of gRPC integration
#
# source://datadog//lib/datadog/tracing/contrib/grpc/integration.rb#12
class Datadog::Tracing::Contrib::GRPC::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/grpc/integration.rb#39
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/grpc/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/grpc/integration.rb#35
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/grpc/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/grpc/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/grpc/integration.rb#15
Datadog::Tracing::Contrib::GRPC::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'grpc' module.
#
# source://datadog//lib/datadog/tracing/contrib/grpc/patcher.rb#11
module Datadog::Tracing::Contrib::GRPC::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/grpc/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/grpc/patcher.rb#26
  def prepend_interceptor; end

  # source://datadog//lib/datadog/tracing/contrib/grpc/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/grpc/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/grpc/patcher.rb#26
    def prepend_interceptor; end

    # source://datadog//lib/datadog/tracing/contrib/grpc/patcher.rb#16
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#6
module Datadog::Tracing::Contrib::Grape; end

# source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Grape::Configuration; end

# Custom settings for the Grape integration
#
# source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Grape::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#23
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#23
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#28
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#28
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#40
  def error_status_codes; end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#40
  def error_status_codes=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#36
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#36
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#34
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/grape/configuration/settings.rb#34
  def service_name=(value); end
end

# Endpoint module includes a list of subscribers to create
# traces when a Grape endpoint is hit
#
# source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#15
module Datadog::Tracing::Contrib::Grape::Endpoint
  class << self
    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#172
    def endpoint_render(name, start, finish, id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#84
    def endpoint_run(name, start, finish, id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#197
    def endpoint_run_filters(name, start, finish, id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#39
    def endpoint_start_process(_name, _start, _finish, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#152
    def endpoint_start_render(*_arg0); end

    # Status code resolution is tied to the exception handling
    #
    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#129
    def handle_error_and_status_code(span, endpoint, payload); end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#20
    def subscribe; end

    private

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#281
    def analytics_enabled?; end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#285
    def analytics_sample_rate; end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#255
    def api_view(api); end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#308
    def datadog_configuration; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#303
    def enabled?; end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#266
    def endpoint_expand_path(endpoint); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#296
    def error_status?(status); end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#247
    def error_status_codes; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#289
    def exception_is_error?(exception); end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#238
    def handle_error(span, exception, status = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#251
    def on_error; end

    # source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#277
    def service_name; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#17
Datadog::Tracing::Contrib::Grape::Endpoint::KEY_RENDER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/endpoint.rb#16
Datadog::Tracing::Contrib::Grape::Endpoint::KEY_RUN = T.let(T.unsafe(nil), String)

# Grape integration constants
#
# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#9
module Datadog::Tracing::Contrib::Grape::Ext; end

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#12
Datadog::Tracing::Contrib::Grape::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#13
Datadog::Tracing::Contrib::Grape::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#10
Datadog::Tracing::Contrib::Grape::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#14
Datadog::Tracing::Contrib::Grape::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#15
Datadog::Tracing::Contrib::Grape::Ext::SPAN_ENDPOINT_RENDER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#16
Datadog::Tracing::Contrib::Grape::Ext::SPAN_ENDPOINT_RUN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#17
Datadog::Tracing::Contrib::Grape::Ext::SPAN_ENDPOINT_RUN_FILTERS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#18
Datadog::Tracing::Contrib::Grape::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#19
Datadog::Tracing::Contrib::Grape::Ext::TAG_FILTER_TYPE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#20
Datadog::Tracing::Contrib::Grape::Ext::TAG_OPERATION_ENDPOINT_RENDER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#21
Datadog::Tracing::Contrib::Grape::Ext::TAG_OPERATION_ENDPOINT_RUN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#22
Datadog::Tracing::Contrib::Grape::Ext::TAG_OPERATION_ENDPOINT_RUN_FILTERS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#23
Datadog::Tracing::Contrib::Grape::Ext::TAG_ROUTE_ENDPOINT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#25
Datadog::Tracing::Contrib::Grape::Ext::TAG_ROUTE_METHOD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/grape/ext.rb#24
Datadog::Tracing::Contrib::Grape::Ext::TAG_ROUTE_PATH = T.let(T.unsafe(nil), String)

# Instrumentation for Grape::Endpoint
#
# source://datadog//lib/datadog/tracing/contrib/grape/instrumentation.rb#8
module Datadog::Tracing::Contrib::Grape::Instrumentation
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Grape::Instrumentation::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/grape/instrumentation.rb#9
    def included(base); end
  end
end

# ClassMethods - implementing instrumentation
#
# source://datadog//lib/datadog/tracing/contrib/grape/instrumentation.rb#15
module Datadog::Tracing::Contrib::Grape::Instrumentation::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/grape/instrumentation.rb#16
  def generate_api_method(*params, &block); end
end

# InstanceMethods - implementing instrumentation
#
# source://datadog//lib/datadog/tracing/contrib/grape/instrumentation.rb#27
module Datadog::Tracing::Contrib::Grape::Instrumentation::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/grape/instrumentation.rb#28
  def run(*args); end
end

# Description of Grape integration
#
# source://datadog//lib/datadog/tracing/contrib/grape/integration.rb#12
class Datadog::Tracing::Contrib::Grape::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/grape/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/grape/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/grape/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/grape/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/grape/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/grape/integration.rb#15
Datadog::Tracing::Contrib::Grape::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'grape' module.
#
# source://datadog//lib/datadog/tracing/contrib/grape/patcher.rb#13
module Datadog::Tracing::Contrib::Grape::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/grape/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/grape/patcher.rb#18
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/grape/patcher.rb#22
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/grape/patcher.rb#18
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#6
module Datadog::Tracing::Contrib::GraphQL; end

# source://datadog//lib/datadog/tracing/contrib/graphql/configuration/error_extension_env_parser.rb#7
module Datadog::Tracing::Contrib::GraphQL::Configuration; end

# Parses the environment variable `DD_TRACE_GRAPHQL_ERROR_EXTENSIONS` for error extension names declaration.
#
# source://datadog//lib/datadog/tracing/contrib/graphql/configuration/error_extension_env_parser.rb#9
class Datadog::Tracing::Contrib::GraphQL::Configuration::ErrorExtensionEnvParser
  class << self
    # Parses the environment variable `DD_TRACE_GRAPHQL_ERROR_EXTENSIONS` into an array of error extension names.
    #
    # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/error_extension_env_parser.rb#11
    def call(values); end
  end
end

# Custom settings for the GraphQL integration
#
# source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#14
class Datadog::Tracing::Contrib::GraphQL::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#22
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#22
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#15
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#15
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#55
  def error_extensions; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#55
  def error_extensions=(value); end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#63
  def error_tracking; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#63
  def error_tracking=(value); end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#33
  def schemas; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#33
  def schemas=(value); end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#38
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#38
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#42
  def with_deprecated_tracer; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#42
  def with_deprecated_tracer=(value); end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#47
  def with_unified_tracer; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#47
  def with_unified_tracer=(value); end
end

# GraphQL integration constants
#
# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#9
module Datadog::Tracing::Contrib::GraphQL::Ext; end

# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#12
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#13
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#10
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#15
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ERROR_EXTENSIONS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#16
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ERROR_TRACKING = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#14
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_WITH_UNIFIED_TRACER = T.let(T.unsafe(nil), String)

# Span event name for query-level errors
#
# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#21
Datadog::Tracing::Contrib::GraphQL::Ext::EVENT_QUERY_ERROR = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#17
Datadog::Tracing::Contrib::GraphQL::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/graphql/ext.rb#18
Datadog::Tracing::Contrib::GraphQL::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# Description of GraphQL integration
#
# source://datadog//lib/datadog/tracing/contrib/graphql/integration.rb#12
class Datadog::Tracing::Contrib::GraphQL::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/graphql/integration.rb#45
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/integration.rb#49
  def patcher; end

  class << self
    # Breaking changes are introduced in `2.2.6` and have been backported to
    #
    # * 1.13.21
    # * 2.0.28
    # * 2.1.11
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/graphql/integration.rb#32
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/graphql/integration.rb#22
    def loaded?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/graphql/integration.rb#41
    def trace_supported?; end

    # source://datadog//lib/datadog/tracing/contrib/graphql/integration.rb#18
    def version; end
  end
end

# Provides instrumentation for `graphql` through the GraphQL tracing framework
#
# source://datadog//lib/datadog/tracing/contrib/graphql/patcher.rb#14
module Datadog::Tracing::Contrib::GraphQL::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/graphql/patcher.rb#47
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/patcher.rb#23
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/patcher.rb#51
  def schemas; end

  # source://datadog//lib/datadog/tracing/contrib/graphql/patcher.rb#19
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/graphql/patcher.rb#47
    def configuration; end

    # source://datadog//lib/datadog/tracing/contrib/graphql/patcher.rb#23
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/graphql/patcher.rb#51
    def schemas; end

    # source://datadog//lib/datadog/tracing/contrib/graphql/patcher.rb#19
    def target_version; end
  end
end

# Provides instrumentation for `graphql` through with GraphQL's trace
#
# source://datadog//lib/datadog/tracing/contrib/graphql/trace_patcher.rb#8
module Datadog::Tracing::Contrib::GraphQL::TracePatcher
  private

  # source://datadog//lib/datadog/tracing/contrib/graphql/trace_patcher.rb#11
  def patch!(schemas); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/graphql/trace_patcher.rb#11
    def patch!(schemas); end
  end
end

# Provides instrumentation for `graphql` through the GraphQL's tracing
#
# source://datadog//lib/datadog/tracing/contrib/graphql/tracing_patcher.rb#8
module Datadog::Tracing::Contrib::GraphQL::TracingPatcher
  private

  # source://datadog//lib/datadog/tracing/contrib/graphql/tracing_patcher.rb#11
  def patch!(schemas); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/graphql/tracing_patcher.rb#11
    def patch!(schemas); end
  end
end

# Provides instrumentation for `graphql` through the GraphQL's tracing with methods defined in UnifiedTrace
#
# source://datadog//lib/datadog/tracing/contrib/graphql/unified_trace_patcher.rb#12
module Datadog::Tracing::Contrib::GraphQL::UnifiedTracePatcher
  private

  # TODO: `GraphQL::Schema.trace_with` and `YOUR_SCHEMA.trace_with` don't mix.
  # TODO: They create duplicate spans when combined.
  # TODO: We should measure how frequently users use `YOUR_SCHEMA.trace_with`, and hopefully we can remove it.
  #
  # source://datadog//lib/datadog/tracing/contrib/graphql/unified_trace_patcher.rb#18
  def patch!(schemas); end

  class << self
    # TODO: `GraphQL::Schema.trace_with` and `YOUR_SCHEMA.trace_with` don't mix.
    # TODO: They create duplicate spans when combined.
    # TODO: We should measure how frequently users use `YOUR_SCHEMA.trace_with`, and hopefully we can remove it.
    #
    # source://datadog//lib/datadog/tracing/contrib/graphql/unified_trace_patcher.rb#18
    def patch!(schemas); end
  end
end

# `Net/HTTP` integration public API
#
# source://datadog//lib/datadog/tracing/contrib/http/circuit_breaker.rb#8
module Datadog::Tracing::Contrib::HTTP
  extend ::Datadog::Tracing::Contrib::HTTP::CircuitBreaker

  class << self
    # Extract distributed headers from the given request
    #
    # @param data [Hash] the request to extract from
    # @return [Datadog::Tracing::TraceDigest, nil] the extracted trace digest or nil if none was found
    #
    # source://datadog//lib/datadog/tracing/contrib/http.rb#25
    def extract(data); end

    # Inject distributed headers into the given request
    #
    # @param data [Hash] the request to inject
    # @param digest [Datadog::Tracing::TraceDigest] the trace to inject
    #
    # source://datadog//lib/datadog/tracing/contrib/http.rb#16
    def inject(digest, data); end
  end
end

# HTTP integration circuit breaker behavior
# For avoiding recursive traces.
#
# source://datadog//lib/datadog/tracing/contrib/http/circuit_breaker.rb#11
module Datadog::Tracing::Contrib::HTTP::CircuitBreaker
  # We don't want to trace our own call to the API (they use net/http)
  # TODO: We don't want this kind of soft-check on HTTP requests.
  #       Remove this when transport implements its own "skip tracing" mechanism.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/http/circuit_breaker.rb#26
  def internal_request?(request); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/http/circuit_breaker.rb#12
  def should_skip_tracing?(request); end
end

# source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#12
module Datadog::Tracing::Contrib::HTTP::Configuration; end

# Custom settings for the HTTP integration
#
# source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#15
class Datadog::Tracing::Contrib::HTTP::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#23
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#23
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#29
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#29
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#35
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#35
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#47
  def error_status_codes; end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#47
  def error_status_codes=(value); end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#58
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#58
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#37
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#37
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#63
  def split_by_domain; end

  # source://datadog//lib/datadog/tracing/contrib/http/configuration/settings.rb#63
  def split_by_domain=(value); end
end

# source://datadog//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#9
module Datadog::Tracing::Contrib::HTTP::Distributed; end

# Retrieves HTTP headers from carrier.
# Headers will also match if Rack-formatted:
# 'my-header' will match 'my-header' and 'HTTP_MY_HEADER'.
#
# In case both variants are present, the verbatim match will be used.
#
# source://datadog//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#15
class Datadog::Tracing::Contrib::HTTP::Distributed::Fetcher < ::Datadog::Tracing::Distributed::Fetcher
  # @param name [String] the header name
  # @return [String, nil] the header value or nil if not found
  #
  # source://datadog//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#18
  def [](name); end
end

# Extracts and injects propagation through HTTP headers.
#
# source://datadog//lib/datadog/tracing/contrib/http/distributed/propagation.rb#18
class Datadog::Tracing::Contrib::HTTP::Distributed::Propagation < ::Datadog::Tracing::Distributed::Propagation
  # @return [Propagation] a new instance of Propagation
  #
  # source://datadog//lib/datadog/tracing/contrib/http/distributed/propagation.rb#19
  def initialize(propagation_style_inject:, propagation_style_extract:, propagation_extract_first:); end
end

# HTTP integration constants
#
# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#9
module Datadog::Tracing::Contrib::HTTP::Ext; end

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#17
Datadog::Tracing::Contrib::HTTP::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#14
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#15
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#10
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#16
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#12
Datadog::Tracing::Contrib::HTTP::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#11
Datadog::Tracing::Contrib::HTTP::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#21
Datadog::Tracing::Contrib::HTTP::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#18
Datadog::Tracing::Contrib::HTTP::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#19
Datadog::Tracing::Contrib::HTTP::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/http/ext.rb#20
Datadog::Tracing::Contrib::HTTP::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Net::HTTP
#
# source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#16
module Datadog::Tracing::Contrib::HTTP::Instrumentation
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#17
    def included(base); end
  end
end

# InstanceMethods - implementing instrumentation
#
# source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#22
module Datadog::Tracing::Contrib::HTTP::Instrumentation::InstanceMethods
  include ::Datadog::Tracing::Contrib::HttpAnnotationHelper

  # source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#58
  def annotate_span_with_request!(span, request, request_options); end

  # source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#100
  def annotate_span_with_response!(span, response, request_options); end

  # :yield: +response+
  #
  # source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#26
  def request(req, body = T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#115
  def set_analytics_sample_rate(span, request_options); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#135
  def analytics_enabled?(request_options); end

  # source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#139
  def analytics_sample_rate(request_options); end

  # source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#131
  def datadog_configuration(host = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/http/instrumentation.rb#123
  def host_and_port(request); end
end

# Description of HTTP integration
#
# source://datadog//lib/datadog/tracing/contrib/http/integration.rb#18
class Datadog::Tracing::Contrib::HTTP::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/http/integration.rb#37
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/http/integration.rb#41
  def patcher; end

  # source://datadog//lib/datadog/tracing/contrib/http/integration.rb#45
  def resolver; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/http/integration.rb#25
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/http/integration.rb#33
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/http/integration.rb#29
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/http/integration.rb#21
Datadog::Tracing::Contrib::HTTP::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), String)

# Patcher enables patching of 'net/http' module.
#
# source://datadog//lib/datadog/tracing/contrib/http/patcher.rb#13
module Datadog::Tracing::Contrib::HTTP::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch if needed
  #
  # source://datadog//lib/datadog/tracing/contrib/http/patcher.rb#23
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/http/patcher.rb#18
  def target_version; end

  class << self
    # patch applies our patch if needed
    #
    # source://datadog//lib/datadog/tracing/contrib/http/patcher.rb#23
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/http/patcher.rb#18
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/hanami/ext.rb#6
module Datadog::Tracing::Contrib::Hanami; end

# Hanami Instrumentation for `hanami.action`
#
# source://datadog//lib/datadog/tracing/contrib/hanami/action_tracer.rb#12
class Datadog::Tracing::Contrib::Hanami::ActionTracer
  # @return [ActionTracer] a new instance of ActionTracer
  #
  # source://datadog//lib/datadog/tracing/contrib/hanami/action_tracer.rb#13
  def initialize(app, action); end

  # source://datadog//lib/datadog/tracing/contrib/hanami/action_tracer.rb#18
  def call(env); end

  private

  # source://datadog//lib/datadog/tracing/contrib/hanami/action_tracer.rb#40
  def configuration; end
end

# source://datadog//lib/datadog/tracing/contrib/hanami/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Hanami::Configuration; end

# Configuration for Hanami instrumentation
#
# source://datadog//lib/datadog/tracing/contrib/hanami/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Hanami::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/hanami/configuration/settings.rb#13
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/hanami/configuration/settings.rb#13
  def enabled=(value); end
end

# Hanami integration constants
#
# source://datadog//lib/datadog/tracing/contrib/hanami/ext.rb#9
module Datadog::Tracing::Contrib::Hanami::Ext; end

# source://datadog//lib/datadog/tracing/contrib/hanami/ext.rb#10
Datadog::Tracing::Contrib::Hanami::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/hanami/ext.rb#12
Datadog::Tracing::Contrib::Hanami::Ext::SPAN_ACTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/hanami/ext.rb#14
Datadog::Tracing::Contrib::Hanami::Ext::SPAN_RENDER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/hanami/ext.rb#13
Datadog::Tracing::Contrib::Hanami::Ext::SPAN_ROUTING = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/hanami/ext.rb#16
Datadog::Tracing::Contrib::Hanami::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/hanami/ext.rb#17
Datadog::Tracing::Contrib::Hanami::Ext::TAG_OPERATION_ACTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/hanami/ext.rb#19
Datadog::Tracing::Contrib::Hanami::Ext::TAG_OPERATION_RENDER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/hanami/ext.rb#18
Datadog::Tracing::Contrib::Hanami::Ext::TAG_OPERATION_ROUTING = T.let(T.unsafe(nil), String)

# Description of Hanami integration
#
# source://datadog//lib/datadog/tracing/contrib/hanami/integration.rb#12
class Datadog::Tracing::Contrib::Hanami::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/hanami/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/hanami/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/hanami/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/hanami/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/hanami/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/hanami/integration.rb#16
Datadog::Tracing::Contrib::Hanami::Integration::MAXIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://datadog//lib/datadog/tracing/contrib/hanami/integration.rb#15
Datadog::Tracing::Contrib::Hanami::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of Hanami
#
# source://datadog//lib/datadog/tracing/contrib/hanami/patcher.rb#13
module Datadog::Tracing::Contrib::Hanami::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/hanami/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/hanami/patcher.rb#18
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/hanami/patcher.rb#22
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/hanami/patcher.rb#18
    def target_version; end
  end
end

# Hanami Instrumentation for `hanami.render`
#
# source://datadog//lib/datadog/tracing/contrib/hanami/renderer_policy_tracing.rb#11
module Datadog::Tracing::Contrib::Hanami::RendererPolicyTracing
  # source://datadog//lib/datadog/tracing/contrib/hanami/renderer_policy_tracing.rb#34
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/hanami/renderer_policy_tracing.rb#12
  def render(env, response); end
end

# Hanami Instrumentation for `hanami.routing`
#
# source://datadog//lib/datadog/tracing/contrib/hanami/router_tracing.rb#11
module Datadog::Tracing::Contrib::Hanami::RouterTracing
  # source://datadog//lib/datadog/tracing/contrib/hanami/router_tracing.rb#12
  def call(env); end

  # source://datadog//lib/datadog/tracing/contrib/hanami/router_tracing.rb#35
  def configuration; end
end

# Contains methods helpful for tracing/annotating HTTP request libraries
#
# source://datadog//lib/datadog/tracing/contrib/http_annotation_helper.rb#7
module Datadog::Tracing::Contrib::HttpAnnotationHelper
  # source://datadog//lib/datadog/tracing/contrib/http_annotation_helper.rb#8
  def service_name(hostname, configuration_options, pin = T.unsafe(nil)); end
end

# Datadog Httpclient integration.
#
# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#6
module Datadog::Tracing::Contrib::Httpclient; end

# source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Httpclient::Configuration; end

# Custom settings for the Httpclient integration
#
# source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Httpclient::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#23
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#23
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#29
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#29
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#35
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#35
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#46
  def error_status_codes; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#46
  def error_status_codes=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#57
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#57
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#37
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#37
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#62
  def split_by_domain; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#62
  def split_by_domain=(value); end
end

# Httpclient integration constants
#
# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#9
module Datadog::Tracing::Contrib::Httpclient::Ext; end

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#18
Datadog::Tracing::Contrib::Httpclient::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#15
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#16
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#10
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#17
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#12
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#11
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#22
Datadog::Tracing::Contrib::Httpclient::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#19
Datadog::Tracing::Contrib::Httpclient::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#20
Datadog::Tracing::Contrib::Httpclient::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httpclient/ext.rb#21
Datadog::Tracing::Contrib::Httpclient::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Httpclient
#
# source://datadog//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#14
module Datadog::Tracing::Contrib::Httpclient::Instrumentation
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#15
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://datadog//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#20
module Datadog::Tracing::Contrib::Httpclient::Instrumentation::InstanceMethods
  include ::Datadog::Tracing::Contrib::HttpAnnotationHelper

  # source://datadog//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#23
  def do_get_block(req, proxy, conn, &block); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#118
  def analytics_enabled?(request_options); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#59
  def annotate_span_with_request!(span, req, req_options); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#97
  def annotate_span_with_response!(span, response, request_options); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#114
  def datadog_configuration(host = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#122
  def set_analytics_sample_rate(span, request_options); end
end

# Description of Httpclient integration
#
# source://datadog//lib/datadog/tracing/contrib/httpclient/integration.rb#13
class Datadog::Tracing::Contrib::Httpclient::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/httpclient/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/integration.rb#37
  def patcher; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/integration.rb#41
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/httpclient/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/httpclient/integration.rb#25
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/httpclient/integration.rb#21
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/httpclient/integration.rb#16
Datadog::Tracing::Contrib::Httpclient::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'httpclient' module.
#
# source://datadog//lib/datadog/tracing/contrib/httpclient/patcher.rb#13
module Datadog::Tracing::Contrib::Httpclient::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/httpclient/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/httpclient/patcher.rb#18
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/httpclient/patcher.rb#22
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/httpclient/patcher.rb#18
    def target_version; end
  end
end

# Datadog Httprb integration.
#
# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#6
module Datadog::Tracing::Contrib::Httprb; end

# source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Httprb::Configuration; end

# Custom settings for the Httprb integration
#
# source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Httprb::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#23
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#23
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#29
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#29
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#35
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#35
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#46
  def error_status_codes; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#46
  def error_status_codes=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#57
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#57
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#37
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#37
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#62
  def split_by_domain; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#62
  def split_by_domain=(value); end
end

# Httprb integration constants
#
# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#9
module Datadog::Tracing::Contrib::Httprb::Ext; end

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#17
Datadog::Tracing::Contrib::Httprb::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#14
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#15
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#10
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#16
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#12
Datadog::Tracing::Contrib::Httprb::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#11
Datadog::Tracing::Contrib::Httprb::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#21
Datadog::Tracing::Contrib::Httprb::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#18
Datadog::Tracing::Contrib::Httprb::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#19
Datadog::Tracing::Contrib::Httprb::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/httprb/ext.rb#20
Datadog::Tracing::Contrib::Httprb::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Httprb
#
# source://datadog//lib/datadog/tracing/contrib/httprb/instrumentation.rb#14
module Datadog::Tracing::Contrib::Httprb::Instrumentation
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/httprb/instrumentation.rb#15
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://datadog//lib/datadog/tracing/contrib/httprb/instrumentation.rb#20
module Datadog::Tracing::Contrib::Httprb::Instrumentation::InstanceMethods
  include ::Datadog::Tracing::Contrib::HttpAnnotationHelper

  # source://datadog//lib/datadog/tracing/contrib/httprb/instrumentation.rb#23
  def perform(req, options); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/httprb/instrumentation.rb#128
  def analytics_enabled?(request_options); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/instrumentation.rb#59
  def annotate_span_with_request!(span, req, req_options); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/instrumentation.rb#105
  def annotate_span_with_response!(span, response, request_options); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/instrumentation.rb#124
  def datadog_configuration(host = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/httprb/instrumentation.rb#132
  def logger; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/instrumentation.rb#136
  def set_analytics_sample_rate(span, request_options); end
end

# Description of Httprb integration
#
# source://datadog//lib/datadog/tracing/contrib/httprb/integration.rb#13
class Datadog::Tracing::Contrib::Httprb::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/httprb/integration.rb#36
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/integration.rb#40
  def patcher; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/integration.rb#44
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/httprb/integration.rb#32
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/httprb/integration.rb#20
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/httprb/integration.rb#28
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/httprb/integration.rb#24
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/httprb/integration.rb#16
Datadog::Tracing::Contrib::Httprb::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'httprb' module.
#
# source://datadog//lib/datadog/tracing/contrib/httprb/patcher.rb#13
module Datadog::Tracing::Contrib::Httprb::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/httprb/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/httprb/patcher.rb#18
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/httprb/patcher.rb#22
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/httprb/patcher.rb#18
    def target_version; end
  end
end

# {Integration} provides the basic contract of a tracing integration.
#
# An example for a simple instrumentation of a fictional `BillingApi::Client`:
#
# ```
# require 'datadog'
#
# module BillingApi
#   class Integration
#     include ::Datadog::Tracing::Contrib::Integration
#
#     register_as :billing_api # Register in the global tracing registry
#
#     def self.available?
#       defined?(::BillingApi::Client) # Check if the target for instrumentation is present.
#     end
#
#     def new_configuration
#       Settings.new
#     end
#
#     def patcher
#       Patcher
#     end
#   end
#
#   class Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
#     # Custom service name, if a separate service is desirable for BillingApi calls.
#     option :service, default: nil
#   end
#
#   module Patcher
#     include ::Datadog::Tracing::Contrib::Patcher
#
#     def self.patch
#       ::BillingApi::Client.prepend(Instrumentation)
#     end
#   end
#
#   module Instrumentation
#     def api_request!(env)
#       Tracing.trace('billing.request',
#                            type: 'http',
#                            service: Datadog.configuration.tracing[:billing_api][:service]) do |span|
#         span.resource = env[:route].to_s
#         span.set_tag('client_id', env[:client][:id])
#
#         super
#       end
#     end
#   end
# end
#
# Datadog.configure do |c|
#   c.tracing.instrument :billing_api # Settings (e.g. `service:`) can be provided as keyword arguments.
# end
# ```
#
# source://datadog//lib/datadog/tracing/contrib/integration.rb#69
module Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable

  mixes_in_class_methods ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/integration.rb#70
    def included(base); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#6
module Datadog::Tracing::Contrib::Kafka; end

# source://datadog//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Kafka::Configuration; end

# Custom settings for the Kafka integration
#
# source://datadog//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Kafka::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#33
  def service_name=(value); end
end

# Defines basic behaviors for an event for a consumer.
#
# source://datadog//lib/datadog/tracing/contrib/kafka/consumer_event.rb#8
module Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  # source://datadog//lib/datadog/tracing/contrib/kafka/consumer_event.rb#9
  def on_start(span, _event, _id, payload); end
end

# Defines basic behaviors for an event for a consumer group.
#
# source://datadog//lib/datadog/tracing/contrib/kafka/consumer_group_event.rb#8
module Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent
  # source://datadog//lib/datadog/tracing/contrib/kafka/consumer_group_event.rb#9
  def on_start(span, _event, _id, payload); end
end

# Defines basic behaviors for an ActiveSupport event.
#
# source://datadog//lib/datadog/tracing/contrib/kafka/event.rb#12
module Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/kafka/event.rb#13
    def included(base); end
  end
end

# Class methods for Kafka events.
#
# source://datadog//lib/datadog/tracing/contrib/kafka/event.rb#19
module Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/kafka/event.rb#28
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/event.rb#20
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/event.rb#32
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/kafka/event.rb#24
  def span_options; end
end

# Defines collection of instrumented Kafka events
#
# source://datadog//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#10
module Datadog::Tracing::Contrib::Kafka::Events
  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/events.rb#33
  def all; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events.rb#41
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events.rb#37
  def subscriptions; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/events.rb#33
    def all; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events.rb#41
    def subscribe!; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events.rb#37
    def subscriptions; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/events.rb#19
Datadog::Tracing::Contrib::Kafka::Events::ALL = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#11
module Datadog::Tracing::Contrib::Kafka::Events::Connection; end

# Defines instrumentation for request.connection.kafka event
#
# source://datadog//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::Connection::Request
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#20
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#29
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#33
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#20
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#29
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#33
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#16
Datadog::Tracing::Contrib::Kafka::Events::Connection::Request::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#12
module Datadog::Tracing::Contrib::Kafka::Events::Consumer; end

# Defines instrumentation for process_batch.consumer.kafka event
#
# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#14
module Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessBatch
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent

  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#22
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#36
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#40
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#22
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#36
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#40
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#18
Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessBatch::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for process_message.consumer.kafka event
#
# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#14
module Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessMessage
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent

  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#22
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#34
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#38
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#22
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#34
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#38
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#18
Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessMessage::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup; end

# Defines instrumentation for heartbeat.consumer.kafka event
#
# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#15
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::Heartbeat
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#24
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#34
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#38
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#24
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#34
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#38
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#20
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::Heartbeat::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for join_group.consumer.kafka event
#
# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#15
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::JoinGroup
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#24
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#28
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#24
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#28
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#20
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::JoinGroup::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for leave_group.consumer.kafka event
#
# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#15
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::LeaveGroup
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#24
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#28
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#24
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#28
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#20
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::LeaveGroup::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for sync_group.consumer.kafka event
#
# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#15
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::SyncGroup
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#24
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#28
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#24
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#28
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#20
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::SyncGroup::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#11
module Datadog::Tracing::Contrib::Kafka::Events::ProduceOperation; end

# Defines instrumentation for send_messages.producer.kafka event
#
# source://datadog//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::ProduceOperation::SendMessages
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#20
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#28
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#32
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#20
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#28
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#32
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#16
Datadog::Tracing::Contrib::Kafka::Events::ProduceOperation::SendMessages::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#11
module Datadog::Tracing::Contrib::Kafka::Events::Producer; end

# Defines instrumentation for deliver_messages.producer.kafka event
#
# source://datadog//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::Producer::DeliverMessages
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#20
  def on_start(span, _event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#31
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#35
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#20
    def on_start(span, _event, _id, payload); end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#31
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#35
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#16
Datadog::Tracing::Contrib::Kafka::Events::Producer::DeliverMessages::EVENT_NAME = T.let(T.unsafe(nil), String)

# Kafka integration constants
#
# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#9
module Datadog::Tracing::Contrib::Kafka::Ext; end

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#12
Datadog::Tracing::Contrib::Kafka::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#13
Datadog::Tracing::Contrib::Kafka::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#10
Datadog::Tracing::Contrib::Kafka::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#14
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONNECTION_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#15
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#16
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_JOIN_GROUP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#17
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_LEAVE_GROUP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#18
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_SYNC_GROUP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#19
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_DELIVER_MESSAGES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#20
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_PROCESS_BATCH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#21
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_PROCESS_MESSAGE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#22
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_SEND_MESSAGES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#24
Datadog::Tracing::Contrib::Kafka::Ext::TAG_API = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#23
Datadog::Tracing::Contrib::Kafka::Ext::TAG_ATTEMPTS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#25
Datadog::Tracing::Contrib::Kafka::Ext::TAG_CLIENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#39
Datadog::Tracing::Contrib::Kafka::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#30
Datadog::Tracing::Contrib::Kafka::Ext::TAG_DELIVERED_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#26
Datadog::Tracing::Contrib::Kafka::Ext::TAG_GROUP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#27
Datadog::Tracing::Contrib::Kafka::Ext::TAG_HIGHWATER_MARK_OFFSET = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#50
Datadog::Tracing::Contrib::Kafka::Ext::TAG_KAFKA_BOOTSTRAP_SERVERS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#28
Datadog::Tracing::Contrib::Kafka::Ext::TAG_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#29
Datadog::Tracing::Contrib::Kafka::Ext::TAG_MESSAGE_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#49
Datadog::Tracing::Contrib::Kafka::Ext::TAG_MESSAGING_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#31
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OFFSET = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#32
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OFFSET_LAG = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#40
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONNECTION_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#41
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#42
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_JOIN_GROUP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#43
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_LEAVE_GROUP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#44
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_SYNC_GROUP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#45
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_DELIVER_MESSAGES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#46
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_PROCESS_BATCH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#47
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_PROCESS_MESSAGE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#48
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_SEND_MESSAGES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#33
Datadog::Tracing::Contrib::Kafka::Ext::TAG_PARTITION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#34
Datadog::Tracing::Contrib::Kafka::Ext::TAG_REQUEST_SIZE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#35
Datadog::Tracing::Contrib::Kafka::Ext::TAG_RESPONSE_SIZE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#36
Datadog::Tracing::Contrib::Kafka::Ext::TAG_SENT_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#37
Datadog::Tracing::Contrib::Kafka::Ext::TAG_TOPIC = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/kafka/ext.rb#38
Datadog::Tracing::Contrib::Kafka::Ext::TAG_TOPIC_PARTITIONS = T.let(T.unsafe(nil), String)

# Description of Kafka integration
#
# source://datadog//lib/datadog/tracing/contrib/kafka/integration.rb#12
class Datadog::Tracing::Contrib::Kafka::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/kafka/integration.rb#36
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/integration.rb#40
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/kafka/integration.rb#32
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/integration.rb#19
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/kafka/integration.rb#27
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/integration.rb#23
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/kafka/integration.rb#15
Datadog::Tracing::Contrib::Kafka::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'kafka' module.
#
# source://datadog//lib/datadog/tracing/contrib/kafka/patcher.rb#12
module Datadog::Tracing::Contrib::Kafka::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/kafka/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/kafka/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/kafka/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/kafka/patcher.rb#17
    def target_version; end
  end
end

# `Karafka` integration public API
#
# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#6
module Datadog::Tracing::Contrib::Karafka
  class << self
    # source://datadog//lib/datadog/tracing/contrib/karafka.rb#18
    def extract(data); end

    # source://datadog//lib/datadog/tracing/contrib/karafka.rb#12
    def inject(digest, data); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/karafka/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Karafka::Configuration; end

# source://datadog//lib/datadog/tracing/contrib/karafka/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Karafka::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/karafka/configuration/settings.rb#21
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/karafka/configuration/settings.rb#21
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/karafka/configuration/settings.rb#13
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/karafka/configuration/settings.rb#13
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/karafka/configuration/settings.rb#19
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/karafka/configuration/settings.rb#19
  def service_name=(value); end
end

# source://datadog//lib/datadog/tracing/contrib/karafka/distributed/propagation.rb#16
module Datadog::Tracing::Contrib::Karafka::Distributed; end

# Extracts and injects propagation through Kafka message headers.
#
# source://datadog//lib/datadog/tracing/contrib/karafka/distributed/propagation.rb#18
class Datadog::Tracing::Contrib::Karafka::Distributed::Propagation < ::Datadog::Tracing::Distributed::Propagation
  # @return [Propagation] a new instance of Propagation
  #
  # source://datadog//lib/datadog/tracing/contrib/karafka/distributed/propagation.rb#19
  def initialize(propagation_style_inject:, propagation_style_extract:, propagation_extract_first:); end
end

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#7
module Datadog::Tracing::Contrib::Karafka::Ext; end

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#8
Datadog::Tracing::Contrib::Karafka::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#10
Datadog::Tracing::Contrib::Karafka::Ext::SPAN_MESSAGE_CONSUME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#11
Datadog::Tracing::Contrib::Karafka::Ext::SPAN_WORKER_PROCESS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#13
Datadog::Tracing::Contrib::Karafka::Ext::TAG_CONSUMER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#18
Datadog::Tracing::Contrib::Karafka::Ext::TAG_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#19
Datadog::Tracing::Contrib::Karafka::Ext::TAG_MESSAGE_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#16
Datadog::Tracing::Contrib::Karafka::Ext::TAG_OFFSET = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#17
Datadog::Tracing::Contrib::Karafka::Ext::TAG_OFFSET_LAG = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#22
Datadog::Tracing::Contrib::Karafka::Ext::TAG_OPERATION_PROCESS_BATCH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#15
Datadog::Tracing::Contrib::Karafka::Ext::TAG_PARTITION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#20
Datadog::Tracing::Contrib::Karafka::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/karafka/ext.rb#14
Datadog::Tracing::Contrib::Karafka::Ext::TAG_TOPIC = T.let(T.unsafe(nil), String)

# Description of Kafka integration
#
# source://datadog//lib/datadog/tracing/contrib/karafka/integration.rb#12
class Datadog::Tracing::Contrib::Karafka::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/karafka/integration.rb#34
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/karafka/integration.rb#38
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/karafka/integration.rb#30
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/karafka/integration.rb#26
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/karafka/integration.rb#22
    def version; end
  end
end

# Minimum version of the Karafka library that we support
# https://karafka.io/docs/Versions-Lifecycle-and-EOL/#versioning-strategy
#
# source://datadog//lib/datadog/tracing/contrib/karafka/integration.rb#17
Datadog::Tracing::Contrib::Karafka::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patch to add tracing to Karafka::Messages::Messages
#
# source://datadog//lib/datadog/tracing/contrib/karafka/patcher.rb#12
module Datadog::Tracing::Contrib::Karafka::MessagesPatch
  # source://datadog//lib/datadog/tracing/contrib/karafka/patcher.rb#13
  def configuration; end

  # `each` is the most popular access point to Karafka messages,
  # but not the only one
  #  Other access patterns do not have a straightforward tracing avenue
  # (e.g. `my_batch_operation messages.payloads`)
  #
  # @see https://github.com/karafka/karafka/blob/b06d1f7c17818e1605f80c2bb573454a33376b40/README.md?plain=1#L29-L35
  #
  # source://datadog//lib/datadog/tracing/contrib/karafka/patcher.rb#26
  def each(&block); end

  # source://datadog//lib/datadog/tracing/contrib/karafka/patcher.rb#17
  def propagation; end
end

# Patcher enables patching of 'karafka' module.
#
# source://datadog//lib/datadog/tracing/contrib/karafka/patcher.rb#52
module Datadog::Tracing::Contrib::Karafka::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/karafka/patcher.rb#61
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/karafka/patcher.rb#57
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/karafka/patcher.rb#61
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/karafka/patcher.rb#57
    def target_version; end
  end
end

# Datadog Lograge integration.
#
# source://datadog//lib/datadog/tracing/contrib/lograge/ext.rb#6
module Datadog::Tracing::Contrib::Lograge; end

# source://datadog//lib/datadog/tracing/contrib/lograge/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Lograge::Configuration; end

# Custom settings for the Lograge integration
#
# source://datadog//lib/datadog/tracing/contrib/lograge/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Lograge::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/lograge/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/lograge/configuration/settings.rb#14
  def enabled=(value); end
end

# Lograge integration constants
#
# source://datadog//lib/datadog/tracing/contrib/lograge/ext.rb#9
module Datadog::Tracing::Contrib::Lograge::Ext; end

# source://datadog//lib/datadog/tracing/contrib/lograge/ext.rb#10
Datadog::Tracing::Contrib::Lograge::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Instrumentation for Lograge
#
# source://datadog//lib/datadog/tracing/contrib/lograge/instrumentation.rb#8
module Datadog::Tracing::Contrib::Lograge::Instrumentation
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/lograge/instrumentation.rb#9
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://datadog//lib/datadog/tracing/contrib/lograge/instrumentation.rb#14
module Datadog::Tracing::Contrib::Lograge::Instrumentation::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/lograge/instrumentation.rb#15
  def custom_options(event); end
end

# Description of Lograge integration
#
# source://datadog//lib/datadog/tracing/contrib/lograge/integration.rb#12
class Datadog::Tracing::Contrib::Lograge::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration and has a hard dependancy on rails
  # so can safely say this shouldn't ever be part of auto instrumentation
  # https://github.com/roidrage/lograge/blob/1729eab7956bb95c5992e4adab251e4f93ff9280/lograge.gemspec#L18-L20
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/lograge/integration.rb#35
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/lograge/integration.rb#39
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/lograge/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/lograge/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/lograge/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/lograge/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/lograge/integration.rb#15
Datadog::Tracing::Contrib::Lograge::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'lograge' module.
#
# source://datadog//lib/datadog/tracing/contrib/lograge/patcher.rb#12
module Datadog::Tracing::Contrib::Lograge::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch
  #
  # source://datadog//lib/datadog/tracing/contrib/lograge/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/lograge/patcher.rb#17
  def target_version; end

  class << self
    # patch applies our patch
    #
    # source://datadog//lib/datadog/tracing/contrib/lograge/patcher.rb#22
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/lograge/patcher.rb#17
    def target_version; end
  end
end

# MongoDB module includes classes and functions to instrument MongoDB clients
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#6
module Datadog::Tracing::Contrib::MongoDB
  private

  # source://datadog//lib/datadog/tracing/contrib/mongodb/parsers.rb#43
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/parsers.rb#39
  def quantization_options; end

  # returns a formatted and normalized query
  #
  # source://datadog//lib/datadog/tracing/contrib/mongodb/parsers.rb#21
  def query_builder(command_name, database_name, command); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/mongodb/parsers.rb#43
    def configuration; end

    # source://datadog//lib/datadog/tracing/contrib/mongodb/parsers.rb#39
    def quantization_options; end

    # returns a formatted and normalized query
    #
    # source://datadog//lib/datadog/tracing/contrib/mongodb/parsers.rb#21
    def query_builder(command_name, database_name, command); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#10
module Datadog::Tracing::Contrib::MongoDB::Configuration; end

# Custom settings for the MongoDB integration
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#13
class Datadog::Tracing::Contrib::MongoDB::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#23
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#23
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#29
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#29
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#54
  def json_command; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#54
  def json_command=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#47
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#47
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#35
  def quantize; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#35
  def quantize=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#37
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#37
  def service_name=(value); end
end

# source://datadog//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#14
Datadog::Tracing::Contrib::MongoDB::Configuration::Settings::DEFAULT_QUANTIZE = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/tracing/contrib/mongodb/parsers.rb#12
Datadog::Tracing::Contrib::MongoDB::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/tracing/contrib/mongodb/parsers.rb#10
Datadog::Tracing::Contrib::MongoDB::EXCLUDE_KEYS = T.let(T.unsafe(nil), Array)

# MongoDB integration constants
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#9
module Datadog::Tracing::Contrib::MongoDB::Ext; end

# Temporary namespace to accommodate unified tags which has naming collision, before
# making breaking changes
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#32
module Datadog::Tracing::Contrib::MongoDB::Ext::DB; end

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#33
Datadog::Tracing::Contrib::MongoDB::Ext::DB::TAG_COLLECTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#17
Datadog::Tracing::Contrib::MongoDB::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#14
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#15
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#10
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#16
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_JSON_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#12
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#11
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#28
Datadog::Tracing::Contrib::MongoDB::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#18
Datadog::Tracing::Contrib::MongoDB::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#19
Datadog::Tracing::Contrib::MongoDB::Ext::SPAN_TYPE_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#20
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_COLLECTION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#25
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#21
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_DB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#22
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_OPERATION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#26
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#23
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#24
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_ROWS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mongodb/ext.rb#27
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Instrumentation for Mongo integration
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#12
module Datadog::Tracing::Contrib::MongoDB::Instrumentation; end

# Instrumentation for Mongo::Client
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#14
module Datadog::Tracing::Contrib::MongoDB::Instrumentation::Client
  include ::Datadog::Tracing::Contrib::MongoDB::Instrumentation::Client::InstanceMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#15
    def included(base); end
  end
end

# Instance methods for Mongo::Client
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#20
module Datadog::Tracing::Contrib::MongoDB::Instrumentation::Client::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#21
  def datadog_pin; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#30
  def datadog_pin=(pin); end
end

# Description of MongoDB integration
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/integration.rb#13
class Datadog::Tracing::Contrib::MongoDB::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/mongodb/integration.rb#36
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/integration.rb#40
  def patcher; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/integration.rb#44
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/mongodb/integration.rb#32
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/mongodb/integration.rb#20
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/mongodb/integration.rb#28
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/mongodb/integration.rb#24
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/mongodb/integration.rb#16
Datadog::Tracing::Contrib::MongoDB::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# `MongoCommandSubscriber` listens to all events from the `Monitoring`
# system available in the Mongo driver.
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#17
class Datadog::Tracing::Contrib::MongoDB::MongoCommandSubscriber
  # source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#80
  def failed(event); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#19
  def started(event); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#96
  def succeeded(event); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#145
  def analytics_enabled?; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#149
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#139
  def clear_span(event); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#153
  def datadog_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#129
  def get_span(event); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#114
  def serialize_query(query); end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/subscribers.rb#134
  def set_span(event, span); end
end

# skipped keys are related to command names, since they are already
# extracted by the query_builder
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/parsers.rb#18
Datadog::Tracing::Contrib::MongoDB::PLACEHOLDER = T.let(T.unsafe(nil), String)

# Patcher enables patching of 'mongo' module.
#
# source://datadog//lib/datadog/tracing/contrib/mongodb/patcher.rb#12
module Datadog::Tracing::Contrib::MongoDB::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/mongodb/patcher.rb#26
  def add_mongo_monitoring; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/mongodb/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/mongodb/patcher.rb#26
    def add_mongo_monitoring; end

    # source://datadog//lib/datadog/tracing/contrib/mongodb/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/mongodb/patcher.rb#17
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/mongodb/parsers.rb#11
Datadog::Tracing::Contrib::MongoDB::SHOW_KEYS = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#6
module Datadog::Tracing::Contrib::Mysql2; end

# source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Mysql2::Configuration; end

# Custom settings for the Mysql2 integration
#
# source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Mysql2::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#23
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#23
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#29
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#29
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#51
  def append_comment; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#51
  def append_comment=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#45
  def comment_propagation; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#45
  def comment_propagation=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#61
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#61
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#56
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#56
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#35
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#35
  def service_name=(value); end
end

# Mysql2 integration constants
#
# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#9
module Datadog::Tracing::Contrib::Mysql2::Ext; end

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#17
Datadog::Tracing::Contrib::Mysql2::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#15
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#16
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#10
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#12
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#11
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#23
Datadog::Tracing::Contrib::Mysql2::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#18
Datadog::Tracing::Contrib::Mysql2::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#20
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#19
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_DB_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#21
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/mysql2/ext.rb#22
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Mysql2::Client patch module
#
# source://datadog//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#15
module Datadog::Tracing::Contrib::Mysql2::Instrumentation
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#16
    def included(base); end
  end
end

# Mysql2::Client patch instance methods
#
# source://datadog//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#21
module Datadog::Tracing::Contrib::Mysql2::Instrumentation::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#22
  def query(sql, options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#84
  def analytics_enabled?; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#88
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#80
  def datadog_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#65
  def inject_propagation(span, sql, trace_op); end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#99
  def set_span_tags(span, query_options); end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#92
  def tag_database_instance(span, database); end
end

# Description of Mysql2 integration
#
# source://datadog//lib/datadog/tracing/contrib/mysql2/integration.rb#12
class Datadog::Tracing::Contrib::Mysql2::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/mysql2/integration.rb#32
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/mysql2/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/mysql2/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/mysql2/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/mysql2/integration.rb#15
Datadog::Tracing::Contrib::Mysql2::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'mysql2' module.
#
# source://datadog//lib/datadog/tracing/contrib/mysql2/patcher.rb#11
module Datadog::Tracing::Contrib::Mysql2::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/mysql2/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/patcher.rb#24
  def patch_mysql2_client; end

  # source://datadog//lib/datadog/tracing/contrib/mysql2/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/mysql2/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/mysql2/patcher.rb#24
    def patch_mysql2_client; end

    # source://datadog//lib/datadog/tracing/contrib/mysql2/patcher.rb#16
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#6
module Datadog::Tracing::Contrib::OpenSearch; end

# source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#10
module Datadog::Tracing::Contrib::OpenSearch::Configuration; end

# Custom settings for the OpenSearch integration
#
# source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#13
class Datadog::Tracing::Contrib::OpenSearch::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#45
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#45
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#33
  def quantize; end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#33
  def quantize=(value); end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#50
  def resource_pattern; end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#50
  def resource_pattern=(value); end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#35
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#35
  def service_name=(value); end
end

# OpenSearch integration constants
#
# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#9
module Datadog::Tracing::Contrib::OpenSearch::Ext; end

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#17
Datadog::Tracing::Contrib::OpenSearch::Ext::ABSOLUTE_RESOURCE_PATTERN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#25
Datadog::Tracing::Contrib::OpenSearch::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# Default should be changed to RELATIVE in 3.0 to match the Elasticsearch integration
#
# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#24
Datadog::Tracing::Contrib::OpenSearch::Ext::DEFAULT_RESOURCE_PATTERN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#14
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#15
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#10
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#12
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#16
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_RESOURCE_PATTERN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#11
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#39
Datadog::Tracing::Contrib::OpenSearch::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#18
Datadog::Tracing::Contrib::OpenSearch::Ext::RELATIVE_RESOURCE_PATTERN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#26
Datadog::Tracing::Contrib::OpenSearch::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#27
Datadog::Tracing::Contrib::OpenSearch::Ext::SPAN_TYPE_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#33
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_BODY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#28
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#35
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_HOST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#30
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#32
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_PARAMS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#31
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_PATH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#36
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_PORT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#38
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_RESPONSE_CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#37
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_SCHEME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#29
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#34
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_URL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/opensearch/ext.rb#19
Datadog::Tracing::Contrib::OpenSearch::Ext::VALID_RESOURCE_PATTERNS = T.let(T.unsafe(nil), Array)

# Description of OpenSearch integration
#
# source://datadog//lib/datadog/tracing/contrib/opensearch/integration.rb#12
class Datadog::Tracing::Contrib::OpenSearch::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/opensearch/integration.rb#35
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/integration.rb#39
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/opensearch/integration.rb#31
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/opensearch/integration.rb#19
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/opensearch/integration.rb#27
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/opensearch/integration.rb#23
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/opensearch/integration.rb#15
Datadog::Tracing::Contrib::OpenSearch::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'opensearch' module.
#
# source://datadog//lib/datadog/tracing/contrib/opensearch/patcher.rb#16
module Datadog::Tracing::Contrib::OpenSearch::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/opensearch/patcher.rb#21
  def patch; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/opensearch/patcher.rb#21
    def patch; end
  end
end

# Patches OpenSearch::Transport::Client module
#
# source://datadog//lib/datadog/tracing/contrib/opensearch/patcher.rb#30
module Datadog::Tracing::Contrib::OpenSearch::Patcher::Client
  # source://datadog//lib/datadog/tracing/contrib/opensearch/patcher.rb#135
  def datadog_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/patcher.rb#33
  def perform_request(method, path, params = T.unsafe(nil), body = T.unsafe(nil), headers = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/patcher.rb#123
  def tag_body(body, span); end

  # source://datadog//lib/datadog/tracing/contrib/opensearch/patcher.rb#116
  def tag_params(params, span); end
end

# Base provides features that are shared across all integrations
#
# source://datadog//lib/datadog/tracing/contrib/patchable.rb#7
module Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods

  mixes_in_class_methods ::Datadog::Tracing::Contrib::Patchable::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/patchable.rb#8
    def included(base); end
  end
end

# Class methods for integrations
#
# source://datadog//lib/datadog/tracing/contrib/patchable.rb#15
module Datadog::Tracing::Contrib::Patchable::ClassMethods
  # Is the target available to be instrumented? (e.g. gem installed?)
  #
  # The target doesn't have to be loaded (e.g. `require`) yet, but needs to be able
  # to be loaded before instrumentation can commence.
  #
  # By default, {.available?} checks if {.version} returned a non-nil object.
  #
  # If the target for instrumentation has concept of versioning, override {.version},
  # otherwise override {.available?} and implement a custom target presence check.
  #
  # @return [Boolean] is the target available for instrumentation in this Ruby environment?
  #
  # source://datadog//lib/datadog/tracing/contrib/patchable.rb#37
  def available?; end

  # Is this instrumentation compatible with the available target? (e.g. minimum version met?)
  #
  # @return [Boolean] is the available target compatible with this instrumentation?
  #
  # source://datadog//lib/datadog/tracing/contrib/patchable.rb#53
  def compatible?; end

  # Is the target loaded into the application? (e.g. gem required? Constant defined?)
  #
  # The target's objects should be ready to be referenced by the instrumented when {.loaded}
  # returns `true`.
  #
  # @return [Boolean] is the target ready to be referenced during instrumentation?
  #
  # source://datadog//lib/datadog/tracing/contrib/patchable.rb#47
  def loaded?; end

  # Can the patch for this integration be applied?
  #
  # By default, this is equivalent to {#available?}, {#loaded?}, and {#compatible?}
  # all being truthy.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/patchable.rb#61
  def patchable?; end

  # Version of the integration target code in the environment.
  #
  # This is the gem version, when the instrumentation target is a Ruby gem.
  #
  # If the target for instrumentation has concept of versioning, override {.version},
  # otherwise override {.available?} and implement a custom target presence check.
  #
  # @return [Object] the target version
  #
  # source://datadog//lib/datadog/tracing/contrib/patchable.rb#23
  def version; end
end

# Instance methods for integrations
#
# source://datadog//lib/datadog/tracing/contrib/patchable.rb#68
module Datadog::Tracing::Contrib::Patchable::InstanceMethods
  # Can the patch for this integration be applied automatically?
  # For example: test integrations should only be applied
  # by the user explicitly setting `c.ci.instrument :rspec`
  # and rails sub-modules are auto-instrumented by enabling rails
  # so auto-instrumenting them on their own will cause changes in
  # service naming behavior
  #
  # @return [Boolean] can the tracer activate this instrumentation without explicit user input?
  #
  # source://datadog//lib/datadog/tracing/contrib/patchable.rb#102
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/patchable.rb#80
  def patch; end

  # The patcher module to inject instrumented objects into the instrumentation target.
  #
  # {Contrib::Patcher} includes the basic functionality of a patcher. `include`ing
  # {Contrib::Patcher} into a new module is the recommend way to create a custom patcher.
  #
  # @return [Contrib::Patcher] a module that `include`s {Contrib::Patcher}
  #
  # source://datadog//lib/datadog/tracing/contrib/patchable.rb#75
  def patcher; end
end

# Common behavior for patcher modules.
#
# `include`ing {Contrib::Patcher} into a new module is the recommend way to create a custom patcher.
# The patcher can then be provided to a custom {Datadog::Tracing::Contrib::Integration} for instrumentation.
#
# source://datadog//lib/datadog/tracing/contrib/patcher.rb#13
module Datadog::Tracing::Contrib::Patcher
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/patcher.rb#14
    def included(base); end
  end
end

# Prepended instance methods for all patchers
#
# source://datadog//lib/datadog/tracing/contrib/patcher.rb#21
module Datadog::Tracing::Contrib::Patcher::CommonMethods
  # source://datadog//lib/datadog/tracing/contrib/patcher.rb#70
  def default_tags; end

  # Processes patching errors. This default implementation logs the error and reports relevant metrics.
  #
  # @param e [Exception]
  #
  # source://datadog//lib/datadog/tracing/contrib/patcher.rb#53
  def on_patch_error(e); end

  # source://datadog//lib/datadog/tracing/contrib/patcher.rb#37
  def patch; end

  # Returns the value of attribute patch_error_result.
  #
  # source://datadog//lib/datadog/tracing/contrib/patcher.rb#22
  def patch_error_result; end

  # Sets the attribute patch_error_result
  #
  # @param value the value to set the attribute patch_error_result to.
  #
  # source://datadog//lib/datadog/tracing/contrib/patcher.rb#22
  def patch_error_result=(_arg0); end

  # source://datadog//lib/datadog/tracing/contrib/patcher.rb#29
  def patch_name; end

  # source://datadog//lib/datadog/tracing/contrib/patcher.rb#25
  def patch_successful; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/patcher.rb#33
  def patched?; end

  private

  # source://datadog//lib/datadog/tracing/contrib/patcher.rb#79
  def patch_only_once; end
end

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#6
module Datadog::Tracing::Contrib::Pg; end

# source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Pg::Configuration; end

# Custom settings for the Pg integration
#
# source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Pg::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#23
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#23
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#33
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#33
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#55
  def append_comment; end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#55
  def append_comment=(value); end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#49
  def comment_propagation; end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#49
  def comment_propagation=(value); end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#29
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#29
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#60
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#60
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#39
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/pg/configuration/settings.rb#39
  def service_name=(value); end
end

# pg integration constants
#
# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#9
module Datadog::Tracing::Contrib::Pg::Ext; end

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#16
Datadog::Tracing::Contrib::Pg::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#14
Datadog::Tracing::Contrib::Pg::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#15
Datadog::Tracing::Contrib::Pg::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#10
Datadog::Tracing::Contrib::Pg::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#12
Datadog::Tracing::Contrib::Pg::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#11
Datadog::Tracing::Contrib::Pg::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#30
Datadog::Tracing::Contrib::Pg::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#20
Datadog::Tracing::Contrib::Pg::Ext::SPAN_ASYNC_EXEC = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#21
Datadog::Tracing::Contrib::Pg::Ext::SPAN_ASYNC_EXEC_PARAMS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#22
Datadog::Tracing::Contrib::Pg::Ext::SPAN_ASYNC_EXEC_PREPARED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#17
Datadog::Tracing::Contrib::Pg::Ext::SPAN_EXEC = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#18
Datadog::Tracing::Contrib::Pg::Ext::SPAN_EXEC_PARAMS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#19
Datadog::Tracing::Contrib::Pg::Ext::SPAN_EXEC_PREPARED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#23
Datadog::Tracing::Contrib::Pg::Ext::SPAN_SYNC_EXEC = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#24
Datadog::Tracing::Contrib::Pg::Ext::SPAN_SYNC_EXEC_PARAMS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#25
Datadog::Tracing::Contrib::Pg::Ext::SPAN_SYNC_EXEC_PREPARED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#27
Datadog::Tracing::Contrib::Pg::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#26
Datadog::Tracing::Contrib::Pg::Ext::TAG_DB_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#28
Datadog::Tracing::Contrib::Pg::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/pg/ext.rb#29
Datadog::Tracing::Contrib::Pg::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# PG::Connection patch module
#
# source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#16
module Datadog::Tracing::Contrib::Pg::Instrumentation
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#17
    def included(base); end
  end
end

# PG::Connection patch methods
#
# source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#22
module Datadog::Tracing::Contrib::Pg::Instrumentation::InstanceMethods
  # async_exec is an alias to exec
  #
  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#48
  def async_exec(sql, *args, &block); end

  # async_exec_params is an alias to exec_params
  #
  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#57
  def async_exec_params(sql, params, *args, &block); end

  # async_exec_prepared is an alias to exec_prepared
  #
  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#66
  def async_exec_prepared(statement_name, params, *args, &block); end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#23
  def exec(sql, *args, &block); end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#31
  def exec_params(sql, params, *args, &block); end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#39
  def exec_prepared(statement_name, params, *args, &block); end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#74
  def sync_exec(sql, *args, &block); end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#82
  def sync_exec_params(sql, params, *args, &block); end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#90
  def sync_exec_prepared(statement_name, params, *args, &block); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#194
  def analytics_enabled?; end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#198
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#152
  def annotate_span_with_query!(span, service); end

  # @param result [PG::Result]
  #
  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#186
  def annotate_span_with_result!(span, result); end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#202
  def comment_propagation; end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#190
  def datadog_configuration; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#206
  def enabled?; end

  # source://datadog//lib/datadog/tracing/contrib/pg/instrumentation.rb#100
  def trace(name, sql: T.unsafe(nil), statement_name: T.unsafe(nil), block: T.unsafe(nil)); end
end

# Description of pg integration
#
# source://datadog//lib/datadog/tracing/contrib/pg/integration.rb#12
class Datadog::Tracing::Contrib::Pg::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/pg/integration.rb#32
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/pg/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/pg/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/pg/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/pg/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/pg/integration.rb#15
Datadog::Tracing::Contrib::Pg::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'pg' module.
#
# source://datadog//lib/datadog/tracing/contrib/pg/patcher.rb#11
module Datadog::Tracing::Contrib::Pg::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/pg/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/pg/patcher.rb#24
  def patch_pg_connection; end

  # source://datadog//lib/datadog/tracing/contrib/pg/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/pg/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/pg/patcher.rb#24
    def patch_pg_connection; end

    # source://datadog//lib/datadog/tracing/contrib/pg/patcher.rb#16
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#6
module Datadog::Tracing::Contrib::Presto; end

# source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Presto::Configuration; end

# Custom settings for the Presto integration
#
# source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Presto::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#43
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#43
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/presto/configuration/settings.rb#33
  def service_name=(value); end
end

# Presto integration constants
#
# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#9
module Datadog::Tracing::Contrib::Presto::Ext; end

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#16
Datadog::Tracing::Contrib::Presto::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#14
Datadog::Tracing::Contrib::Presto::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#15
Datadog::Tracing::Contrib::Presto::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#10
Datadog::Tracing::Contrib::Presto::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#12
Datadog::Tracing::Contrib::Presto::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#11
Datadog::Tracing::Contrib::Presto::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#32
Datadog::Tracing::Contrib::Presto::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#18
Datadog::Tracing::Contrib::Presto::Ext::SPAN_KILL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#17
Datadog::Tracing::Contrib::Presto::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#20
Datadog::Tracing::Contrib::Presto::Ext::TAG_CATALOG_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#28
Datadog::Tracing::Contrib::Presto::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#23
Datadog::Tracing::Contrib::Presto::Ext::TAG_LANGUAGE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#25
Datadog::Tracing::Contrib::Presto::Ext::TAG_MODEL_VERSION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#30
Datadog::Tracing::Contrib::Presto::Ext::TAG_OPERATION_KILL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#29
Datadog::Tracing::Contrib::Presto::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#24
Datadog::Tracing::Contrib::Presto::Ext::TAG_PROXY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#27
Datadog::Tracing::Contrib::Presto::Ext::TAG_QUERY_ASYNC = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#26
Datadog::Tracing::Contrib::Presto::Ext::TAG_QUERY_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#19
Datadog::Tracing::Contrib::Presto::Ext::TAG_SCHEMA_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#31
Datadog::Tracing::Contrib::Presto::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#22
Datadog::Tracing::Contrib::Presto::Ext::TAG_TIME_ZONE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/presto/ext.rb#21
Datadog::Tracing::Contrib::Presto::Ext::TAG_USER_NAME = T.let(T.unsafe(nil), String)

# Instrumentation for Presto integration
#
# source://datadog//lib/datadog/tracing/contrib/presto/instrumentation.rb#11
module Datadog::Tracing::Contrib::Presto::Instrumentation; end

# Instrumentation for Presto::Client::Client
#
# source://datadog//lib/datadog/tracing/contrib/presto/instrumentation.rb#13
module Datadog::Tracing::Contrib::Presto::Instrumentation::Client
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/presto/instrumentation.rb#14
    def included(base); end
  end
end

# Instance methods for Presto::Client
#
# source://datadog//lib/datadog/tracing/contrib/presto/instrumentation.rb#19
module Datadog::Tracing::Contrib::Presto::Instrumentation::Client::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/presto/instrumentation.rb#56
  def kill(query_id); end

  # source://datadog//lib/datadog/tracing/contrib/presto/instrumentation.rb#38
  def query(query, &blk); end

  # source://datadog//lib/datadog/tracing/contrib/presto/instrumentation.rb#20
  def run(query); end

  private

  # source://datadog//lib/datadog/tracing/contrib/presto/instrumentation.rb#77
  def datadog_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/presto/instrumentation.rb#81
  def decorate!(span, operation); end

  # source://datadog//lib/datadog/tracing/contrib/presto/instrumentation.rb#129
  def set_nilable_tag!(span, key, tag_name); end
end

# Description of Presto integration
#
# source://datadog//lib/datadog/tracing/contrib/presto/integration.rb#12
class Datadog::Tracing::Contrib::Presto::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/presto/integration.rb#35
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/presto/integration.rb#39
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/presto/integration.rb#31
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/presto/integration.rb#19
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/presto/integration.rb#27
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/presto/integration.rb#23
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/presto/integration.rb#15
Datadog::Tracing::Contrib::Presto::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'presto-client' module.
#
# source://datadog//lib/datadog/tracing/contrib/presto/patcher.rb#13
module Datadog::Tracing::Contrib::Presto::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/presto/patcher.rb#18
  def patch; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/presto/patcher.rb#18
    def patch; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#8
module Datadog::Tracing::Contrib::Propagation; end

# Implements sql comment propagation related contracts.
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#9
module Datadog::Tracing::Contrib::Propagation::SqlComment
  class << self
    # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment.rb#14
    def annotate!(span_op, mode); end

    # Inject span_op and trace_op instead of TraceDigest to improve memory usage
    # for `disabled` and `service` mode
    #
    # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment.rb#22
    def prepend_comment(sql, span_op, trace_op, mode); end
  end
end

# To be prepended to a sql statement.
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#11
class Datadog::Tracing::Contrib::Propagation::SqlComment::Comment
  # @return [Comment] a new instance of Comment
  #
  # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#12
  def initialize(hash); end

  # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#16
  def to_s; end
end

# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#8
module Datadog::Tracing::Contrib::Propagation::SqlComment::Ext; end

# The default mode for sql comment propagation
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#12
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::DISABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#9
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::ENV_DBM_PROPAGATION_MODE = T.let(T.unsafe(nil), String)

# The `full` mode propagates service configuration + trace context
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#18
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::FULL = T.let(T.unsafe(nil), String)

# Database service/sql span service (i.e. the service executing the actual query)
#
# If fake services are disabled:
#   This value will be the same as the parent service
#
# If fake services are enabled:
#   This value is NOT the same as the parent service
#
# This should NOT be overridden by peer.service.
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#32
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_DATABASE_SERVICE = T.let(T.unsafe(nil), String)

# @see Datadog::Tracing::Contrib::Ext::DB::TAG_INSTANCE
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#48
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_DB_NAME = T.let(T.unsafe(nil), String)

# The global service environment (e.g. DD_ENV)
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#35
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_ENVIRONMENT = T.let(T.unsafe(nil), String)

# The hostname of the database server, as provided to the database client upon instantiation.
#
# @see Datadog::Tracing::Metadata::Ext::TAG_PEER_HOSTNAME
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#45
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_HOSTNAME = T.let(T.unsafe(nil), String)

# The global service name (e.g. DD_SERVICE)
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#38
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_PARENT_SERVICE = T.let(T.unsafe(nil), String)

# Users can use this attribute to specify the identity of the dependency/database they are connecting to.
# We should grab this attribute only if the user is EXPLICITLY specifying it.
#
# @see Datadog::Tracing::Metadata::Ext::TAG_PEER_SERVICE
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#53
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#55
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_TRACEPARENT = T.let(T.unsafe(nil), String)

# The global service version (e.g. DD_VERSION)
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#41
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_VERSION = T.let(T.unsafe(nil), String)

# The `service` mode propagates service configuration
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#15
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::SERVICE = T.let(T.unsafe(nil), String)

# The value should be `true` when `full` mode
#
# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#21
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::TAG_DBM_TRACE_INJECTED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
class Datadog::Tracing::Contrib::Propagation::SqlComment::Mode < ::Struct
  # Returns the value of attribute append
  #
  # @return [Object] the current value of append
  #
  # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
  def append; end

  # Sets the attribute append
  #
  # @param value [Object] the value to set the attribute append to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
  def append=(_); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#24
  def append?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#12
  def enabled?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#20
  def full?; end

  # Returns the value of attribute mode
  #
  # @return [Object] the current value of mode
  #
  # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
  def mode; end

  # Sets the attribute mode
  #
  # @param value [Object] the value to set the attribute mode to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
  def mode=(_); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#16
  def service?; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
    def [](*_arg0); end

    # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
    def inspect; end

    # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
    def keyword_init?; end

    # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
    def members; end

    # source://datadog//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
    def new(*_arg0); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#6
module Datadog::Tracing::Contrib::Que; end

# source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Que::Configuration; end

# Default settings for the Que integration
#
# source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Que::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#23
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#23
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#29
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#29
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#14
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#14
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#47
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#47
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#13
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#13
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#35
  def tag_args; end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#35
  def tag_args=(value); end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#41
  def tag_data; end

  # source://datadog//lib/datadog/tracing/contrib/que/configuration/settings.rb#41
  def tag_data=(value); end
end

# Que integration constants
#
# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#9
module Datadog::Tracing::Contrib::Que::Ext; end

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#11
Datadog::Tracing::Contrib::Que::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#12
Datadog::Tracing::Contrib::Que::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#13
Datadog::Tracing::Contrib::Que::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#14
Datadog::Tracing::Contrib::Que::Ext::ENV_TAG_ARGS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#15
Datadog::Tracing::Contrib::Que::Ext::ENV_TAG_DATA_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#16
Datadog::Tracing::Contrib::Que::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#17
Datadog::Tracing::Contrib::Que::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#27
Datadog::Tracing::Contrib::Que::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#18
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_ARGS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#19
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_DATA = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#20
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_ERROR_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#21
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_EXPIRED_AT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#22
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_FINISHED_AT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#23
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#24
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_PRIORITY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#25
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#26
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_RUN_AT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/que/ext.rb#28
Datadog::Tracing::Contrib::Que::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Que integration
#
# source://datadog//lib/datadog/tracing/contrib/que/integration.rb#13
class Datadog::Tracing::Contrib::Que::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/que/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/que/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/que/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/que/integration.rb#25
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/que/integration.rb#21
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/que/integration.rb#16
Datadog::Tracing::Contrib::Que::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'que' module.
#
# source://datadog//lib/datadog/tracing/contrib/que/patcher.rb#10
module Datadog::Tracing::Contrib::Que::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/que/patcher.rb#19
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/que/patcher.rb#15
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/que/patcher.rb#19
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/que/patcher.rb#15
    def target_version; end
  end
end

# Tracer is a Que's server-side middleware which traces executed jobs
#
# source://datadog//lib/datadog/tracing/contrib/que/tracer.rb#10
class Datadog::Tracing::Contrib::Que::Tracer
  # source://datadog//lib/datadog/tracing/contrib/que/tracer.rb#11
  def call(job); end

  private

  # source://datadog//lib/datadog/tracing/contrib/que/tracer.rb#56
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/que/tracer.rb#47
  def set_sample_rate(request_span); end
end

# Registry is a global, declarative repository of all available integrations.
#
# Integrations should register themselves with the registry as early as
# possible as the initial tracer configuration can only activate integrations
# if they have already been registered.
#
# Despite that, integrations *can* be appended to the registry at any point
# of the program execution. Newly appended integrations can then be
# activated during tracer reconfiguration.
#
# The registry does not depend on runtime configuration and registered integrations
# must execute correctly after successive configuration changes.
# The registered integrations themselves can depend on the stateful configuration
# of the tracer.
#
# `Datadog.registry` is a helper accessor to this constant, but it's only available
# after the tracer has complete initialization. Use `Datadog::Tracing::Contrib::REGISTRY` instead
# of `Datadog.registry` when you code might be called during tracer initialization.
#
# source://datadog//lib/datadog/tracing/contrib.rb#28
Datadog::Tracing::Contrib::REGISTRY = T.let(T.unsafe(nil), Datadog::Tracing::Contrib::Registry)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#6
module Datadog::Tracing::Contrib::Racecar; end

# source://datadog//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Racecar::Configuration; end

# Custom settings for the Racecar integration
#
# source://datadog//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Racecar::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#33
  def service_name=(value); end
end

# Defines basic behaviors for an ActiveRecord event.
#
# source://datadog//lib/datadog/tracing/contrib/racecar/event.rb#13
module Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/racecar/event.rb#14
    def included(base); end
  end
end

# Class methods for Racecar events.
# Note, they share the same process method and before_trace method.
#
# source://datadog//lib/datadog/tracing/contrib/racecar/event.rb#21
module Datadog::Tracing::Contrib::Racecar::Event::ClassMethods
  # source://datadog//lib/datadog/tracing/contrib/racecar/event.rb#32
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/event.rb#36
  def on_start(span, event, _id, payload); end

  # source://datadog//lib/datadog/tracing/contrib/racecar/event.rb#28
  def span_options; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/event.rb#22
  def subscription(*args, **kwargs); end

  private

  # Context objects are thread-bound.
  # If Racecar re-uses threads, context from a previous trace
  # could leak into the new trace. This "cleans" current context,
  # preventing such a leak.
  #
  # source://datadog//lib/datadog/tracing/contrib/racecar/event.rb#71
  def ensure_clean_context!; end
end

# Defines collection of instrumented Racecar events
#
# source://datadog//lib/datadog/tracing/contrib/racecar/events/batch.rb#10
module Datadog::Tracing::Contrib::Racecar::Events
  private

  # source://datadog//lib/datadog/tracing/contrib/racecar/events.rb#21
  def all; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/events.rb#29
  def subscribe!; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/events.rb#25
  def subscriptions; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/racecar/events.rb#21
    def all; end

    # source://datadog//lib/datadog/tracing/contrib/racecar/events.rb#29
    def subscribe!; end

    # source://datadog//lib/datadog/tracing/contrib/racecar/events.rb#25
    def subscriptions; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/racecar/events.rb#13
Datadog::Tracing::Contrib::Racecar::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for process_batch.racecar event
#
# source://datadog//lib/datadog/tracing/contrib/racecar/events/batch.rb#12
module Datadog::Tracing::Contrib::Racecar::Events::Batch
  include ::Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/racecar/events/batch.rb#19
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/events/batch.rb#23
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/events/batch.rb#27
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/racecar/events/batch.rb#19
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/racecar/events/batch.rb#23
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/racecar/events/batch.rb#27
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/racecar/events/batch.rb#15
Datadog::Tracing::Contrib::Racecar::Events::Batch::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for main_loop.racecar event
#
# source://datadog//lib/datadog/tracing/contrib/racecar/events/consume.rb#12
module Datadog::Tracing::Contrib::Racecar::Events::Consume
  include ::Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/racecar/events/consume.rb#19
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/events/consume.rb#23
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/events/consume.rb#27
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/racecar/events/consume.rb#19
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/racecar/events/consume.rb#23
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/racecar/events/consume.rb#27
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/racecar/events/consume.rb#15
Datadog::Tracing::Contrib::Racecar::Events::Consume::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for process_message.racecar event
#
# source://datadog//lib/datadog/tracing/contrib/racecar/events/message.rb#12
module Datadog::Tracing::Contrib::Racecar::Events::Message
  include ::Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/racecar/events/message.rb#19
  def event_name; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/events/message.rb#23
  def span_name; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/events/message.rb#27
  def span_options; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/racecar/events/message.rb#19
    def event_name; end

    # source://datadog//lib/datadog/tracing/contrib/racecar/events/message.rb#23
    def span_name; end

    # source://datadog//lib/datadog/tracing/contrib/racecar/events/message.rb#27
    def span_options; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/racecar/events/message.rb#15
Datadog::Tracing::Contrib::Racecar::Events::Message::EVENT_NAME = T.let(T.unsafe(nil), String)

# Racecar integration constants
#
# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#9
module Datadog::Tracing::Contrib::Racecar::Ext; end

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#14
Datadog::Tracing::Contrib::Racecar::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#12
Datadog::Tracing::Contrib::Racecar::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#13
Datadog::Tracing::Contrib::Racecar::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#10
Datadog::Tracing::Contrib::Racecar::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#16
Datadog::Tracing::Contrib::Racecar::Ext::SPAN_BATCH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#15
Datadog::Tracing::Contrib::Racecar::Ext::SPAN_CONSUME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#17
Datadog::Tracing::Contrib::Racecar::Ext::SPAN_MESSAGE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#24
Datadog::Tracing::Contrib::Racecar::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#18
Datadog::Tracing::Contrib::Racecar::Ext::TAG_CONSUMER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#19
Datadog::Tracing::Contrib::Racecar::Ext::TAG_FIRST_OFFSET = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#20
Datadog::Tracing::Contrib::Racecar::Ext::TAG_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#28
Datadog::Tracing::Contrib::Racecar::Ext::TAG_MESSAGING_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#21
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OFFSET = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#26
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OPERATION_BATCH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#25
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OPERATION_CONSUME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#27
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OPERATION_MESSAGE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#22
Datadog::Tracing::Contrib::Racecar::Ext::TAG_PARTITION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/racecar/ext.rb#23
Datadog::Tracing::Contrib::Racecar::Ext::TAG_TOPIC = T.let(T.unsafe(nil), String)

# Description of Racecar integration
#
# source://datadog//lib/datadog/tracing/contrib/racecar/integration.rb#12
class Datadog::Tracing::Contrib::Racecar::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/racecar/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/racecar/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/racecar/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/racecar/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/racecar/integration.rb#15
Datadog::Tracing::Contrib::Racecar::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'racecar' module.
#
# source://datadog//lib/datadog/tracing/contrib/racecar/patcher.rb#12
module Datadog::Tracing::Contrib::Racecar::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/racecar/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/racecar/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/racecar/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/racecar/patcher.rb#17
    def target_version; end
  end
end

# Rack module includes middlewares that are required to trace any framework
# and application built on top of Rack.
#
# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#6
module Datadog::Tracing::Contrib::Rack; end

# source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Rack::Configuration; end

# Custom settings for the Rack integration
#
# source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Rack::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#28
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#28
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#33
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#33
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#39
  def application; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#39
  def application=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#40
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#40
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#21
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#21
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#41
  def headers; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#41
  def headers=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#42
  def middleware_names; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#42
  def middleware_names=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#43
  def quantize; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#43
  def quantize=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#44
  def request_queuing; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#44
  def request_queuing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#49
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#49
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#53
  def web_service_name; end

  # source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#53
  def web_service_name=(value); end
end

# source://datadog//lib/datadog/tracing/contrib/rack/configuration/settings.rb#14
Datadog::Tracing::Contrib::Rack::Configuration::Settings::DEFAULT_HEADERS = T.let(T.unsafe(nil), Hash)

# Rack integration constants
#
# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#9
module Datadog::Tracing::Contrib::Rack::Ext; end

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#25
Datadog::Tracing::Contrib::Rack::Ext::DEFAULT_PEER_WEBSERVER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#12
Datadog::Tracing::Contrib::Rack::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#13
Datadog::Tracing::Contrib::Rack::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#10
Datadog::Tracing::Contrib::Rack::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#14
Datadog::Tracing::Contrib::Rack::Ext::RACK_ENV_REQUEST_SPAN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#16
Datadog::Tracing::Contrib::Rack::Ext::SPAN_HTTP_PROXY_QUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#15
Datadog::Tracing::Contrib::Rack::Ext::SPAN_HTTP_PROXY_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#17
Datadog::Tracing::Contrib::Rack::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#18
Datadog::Tracing::Contrib::Rack::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#19
Datadog::Tracing::Contrib::Rack::Ext::TAG_COMPONENT_HTTP_PROXY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#22
Datadog::Tracing::Contrib::Rack::Ext::TAG_OPERATION_HTTP_PROXY_QUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#21
Datadog::Tracing::Contrib::Rack::Ext::TAG_OPERATION_HTTP_PROXY_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#23
Datadog::Tracing::Contrib::Rack::Ext::TAG_OPERATION_HTTP_SERVER_QUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#20
Datadog::Tracing::Contrib::Rack::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/ext.rb#24
Datadog::Tracing::Contrib::Rack::Ext::WEBSERVER_APP = T.let(T.unsafe(nil), String)

# Classes and utilities for handling headers in Rack.
#
# source://datadog//lib/datadog/tracing/contrib/rack/header_collection.rb#10
module Datadog::Tracing::Contrib::Rack::Header
  class << self
    # source://datadog//lib/datadog/tracing/contrib/rack/header_collection.rb#33
    def to_rack_header(name); end
  end
end

# An implementation of a header collection that looks up headers from a Rack environment.
#
# source://datadog//lib/datadog/tracing/contrib/rack/header_collection.rb#12
class Datadog::Tracing::Contrib::Rack::Header::RequestHeaderCollection < ::Datadog::Core::HeaderCollection
  # Creates a header collection from a rack environment.
  #
  # @return [RequestHeaderCollection] a new instance of RequestHeaderCollection
  #
  # source://datadog//lib/datadog/tracing/contrib/rack/header_collection.rb#14
  def initialize(env); end

  # Gets the value of the header with the given name.
  # Allows this class to have a similar API to a {Hash}.
  #
  # source://datadog//lib/datadog/tracing/contrib/rack/header_collection.rb#25
  def [](header_name); end

  # Gets the value of the header with the given name.
  #
  # source://datadog//lib/datadog/tracing/contrib/rack/header_collection.rb#20
  def get(header_name); end

  # Tests whether a header with the given name exists in the environment.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/rack/header_collection.rb#28
  def key?(header_name); end
end

# Matches Rack-style headers with a matcher and sets matching headers into a span.
#
# source://datadog//lib/datadog/tracing/contrib/rack/header_tagging.rb#8
module Datadog::Tracing::Contrib::Rack::HeaderTagging
  class << self
    # source://datadog//lib/datadog/tracing/contrib/rack/header_tagging.rb#9
    def tag_request_headers(span, env, configuration); end

    # source://datadog//lib/datadog/tracing/contrib/rack/header_tagging.rb#30
    def tag_response_headers(span, headers, configuration); end
  end
end

# Description of Rack integration
#
# source://datadog//lib/datadog/tracing/contrib/rack/integration.rb#13
class Datadog::Tracing::Contrib::Rack::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/rack/integration.rb#35
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/rack/integration.rb#39
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/rack/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/rack/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/rack/integration.rb#25
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/rack/integration.rb#21
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/rack/integration.rb#16
Datadog::Tracing::Contrib::Rack::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Provides instrumentation for Rack middleware names
#
# source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#24
module Datadog::Tracing::Contrib::Rack::MiddlewareNamePatcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#64
  def get_option(option); end

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#33
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#37
  def patch_middleware_names; end

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#47
  def retain_middleware_name(middleware); end

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#29
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#64
    def get_option(option); end

    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#33
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#37
    def patch_middleware_names; end

    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#47
    def retain_middleware_name(middleware); end

    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#29
    def target_version; end
  end
end

# Provides instrumentation for `rack`
#
# source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#8
module Datadog::Tracing::Contrib::Rack::MiddlewarePatcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#17
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#13
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#17
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#13
    def target_version; end
  end
end

# Applies multiple patches
#
# source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#70
module Datadog::Tracing::Contrib::Rack::Patcher
  private

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#104
  def get_option(option); end

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#86
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#112
  def patch_error_result; end

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#108
  def patch_successful; end

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#78
  def patched?; end

  # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#82
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#104
    def get_option(option); end

    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#86
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#112
    def patch_error_result; end

    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#108
    def patch_successful; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#78
    def patched?; end

    # source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#82
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/rack/patcher.rb#71
Datadog::Tracing::Contrib::Rack::Patcher::PATCHERS = T.let(T.unsafe(nil), Array)

# Retrieves the time spent in an upstream proxy
# for the current Rack request.
#
# This time captures the request delay introduced but
# such proxy before the request made it to the Ruby
# process.
#
# source://datadog//lib/datadog/tracing/contrib/rack/request_queue.rb#13
module Datadog::Tracing::Contrib::Rack::QueueTime
  private

  # source://datadog//lib/datadog/tracing/contrib/rack/request_queue.rb#20
  def get_request_start(env, now = T.unsafe(nil)); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/rack/request_queue.rb#20
    def get_request_start(env, now = T.unsafe(nil)); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/rack/request_queue.rb#16
Datadog::Tracing::Contrib::Rack::QueueTime::MINIMUM_ACCEPTABLE_TIME_VALUE = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/contrib/rack/request_queue.rb#15
Datadog::Tracing::Contrib::Rack::QueueTime::QUEUE_START = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rack/request_queue.rb#14
Datadog::Tracing::Contrib::Rack::QueueTime::REQUEST_START = T.let(T.unsafe(nil), String)

# TraceMiddleware ensures that the Rack Request is properly traced
# from the beginning to the end. The middleware adds the request span
# in the Rack environment so that it can be retrieved by the underlying
# application. If request tags are not set by the app, they will be set using
# information available at the Rack level.
#
# source://datadog//lib/datadog/tracing/contrib/rack/middlewares.rb#29
class Datadog::Tracing::Contrib::Rack::TraceMiddleware
  # @return [TraceMiddleware] a new instance of TraceMiddleware
  #
  # source://datadog//lib/datadog/tracing/contrib/rack/middlewares.rb#30
  def initialize(app); end

  # source://datadog//lib/datadog/tracing/contrib/rack/middlewares.rb#34
  def call(env); end

  # source://datadog//lib/datadog/tracing/contrib/rack/middlewares.rb#108
  def set_request_tags!(trace, request_span, env, status, headers, response, original_env); end

  private

  # source://datadog//lib/datadog/tracing/contrib/rack/middlewares.rb#239
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/rack/middlewares.rb#245
  def parse_url(env, original_env); end

  # source://datadog//lib/datadog/tracing/contrib/rack/middlewares.rb#289
  def parse_user_agent_header(headers); end
end

# Module to create virtual proxy span
#
# source://datadog//lib/datadog/tracing/contrib/rack/trace_proxy_middleware.rb#13
module Datadog::Tracing::Contrib::Rack::TraceProxyMiddleware
  private

  # source://datadog//lib/datadog/tracing/contrib/rack/trace_proxy_middleware.rb#16
  def call(env, configuration); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/rack/trace_proxy_middleware.rb#16
    def call(env, configuration); end
  end
end

# Rails module includes middlewares that are required for Rails to be properly instrumented.
#
# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#6
module Datadog::Tracing::Contrib::Rails; end

# source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Rails::Configuration; end

# Custom settings for the Rails integration
#
# source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Rails::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # @return [Settings] a new instance of Settings
  #
  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#15
  def initialize(options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#35
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#35
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#44
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#44
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#54
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#54
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#28
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#28
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#61
  def middleware; end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#61
  def middleware=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#62
  def middleware_names; end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#62
  def middleware_names=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#56
  def request_queuing; end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#56
  def request_queuing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#63
  def template_base_path; end

  # source://datadog//lib/datadog/tracing/contrib/rails/configuration/settings.rb#63
  def template_base_path=(value); end
end

# This is only here to catch errors, the Rack module does something very similar, however,
# since it's not in the same place in the stack, when the Rack middleware is called,
# error is already swallowed and handled by Rails so we miss the call stack, for instance.
#
# source://datadog//lib/datadog/tracing/contrib/rails/middlewares.rb#13
class Datadog::Tracing::Contrib::Rails::ExceptionMiddleware
  # @return [ExceptionMiddleware] a new instance of ExceptionMiddleware
  #
  # source://datadog//lib/datadog/tracing/contrib/rails/middlewares.rb#14
  def initialize(app); end

  # source://datadog//lib/datadog/tracing/contrib/rails/middlewares.rb#18
  def call(env); end
end

# Rails integration constants
#
# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#9
module Datadog::Tracing::Contrib::Rails::Ext; end

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#10
Datadog::Tracing::Contrib::Rails::Ext::APP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#13
Datadog::Tracing::Contrib::Rails::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#14
Datadog::Tracing::Contrib::Rails::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# Note: Alias (previous name DISABLE_DATADOG_RAILS) defined in supported-configurations.json
#
# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#16
Datadog::Tracing::Contrib::Rails::Ext::ENV_DISABLE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#11
Datadog::Tracing::Contrib::Rails::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#28
Datadog::Tracing::Contrib::Rails::Ext::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#18
Datadog::Tracing::Contrib::Rails::Ext::SPAN_RUNNER_FILE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#19
Datadog::Tracing::Contrib::Rails::Ext::SPAN_RUNNER_INLINE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#20
Datadog::Tracing::Contrib::Rails::Ext::SPAN_RUNNER_STDIN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#21
Datadog::Tracing::Contrib::Rails::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#22
Datadog::Tracing::Contrib::Rails::Ext::TAG_OPERATION_FILE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#23
Datadog::Tracing::Contrib::Rails::Ext::TAG_OPERATION_INLINE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#24
Datadog::Tracing::Contrib::Rails::Ext::TAG_OPERATION_STDIN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rails/ext.rb#25
Datadog::Tracing::Contrib::Rails::Ext::TAG_RUNNER_SOURCE = T.let(T.unsafe(nil), String)

# Rails framework code, used to essentially:
# - handle configuration entries which are specific to Datadog tracing
# - instrument parts of the framework when needed
#
# source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#23
module Datadog::Tracing::Contrib::Rails::Framework
  class << self
    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#77
    def activate_action_cable!(datadog_config, rails_config); end

    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#83
    def activate_action_mailer!(datadog_config, rails_config); end

    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#92
    def activate_action_pack!(datadog_config, rails_config); end

    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#101
    def activate_action_view!(datadog_config, rails_config); end

    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#110
    def activate_active_job!(datadog_config, rails_config); end

    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#119
    def activate_active_record!(datadog_config, rails_config); end

    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#71
    def activate_active_support!(datadog_config, rails_config); end

    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#125
    def activate_lograge!(datadog_config, rails_config); end

    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#60
    def activate_rack!(datadog_config, rails_config); end

    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#135
    def activate_semantic_logger!(datadog_config, rails_config); end

    # After the Rails application finishes initializing, we configure the Rails
    # integration and all its sub-components with the application information
    # available.
    # We do this after the initialization because not all the information we
    # require is available before then.
    #
    # source://datadog//lib/datadog/tracing/contrib/rails/framework.rb#29
    def setup; end
  end
end

# Description of Rails integration
#
# source://datadog//lib/datadog/tracing/contrib/rails/integration.rb#14
class Datadog::Tracing::Contrib::Rails::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/rails/integration.rb#41
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/rails/integration.rb#45
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/rails/integration.rb#33
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/rails/integration.rb#29
    def loaded?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/rails/integration.rb#37
    def patchable?; end

    # source://datadog//lib/datadog/tracing/contrib/rails/integration.rb#25
    def version; end
  end
end

# The version of Rails lives in Ext because the `rails/patcher.rb` indirectly loads
# all Rails components, and those components need the Rails version. Declaring the version
# here would cause a circular dependency.
#
# source://datadog//lib/datadog/tracing/contrib/rails/integration.rb#20
Datadog::Tracing::Contrib::Rails::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Rails log injection helper methods
#
# source://datadog//lib/datadog/tracing/contrib/rails/log_injection.rb#9
module Datadog::Tracing::Contrib::Rails::LogInjection
  private

  # Use `app.config.log_tags` to inject propagation tags into the default Rails logger.
  #
  # source://datadog//lib/datadog/tracing/contrib/rails/log_injection.rb#13
  def configure_log_tags(app_config); end

  class << self
    # Use `app.config.log_tags` to inject propagation tags into the default Rails logger.
    #
    # source://datadog//lib/datadog/tracing/contrib/rails/log_injection.rb#13
    def configure_log_tags(app_config); end
  end
end

# Patcher enables patching of 'rails' module.
#
# source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#17
module Datadog::Tracing::Contrib::Rails::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#51
  def add_middleware(app); end

  # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#74
  def after_initialize(app); end

  # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#41
  def before_initialize(app); end

  # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#29
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#68
  def patch_after_initialize; end

  # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#35
  def patch_before_initialize; end

  # Instruments the `bin/rails runner` command.
  #
  # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#88
  def patch_rails_runner; end

  # Configure Rails tracing with settings
  #
  # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#83
  def setup_tracer; end

  # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#25
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#51
    def add_middleware(app); end

    # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#74
    def after_initialize(app); end

    # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#41
    def before_initialize(app); end

    # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#29
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#68
    def patch_after_initialize; end

    # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#35
    def patch_before_initialize; end

    # Instruments the `bin/rails runner` command.
    #
    # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#88
    def patch_rails_runner; end

    # Configure Rails tracing with settings
    #
    # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#83
    def setup_tracer; end

    # source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#25
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#21
Datadog::Tracing::Contrib::Rails::Patcher::AFTER_INITIALIZE_ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/tracing/contrib/rails/patcher.rb#20
Datadog::Tracing::Contrib::Rails::Patcher::BEFORE_INITIALIZE_ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# Instruments the `bin/rails runner` command.
# This command executes the provided code with the host Rails application loaded.
# The command can be either:
# * `-`: for code provided through the STDIN.
# * File path: for code provided through a local file.
# * `inline code`: for code provided directly as a command line argument.
#
# The difficulty in instrumenting the Rails Runner is that
# the Rails application (and as a consequence the Datadog tracing library)
# is loaded very late in the runner execution.
# The Rails application is loaded inside the same method the method
# that directly executes the code the user wants the runner to execute:
#
# ```ruby
# def perform(code_or_file = nil, *command_argv)
#   boot_application! # Loads the Rails and Datadog
#
#   if code_or_file == "-"
#     eval($stdin.read, TOPLEVEL_BINDING, "stdin") # Calls the user code for this Runner
#   # ...
# ```
#
# This means that there's no time to instrument the calling method, `perform`, which
# would be ideal. Instead, we resort to instrumenting `eval` and `load`, but
# only for calls from the `Rails::Command::RunnerCommand` class.
#
# @see https://guides.rubyonrails.org/v6.1/command_line.html#bin-rails-runner
#
# source://datadog//lib/datadog/tracing/contrib/rails/runner.rb#34
module Datadog::Tracing::Contrib::Rails::Runner
  # Instruments the `Kernel.eval` method, but only for the
  # `Rails::Command::RunnerCommand` class.
  #
  # source://datadog//lib/datadog/tracing/contrib/rails/runner.rb#41
  def eval(*args); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/rails/runner.rb#72
    def prepended(base); end
  end
end

# Instruments the `Kernel.load` method, but only for the
# `Rails::Command::RunnerCommand` class.
#
# source://datadog//lib/datadog/tracing/contrib/rails/runner.rb#78
module Datadog::Tracing::Contrib::Rails::Runner::InstrumentedKernel
  class << self
    # source://datadog//lib/datadog/tracing/contrib/rails/runner.rb#79
    def load(*args); end
  end
end

# Limit the maximum size of the source code captured in the source tag.
#
# source://datadog//lib/datadog/tracing/contrib/rails/runner.rb#36
Datadog::Tracing::Contrib::Rails::Runner::MAX_TAG_VALUE_SIZE = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#6
module Datadog::Tracing::Contrib::Rake; end

# source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Rake::Configuration; end

# Custom settings for the Rake integration
#
# source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Rake::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#23
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#23
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#29
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#29
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#35
  def quantize; end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#35
  def quantize=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#36
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#36
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#42
  def tasks; end

  # source://datadog//lib/datadog/tracing/contrib/rake/configuration/settings.rb#42
  def tasks=(value); end
end

# Rake integration constants
#
# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#9
module Datadog::Tracing::Contrib::Rake::Ext; end

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#12
Datadog::Tracing::Contrib::Rake::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#13
Datadog::Tracing::Contrib::Rake::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#10
Datadog::Tracing::Contrib::Rake::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#14
Datadog::Tracing::Contrib::Rake::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#16
Datadog::Tracing::Contrib::Rake::Ext::SPAN_EXECUTE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#15
Datadog::Tracing::Contrib::Rake::Ext::SPAN_INVOKE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#20
Datadog::Tracing::Contrib::Rake::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#17
Datadog::Tracing::Contrib::Rake::Ext::TAG_EXECUTE_ARGS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#18
Datadog::Tracing::Contrib::Rake::Ext::TAG_INVOKE_ARGS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#21
Datadog::Tracing::Contrib::Rake::Ext::TAG_OPERATION_EXECUTE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#22
Datadog::Tracing::Contrib::Rake::Ext::TAG_OPERATION_INVOKE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rake/ext.rb#19
Datadog::Tracing::Contrib::Rake::Ext::TAG_TASK_ARG_NAMES = T.let(T.unsafe(nil), String)

# Instrumentation for Rake tasks
#
# source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#13
module Datadog::Tracing::Contrib::Rake::Instrumentation
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#14
    def included(base); end
  end
end

# Instance methods for Rake instrumentation
#
# source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#19
module Datadog::Tracing::Contrib::Rake::Instrumentation::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#31
  def execute(args = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#20
  def invoke(*args); end

  private

  # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#72
  def annotate_execute!(span, args); end

  # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#54
  def annotate_invoke!(span, args); end

  # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#95
  def configuration; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#86
  def enabled?; end

  # Task names are verified dynamically, in order to be agnostic of
  # when tracing is configured in relation to Rake task declaration.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#46
  def instrumented_task?; end

  # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#81
  def quantize_args(args); end

  # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#50
  def shutdown_tracer!; end

  # source://datadog//lib/datadog/tracing/contrib/rake/instrumentation.rb#91
  def span_options; end
end

# Description of Rake integration
#
# source://datadog//lib/datadog/tracing/contrib/rake/integration.rb#12
class Datadog::Tracing::Contrib::Rake::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/rake/integration.rb#32
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/rake/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/rake/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/rake/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/rake/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/rake/integration.rb#15
Datadog::Tracing::Contrib::Rake::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'rake' module.
#
# source://datadog//lib/datadog/tracing/contrib/rake/patcher.rb#12
module Datadog::Tracing::Contrib::Rake::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/rake/patcher.rb#26
  def get_option(option); end

  # source://datadog//lib/datadog/tracing/contrib/rake/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/rake/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/rake/patcher.rb#26
    def get_option(option); end

    # source://datadog//lib/datadog/tracing/contrib/rake/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/rake/patcher.rb#17
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#6
module Datadog::Tracing::Contrib::Redis; end

# source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Redis::Configuration; end

# Converts String URLs and Hashes to a normalized connection settings Hash.
#
# source://datadog//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#13
class Datadog::Tracing::Contrib::Redis::Configuration::Resolver < ::Datadog::Tracing::Contrib::Configuration::Resolver
  # @param Redis [Hash, String] connection information
  #
  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#15
  def resolve(hash); end

  protected

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#41
  def connection_resolver; end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#27
  def normalize(hash); end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#21
  def parse_matcher(matcher); end
end

# Custom settings for the Redis integration
#
# source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Redis::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#33
  def command_args; end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#33
  def command_args=(value); end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#48
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#48
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#39
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/redis/configuration/settings.rb#39
  def service_name=(value); end
end

# source://datadog//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#10
Datadog::Tracing::Contrib::Redis::Configuration::UNIX_SCHEME = T.let(T.unsafe(nil), String)

# Redis integration constants
#
# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#9
module Datadog::Tracing::Contrib::Redis::Ext; end

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#18
Datadog::Tracing::Contrib::Redis::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#14
Datadog::Tracing::Contrib::Redis::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#15
Datadog::Tracing::Contrib::Redis::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#16
Datadog::Tracing::Contrib::Redis::Ext::ENV_COMMAND_ARGS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#10
Datadog::Tracing::Contrib::Redis::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#12
Datadog::Tracing::Contrib::Redis::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#11
Datadog::Tracing::Contrib::Redis::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#17
Datadog::Tracing::Contrib::Redis::Ext::METRIC_PIPELINE_LEN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#27
Datadog::Tracing::Contrib::Redis::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#19
Datadog::Tracing::Contrib::Redis::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#23
Datadog::Tracing::Contrib::Redis::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#26
Datadog::Tracing::Contrib::Redis::Ext::TAG_DATABASE_INDEX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#20
Datadog::Tracing::Contrib::Redis::Ext::TAG_DB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#24
Datadog::Tracing::Contrib::Redis::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#21
Datadog::Tracing::Contrib::Redis::Ext::TAG_RAW_COMMAND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#25
Datadog::Tracing::Contrib::Redis::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/redis/ext.rb#22
Datadog::Tracing::Contrib::Redis::Ext::TYPE = T.let(T.unsafe(nil), String)

# Description of Redis integration
#
# source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#12
class Datadog::Tracing::Contrib::Redis::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#65
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#69
  def patcher; end

  # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#73
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#53
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#41
    def loaded?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#61
    def redis_client_compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#49
    def redis_client_loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#37
    def redis_client_version; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#57
    def redis_compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#45
    def redis_loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#33
    def redis_version; end

    # Until Redis 4, all instrumentation happened in one gem: redis.
    # Since Redis 5, instrumentation happens in a separate gem: redis-client.
    # Because Redis 4 does not depend on redis-client, it's possible for both gems to be installed at the same time.
    # For example, if Sidekiq 7 and Redis 4 are installed: both redis and redis-client will be installed.
    # If redis-client and redis > 5 are installed, than they will be in sync, and only redis-client will be installed.
    #
    # source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#29
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#15
Datadog::Tracing::Contrib::Redis::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Support `Config#custom`
# https://github.com/redis-rb/redis-client/blob/master/CHANGELOG.md#0110
#
# source://datadog//lib/datadog/tracing/contrib/redis/integration.rb#19
Datadog::Tracing::Contrib::Redis::Integration::REDISCLIENT_MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'redis' module.
#
# source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#12
module Datadog::Tracing::Contrib::Redis::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#62
  def default_tags; end

  # source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#69
  def patch; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#62
    def default_tags; end

    # source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#69
    def patch; end
  end
end

# Patch for redis instance (with redis < 5)
#
# source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#16
module Datadog::Tracing::Contrib::Redis::Patcher::DatadogPinPatch
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#17
    def included(base); end
  end
end

# Instance method patch for redis instance
#
# source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#22
module Datadog::Tracing::Contrib::Redis::Patcher::DatadogPinPatch::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#23
  def datadog_pin=(pin); end

  # source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#27
  def datadog_target; end
end

# Patch for redis instance (with redis >= 5)
#
# source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#43
module Datadog::Tracing::Contrib::Redis::Patcher::NotSupportedNoticePatch
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#44
    def included(base); end
  end
end

# Instance method patch for redis instance
#
# source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#49
module Datadog::Tracing::Contrib::Redis::Patcher::NotSupportedNoticePatch::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/redis/patcher.rb#50
  def datadog_pin=(_pin); end
end

# source://datadog//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#12
module Datadog::Tracing::Contrib::Redis::Vendor; end

# source://datadog//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#13
class Datadog::Tracing::Contrib::Redis::Vendor::Resolver
  #
  # This method is a subset of the implementation provided in v3.0.0
  # https://github.com/redis/redis-rb/blob/v3.0.0/lib/redis/client.rb
  # https://github.com/redis/redis-rb/blob/v4.1.3/lib/redis/client.rb
  #
  # Since it has been backported from the original gem, some linting
  # cops have been disabled
  #
  # source://datadog//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#52
  def _parse_options(options); end

  # source://datadog//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#38
  def resolve(options); end
end

# Connection DEFAULTS for a Redis::Client are unchanged for
# the integration supported options.
# https://github.com/redis/redis-rb/blob/v3.0.0/lib/redis/client.rb#L6-L14
# https://github.com/redis/redis-rb/blob/v4.1.3/lib/redis/client.rb#L10-L26
# Since the integration takes in consideration only few attributes, all
# versions are compatible for :url, :scheme, :host, :port, :db
#
# source://datadog//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#20
Datadog::Tracing::Contrib::Redis::Vendor::Resolver::DEFAULTS = T.let(T.unsafe(nil), Hash)

# Defines registerable behavior for integrations
#
# source://datadog//lib/datadog/tracing/contrib/registerable.rb#7
module Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods

  mixes_in_class_methods ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/registerable.rb#8
    def included(base); end
  end
end

# Class methods for registerable behavior
#
# source://datadog//lib/datadog/tracing/contrib/registerable.rb#15
module Datadog::Tracing::Contrib::Registerable::ClassMethods
  # Registers this integration in the global tracer registry.
  # Once registered, this integration can be activated with:
  #
  # ```
  # Datadog.configure do |c|
  #   c.tracing.instrument :name
  # end
  # ```
  #
  # @param auto_patch [Boolean] will this integration be activated during
  #   {file:docs/AutoInstrumentation.md Auto Instrumentation}?
  # @param name [Symbol] integration name. Used during activation.
  # @param options [Hash] additional keyword options passed to the initializer of
  #   a custom {Registerable} instrumentation
  # @param registry [Datadog::Tracing::Contrib::Registry] a custom registry.
  #   Defaults to the global tracing registry.
  # @see Datadog::Tracing::Contrib::Integration
  #
  # source://datadog//lib/datadog/tracing/contrib/registerable.rb#33
  def register_as(name, registry: T.unsafe(nil), auto_patch: T.unsafe(nil), **options); end
end

# Instance methods for registerable behavior
#
# source://datadog//lib/datadog/tracing/contrib/registerable.rb#39
module Datadog::Tracing::Contrib::Registerable::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/registerable.rb#43
  def initialize(name, **options); end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/tracing/contrib/registerable.rb#40
  def name; end
end

# Registry is a collection of tracing integrations.
#
# source://datadog//lib/datadog/tracing/contrib/registry.rb#8
class Datadog::Tracing::Contrib::Registry
  include ::Enumerable

  # @return [Registry] a new instance of Registry
  #
  # source://datadog//lib/datadog/tracing/contrib/registry.rb#14
  def initialize; end

  # source://datadog//lib/datadog/tracing/contrib/registry.rb#35
  def [](name); end

  # @param auto_patch [Boolean] is the tracer allowed to automatically patch
  #   the host application with this instrumentation?
  # @param klass [Object] instrumentation implementation
  # @param name [Symbol] instrumentation name, to be used when activating this integration
  #
  # source://datadog//lib/datadog/tracing/contrib/registry.rb#23
  def add(name, klass, auto_patch = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/registry.rb#29
  def each(&block); end

  # source://datadog//lib/datadog/tracing/contrib/registry.rb#42
  def to_h; end
end

# source://datadog//lib/datadog/tracing/contrib/registry.rb#11
class Datadog::Tracing::Contrib::Registry::Entry < ::Struct
  # Returns the value of attribute auto_patch
  #
  # @return [Object] the current value of auto_patch
  #
  # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
  def auto_patch; end

  # Sets the attribute auto_patch
  #
  # @param value [Object] the value to set the attribute auto_patch to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
  def auto_patch=(_); end

  # Returns the value of attribute klass
  #
  # @return [Object] the current value of klass
  #
  # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
  def klass; end

  # Sets the attribute klass
  #
  # @param value [Object] the value to set the attribute klass to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
  def klass=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
  def name=(_); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
    def [](*_arg0); end

    # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
    def inspect; end

    # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
    def keyword_init?; end

    # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
    def members; end

    # source://datadog//lib/datadog/tracing/contrib/registry.rb#11
    def new(*_arg0); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/resque/ext.rb#6
module Datadog::Tracing::Contrib::Resque; end

# source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Resque::Configuration; end

# Custom settings for the Resque integration
#
# source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Resque::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#34
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#34
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/resque/configuration/settings.rb#33
  def service_name=(value); end
end

# Resque integration constants
#
# source://datadog//lib/datadog/tracing/contrib/resque/ext.rb#9
module Datadog::Tracing::Contrib::Resque::Ext; end

# source://datadog//lib/datadog/tracing/contrib/resque/ext.rb#12
Datadog::Tracing::Contrib::Resque::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/resque/ext.rb#13
Datadog::Tracing::Contrib::Resque::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/resque/ext.rb#10
Datadog::Tracing::Contrib::Resque::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/resque/ext.rb#14
Datadog::Tracing::Contrib::Resque::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/resque/ext.rb#15
Datadog::Tracing::Contrib::Resque::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/resque/ext.rb#16
Datadog::Tracing::Contrib::Resque::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/resque/ext.rb#17
Datadog::Tracing::Contrib::Resque::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Resque integration
#
# source://datadog//lib/datadog/tracing/contrib/resque/integration.rb#12
class Datadog::Tracing::Contrib::Resque::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/resque/integration.rb#32
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/resque/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/resque/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/resque/integration.rb#24
    def loaded?; end

    # Globally-acccesible reference for pre-forking optimization
    #
    # source://datadog//lib/datadog/tracing/contrib/resque/integration.rb#42
    def sync_writer; end

    # Globally-acccesible reference for pre-forking optimization
    #
    # source://datadog//lib/datadog/tracing/contrib/resque/integration.rb#42
    def sync_writer=(_arg0); end

    # source://datadog//lib/datadog/tracing/contrib/resque/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/resque/integration.rb#15
Datadog::Tracing::Contrib::Resque::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'resque' module.
#
# source://datadog//lib/datadog/tracing/contrib/resque/patcher.rb#11
module Datadog::Tracing::Contrib::Resque::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/resque/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/resque/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/resque/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/resque/patcher.rb#16
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#6
module Datadog::Tracing::Contrib::RestClient; end

# source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#10
module Datadog::Tracing::Contrib::RestClient::Configuration; end

# Custom settings for the RestClient integration
#
# source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#13
class Datadog::Tracing::Contrib::RestClient::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#33
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#33
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#44
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#44
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#35
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#35
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#49
  def split_by_domain; end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#49
  def split_by_domain=(value); end
end

# RestClient integration constants
#
# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#9
module Datadog::Tracing::Contrib::RestClient::Ext; end

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#16
Datadog::Tracing::Contrib::RestClient::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#14
Datadog::Tracing::Contrib::RestClient::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#15
Datadog::Tracing::Contrib::RestClient::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#10
Datadog::Tracing::Contrib::RestClient::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#12
Datadog::Tracing::Contrib::RestClient::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#11
Datadog::Tracing::Contrib::RestClient::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#20
Datadog::Tracing::Contrib::RestClient::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#17
Datadog::Tracing::Contrib::RestClient::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#18
Datadog::Tracing::Contrib::RestClient::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/rest_client/ext.rb#19
Datadog::Tracing::Contrib::RestClient::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of RestClient integration
#
# source://datadog//lib/datadog/tracing/contrib/rest_client/integration.rb#12
class Datadog::Tracing::Contrib::RestClient::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/rest_client/integration.rb#35
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/integration.rb#39
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/rest_client/integration.rb#31
    def compatible?; end

    # source://datadog//lib/datadog/tracing/contrib/rest_client/integration.rb#19
    def gem_name; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/rest_client/integration.rb#27
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/rest_client/integration.rb#23
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/rest_client/integration.rb#15
Datadog::Tracing::Contrib::RestClient::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'rest_client' module.
#
# source://datadog//lib/datadog/tracing/contrib/rest_client/patcher.rb#10
module Datadog::Tracing::Contrib::RestClient::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/rest_client/patcher.rb#19
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/rest_client/patcher.rb#15
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/rest_client/patcher.rb#19
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/rest_client/patcher.rb#15
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/roda/ext.rb#6
module Datadog::Tracing::Contrib::Roda; end

# source://datadog//lib/datadog/tracing/contrib/roda/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Roda::Configuration; end

# Custom settings for the Roda integration
#
# source://datadog//lib/datadog/tracing/contrib/roda/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Roda::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/roda/configuration/settings.rb#20
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/roda/configuration/settings.rb#20
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/roda/configuration/settings.rb#26
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/roda/configuration/settings.rb#26
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/roda/configuration/settings.rb#13
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/roda/configuration/settings.rb#13
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/roda/configuration/settings.rb#32
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/roda/configuration/settings.rb#32
  def service_name=(value); end
end

# Roda integration constants
#
# source://datadog//lib/datadog/tracing/contrib/roda/ext.rb#8
module Datadog::Tracing::Contrib::Roda::Ext; end

# source://datadog//lib/datadog/tracing/contrib/roda/ext.rb#9
Datadog::Tracing::Contrib::Roda::Ext::APP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/roda/ext.rb#12
Datadog::Tracing::Contrib::Roda::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/roda/ext.rb#13
Datadog::Tracing::Contrib::Roda::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/roda/ext.rb#10
Datadog::Tracing::Contrib::Roda::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/roda/ext.rb#14
Datadog::Tracing::Contrib::Roda::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Roda
#
# source://datadog//lib/datadog/tracing/contrib/roda/instrumentation.rb#12
module Datadog::Tracing::Contrib::Roda::Instrumentation
  # source://datadog//lib/datadog/tracing/contrib/roda/instrumentation.rb#13
  def _roda_handle_main_route; end

  # source://datadog//lib/datadog/tracing/contrib/roda/instrumentation.rb#17
  def call; end

  private

  # source://datadog//lib/datadog/tracing/contrib/roda/instrumentation.rb#69
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/roda/instrumentation.rb#23
  def instrument(span_name, &block); end
end

# Description of Roda integration
#
# source://datadog//lib/datadog/tracing/contrib/roda/integration.rb#14
class Datadog::Tracing::Contrib::Roda::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/roda/integration.rb#34
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/roda/integration.rb#38
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/roda/integration.rb#30
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/roda/integration.rb#26
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/roda/integration.rb#22
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/roda/integration.rb#18
Datadog::Tracing::Contrib::Roda::Integration::MAXIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://datadog//lib/datadog/tracing/contrib/roda/integration.rb#17
Datadog::Tracing::Contrib::Roda::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://datadog//lib/datadog/tracing/contrib/roda/patcher.rb#14
module Datadog::Tracing::Contrib::Roda::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods
end

# Datadog SemanticLogger integration.
#
# source://datadog//lib/datadog/tracing/contrib/semantic_logger/ext.rb#6
module Datadog::Tracing::Contrib::SemanticLogger; end

# source://datadog//lib/datadog/tracing/contrib/semantic_logger/configuration/settings.rb#10
module Datadog::Tracing::Contrib::SemanticLogger::Configuration; end

# Custom settings for the SemanticLogger integration
#
# source://datadog//lib/datadog/tracing/contrib/semantic_logger/configuration/settings.rb#13
class Datadog::Tracing::Contrib::SemanticLogger::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/semantic_logger/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/semantic_logger/configuration/settings.rb#14
  def enabled=(value); end
end

# SemanticLogger integration constants
#
# source://datadog//lib/datadog/tracing/contrib/semantic_logger/ext.rb#9
module Datadog::Tracing::Contrib::SemanticLogger::Ext; end

# source://datadog//lib/datadog/tracing/contrib/semantic_logger/ext.rb#10
Datadog::Tracing::Contrib::SemanticLogger::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Instrumentation for SemanticLogger
#
# source://datadog//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#8
module Datadog::Tracing::Contrib::SemanticLogger::Instrumentation
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#9
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://datadog//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#14
module Datadog::Tracing::Contrib::SemanticLogger::Instrumentation::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#15
  def log(log, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
end

# Description of SemanticLogger integration
#
# source://datadog//lib/datadog/tracing/contrib/semantic_logger/integration.rb#12
class Datadog::Tracing::Contrib::SemanticLogger::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # TODO: abstract out the log injection related instrumentation into it's own module so we dont
  # keep having to do these workarounds
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/semantic_logger/integration.rb#37
  def auto_instrument?; end

  # source://datadog//lib/datadog/tracing/contrib/semantic_logger/integration.rb#41
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/semantic_logger/integration.rb#45
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/semantic_logger/integration.rb#31
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/semantic_logger/integration.rb#27
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/semantic_logger/integration.rb#23
    def version; end
  end
end

# v4 had a migration to `named_tags` instead of `payload`
# and has been out for almost 5 years at this point
# it's probably reasonable to nudge users to using modern ruby libs
#
# source://datadog//lib/datadog/tracing/contrib/semantic_logger/integration.rb#18
Datadog::Tracing::Contrib::SemanticLogger::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'semantic_logger' module.
#
# source://datadog//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#12
module Datadog::Tracing::Contrib::SemanticLogger::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch
  #
  # source://datadog//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#22
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#17
  def target_version; end

  class << self
    # patch applies our patch
    #
    # source://datadog//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#22
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#17
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/sequel/ext.rb#6
module Datadog::Tracing::Contrib::Sequel; end

# source://datadog//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Sequel::Configuration; end

# Custom settings for the Sequel integration
#
# source://datadog//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Sequel::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#14
  def enabled=(value); end
end

# Adds instrumentation to Sequel::Database
#
# source://datadog//lib/datadog/tracing/contrib/sequel/database.rb#13
module Datadog::Tracing::Contrib::Sequel::Database
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/sequel/database.rb#14
    def included(base); end
  end
end

# Instance methods for instrumenting Sequel::Database
#
# source://datadog//lib/datadog/tracing/contrib/sequel/database.rb#19
module Datadog::Tracing::Contrib::Sequel::Database::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/sequel/database.rb#20
  def run(sql, options = T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/tracing/contrib/sequel/database.rb#43
  def adapter_name; end

  # source://datadog//lib/datadog/tracing/contrib/sequel/database.rb#47
  def parse_opts(sql, opts); end
end

# Adds instrumentation to Sequel::Dataset
#
# source://datadog//lib/datadog/tracing/contrib/sequel/dataset.rb#13
module Datadog::Tracing::Contrib::Sequel::Dataset
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/sequel/dataset.rb#14
    def included(base); end
  end
end

# Instance methods for instrumenting Sequel::Dataset
#
# source://datadog//lib/datadog/tracing/contrib/sequel/dataset.rb#19
module Datadog::Tracing::Contrib::Sequel::Dataset::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/sequel/dataset.rb#20
  def execute(sql, options = T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/tracing/contrib/sequel/dataset.rb#24
  def execute_ddl(sql, options = T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/tracing/contrib/sequel/dataset.rb#28
  def execute_dui(sql, options = T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/tracing/contrib/sequel/dataset.rb#32
  def execute_insert(sql, options = T.unsafe(nil), &block); end

  private

  # source://datadog//lib/datadog/tracing/contrib/sequel/dataset.rb#59
  def adapter_name; end

  # source://datadog//lib/datadog/tracing/contrib/sequel/dataset.rb#38
  def trace_execute(super_method, sql, options, &block); end
end

# Sequel integration constants
#
# source://datadog//lib/datadog/tracing/contrib/sequel/ext.rb#9
module Datadog::Tracing::Contrib::Sequel::Ext; end

# source://datadog//lib/datadog/tracing/contrib/sequel/ext.rb#12
Datadog::Tracing::Contrib::Sequel::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sequel/ext.rb#13
Datadog::Tracing::Contrib::Sequel::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sequel/ext.rb#10
Datadog::Tracing::Contrib::Sequel::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sequel/ext.rb#14
Datadog::Tracing::Contrib::Sequel::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sequel/ext.rb#17
Datadog::Tracing::Contrib::Sequel::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sequel/ext.rb#15
Datadog::Tracing::Contrib::Sequel::Ext::TAG_DB_VENDOR = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sequel/ext.rb#18
Datadog::Tracing::Contrib::Sequel::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sequel/ext.rb#16
Datadog::Tracing::Contrib::Sequel::Ext::TAG_PREPARED_NAME = T.let(T.unsafe(nil), String)

# Description of Sequel integration
#
# source://datadog//lib/datadog/tracing/contrib/sequel/integration.rb#12
class Datadog::Tracing::Contrib::Sequel::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/sequel/integration.rb#32
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/sequel/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sequel/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sequel/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/sequel/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/sequel/integration.rb#15
Datadog::Tracing::Contrib::Sequel::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sequel' module.
#
# source://datadog//lib/datadog/tracing/contrib/sequel/patcher.rb#12
module Datadog::Tracing::Contrib::Sequel::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/sequel/patcher.rb#21
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/sequel/patcher.rb#26
  def patch_sequel_database; end

  # source://datadog//lib/datadog/tracing/contrib/sequel/patcher.rb#30
  def patch_sequel_dataset; end

  # source://datadog//lib/datadog/tracing/contrib/sequel/patcher.rb#17
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/sequel/patcher.rb#21
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/sequel/patcher.rb#26
    def patch_sequel_database; end

    # source://datadog//lib/datadog/tracing/contrib/sequel/patcher.rb#30
    def patch_sequel_dataset; end

    # source://datadog//lib/datadog/tracing/contrib/sequel/patcher.rb#17
    def target_version; end
  end
end

# General purpose functions for Sequel
#
# source://datadog//lib/datadog/tracing/contrib/sequel/utils.rb#11
module Datadog::Tracing::Contrib::Sequel::Utils
  class << self
    # Ruby database connector library
    #
    # e.g. adapter:mysql2 (database:mysql), adapter:jdbc (database:postgres)
    #
    # source://datadog//lib/datadog/tracing/contrib/sequel/utils.rb#16
    def adapter_name(database); end

    # Database engine
    #
    # e.g. database:mysql (adapter:mysql2), database:postgres (adapter:jdbc)
    #
    # source://datadog//lib/datadog/tracing/contrib/sequel/utils.rb#31
    def database_type(database); end

    # source://datadog//lib/datadog/tracing/contrib/sequel/utils.rb#35
    def parse_opts(sql, opts, db_opts, dataset = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/sequel/utils.rb#53
    def set_common_tags(span, db); end

    private

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sequel/utils.rb#78
    def analytics_enabled?; end

    # source://datadog//lib/datadog/tracing/contrib/sequel/utils.rb#82
    def analytics_sample_rate; end

    # source://datadog//lib/datadog/tracing/contrib/sequel/utils.rb#74
    def datadog_configuration; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#6
module Datadog::Tracing::Contrib::Shoryuken; end

# source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Shoryuken::Configuration; end

# Default settings for the Shoryuken integration
#
# source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Shoryuken::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#34
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#34
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#33
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#37
  def tag_body; end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#37
  def tag_body=(value); end
end

# Shoryuken integration constants
#
# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#9
module Datadog::Tracing::Contrib::Shoryuken::Ext; end

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#12
Datadog::Tracing::Contrib::Shoryuken::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#13
Datadog::Tracing::Contrib::Shoryuken::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#10
Datadog::Tracing::Contrib::Shoryuken::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#14
Datadog::Tracing::Contrib::Shoryuken::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#15
Datadog::Tracing::Contrib::Shoryuken::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#20
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#18
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_ATTRIBUTES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#19
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_BODY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#16
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#17
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#22
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_MESSAGING_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/shoryuken/ext.rb#21
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Shoryuken integration
#
# source://datadog//lib/datadog/tracing/contrib/shoryuken/integration.rb#13
class Datadog::Tracing::Contrib::Shoryuken::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/shoryuken/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/shoryuken/integration.rb#25
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/shoryuken/integration.rb#21
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/shoryuken/integration.rb#16
Datadog::Tracing::Contrib::Shoryuken::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'shoryuken' module.
#
# source://datadog//lib/datadog/tracing/contrib/shoryuken/patcher.rb#10
module Datadog::Tracing::Contrib::Shoryuken::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/patcher.rb#19
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/patcher.rb#15
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/shoryuken/patcher.rb#19
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/shoryuken/patcher.rb#15
    def target_version; end
  end
end

# Tracer is a Shoryuken server-side middleware which traces executed jobs
#
# source://datadog//lib/datadog/tracing/contrib/shoryuken/tracer.rb#10
class Datadog::Tracing::Contrib::Shoryuken::Tracer
  # @return [Tracer] a new instance of Tracer
  #
  # source://datadog//lib/datadog/tracing/contrib/shoryuken/tracer.rb#11
  def initialize(options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/tracer.rb#16
  def call(worker_instance, queue, sqs_msg, body); end

  private

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/tracer.rb#58
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/shoryuken/tracer.rb#50
  def resource(worker_instance, body); end
end

# `Sidekiq` integration public API
#
# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#6
module Datadog::Tracing::Contrib::Sidekiq
  class << self
    # source://datadog//lib/datadog/tracing/contrib/sidekiq.rb#18
    def extract(data); end

    # source://datadog//lib/datadog/tracing/contrib/sidekiq.rb#12
    def inject(digest, data); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Sidekiq::Configuration; end

# Custom settings for the Sidekiq integration
#
# source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Sidekiq::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#34
  def client_service_name; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#34
  def client_service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#41
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#41
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#36
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#36
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#40
  def quantize; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#40
  def quantize=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#33
  def service_name=(value); end
end

# source://datadog//lib/datadog/tracing/contrib/sidekiq/distributed/propagation.rb#17
module Datadog::Tracing::Contrib::Sidekiq::Distributed; end

# Extracts and injects propagation through HTTP headers.
#
# source://datadog//lib/datadog/tracing/contrib/sidekiq/distributed/propagation.rb#19
class Datadog::Tracing::Contrib::Sidekiq::Distributed::Propagation < ::Datadog::Tracing::Distributed::Propagation
  # @return [Propagation] a new instance of Propagation
  #
  # source://datadog//lib/datadog/tracing/contrib/sidekiq/distributed/propagation.rb#20
  def initialize(propagation_style_inject:, propagation_style_extract:, propagation_extract_first:); end
end

# Sidekiq integration constants
#
# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#9
module Datadog::Tracing::Contrib::Sidekiq::Ext; end

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#10
Datadog::Tracing::Contrib::Sidekiq::Ext::CLIENT_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#13
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#14
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#11
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#15
Datadog::Tracing::Contrib::Sidekiq::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# Sidekiq 8 uses integer epoch milliseconds, rather than epoch floats
#
# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#16
Datadog::Tracing::Contrib::Sidekiq::Ext::SIDEKIQ_8_SECONDS_PER_INTEGER = T.let(T.unsafe(nil), Float)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#21
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#18
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#19
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_JOB_FETCH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#17
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_PUSH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#20
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_REDIS_INFO = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#22
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_SCHEDULED_PUSH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#23
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_SCHEDULED_WAIT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#24
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_STOP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#32
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#31
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_ARGS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#25
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_DELAY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#26
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#27
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#28
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_RETRY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#29
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_RETRY_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#30
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_WRAPPER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#37
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#34
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#35
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_JOB_FETCH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#33
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_PUSH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#36
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_REDIS_INFO = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#38
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_SCHEDULED_PUSH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#39
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_SCHEDULED_WAIT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/ext.rb#40
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_STOP = T.let(T.unsafe(nil), String)

# Description of Sidekiq integration
#
# source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#12
class Datadog::Tracing::Contrib::Sidekiq::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#50
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#54
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#30
    def compatible?; end

    # Only patch server internals on v5.2.4+ because that's when loading of
    # `Sidekiq::Launcher` stabilized. Sidekiq 4+ technically can support our
    # patches (with minor adjustments), but in order to avoid explicitly
    # requiring `sidekiq/launcher` ourselves (which could affect gem
    # initialization order), we are limiting this tracing to v5.2.4+.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#39
    def compatible_with_server_internal_tracing?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#26
    def loaded?; end

    # Capsules are a new way of configuring Sidekiq that was introduced in version 7
    # that change the way some of the configuration data is exposed. Certain patches
    # are applied differently for versions of Sidekiq that support capsules.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#46
    def supports_capsules?; end

    # source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#22
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#17
Datadog::Tracing::Contrib::Sidekiq::Integration::MINIMUM_CAPSULE_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#16
Datadog::Tracing::Contrib::Sidekiq::Integration::MINIMUM_SERVER_INTERNAL_TRACING_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://datadog//lib/datadog/tracing/contrib/sidekiq/integration.rb#15
Datadog::Tracing::Contrib::Sidekiq::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sidekiq' module.
#
# source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#10
module Datadog::Tracing::Contrib::Sidekiq::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#19
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#77
  def patch_redis_info; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#51
  def patch_server_heartbeat; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#44
  def patch_server_internals; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#65
  def patch_server_job_fetch; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#71
  def patch_server_scheduled_push; end

  # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#15
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#19
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#77
    def patch_redis_info; end

    # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#51
    def patch_server_heartbeat; end

    # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#44
    def patch_server_internals; end

    # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#65
    def patch_server_job_fetch; end

    # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#71
    def patch_server_scheduled_push; end

    # source://datadog//lib/datadog/tracing/contrib/sidekiq/patcher.rb#15
    def target_version; end
  end
end

# Instrument Sinatra.
#
# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#6
module Datadog::Tracing::Contrib::Sinatra; end

# source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Sinatra::Configuration; end

# Custom settings for the Sinatra integration
#
# source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Sinatra::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#25
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#25
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#30
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#30
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#36
  def distributed_tracing; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#36
  def distributed_tracing=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#18
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#18
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#37
  def headers; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#37
  def headers=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#38
  def resource_script_names; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#38
  def resource_script_names=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#40
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#40
  def service_name=(value); end
end

# source://datadog//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#14
Datadog::Tracing::Contrib::Sinatra::Configuration::Settings::DEFAULT_HEADERS = T.let(T.unsafe(nil), Hash)

# Hook into builder before the middleware list gets frozen
#
# source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#26
module Datadog::Tracing::Contrib::Sinatra::DefaultMiddlewarePatch
  # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#29
  def setup_middleware(*args, &block); end
end

# source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#27
Datadog::Tracing::Contrib::Sinatra::DefaultMiddlewarePatch::ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# Sinatra integration constants
#
# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#9
module Datadog::Tracing::Contrib::Sinatra::Ext; end

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#12
Datadog::Tracing::Contrib::Sinatra::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#13
Datadog::Tracing::Contrib::Sinatra::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#10
Datadog::Tracing::Contrib::Sinatra::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#14
Datadog::Tracing::Contrib::Sinatra::Ext::RACK_ENV_SINATRA_REQUEST_SPAN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#15
Datadog::Tracing::Contrib::Sinatra::Ext::SPAN_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#16
Datadog::Tracing::Contrib::Sinatra::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#17
Datadog::Tracing::Contrib::Sinatra::Ext::SPAN_ROUTE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#18
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_APP_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#19
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#20
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_OPERATION_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#21
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#22
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_OPERATION_ROUTE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#23
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_ROUTE_PATH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#24
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#25
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_TEMPLATE_ENGINE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sinatra/ext.rb#26
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_TEMPLATE_NAME = T.let(T.unsafe(nil), String)

# Sinatra framework code, used to essentially:
# - handle configuration entries which are specific to Datadog tracing
# - instrument parts of the framework when needed
#
# source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#11
module Datadog::Tracing::Contrib::Sinatra::Framework
  class << self
    # Apply relevant configuration from Sinatra to Rack
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#25
    def activate_rack!(datadog_config, sinatra_config); end

    # Add Rack middleware at the top of the stack
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#34
    def add_middleware(middleware, builder, *args, &block); end

    # Add Rack middleware after another in the the stack
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#63
    def add_middleware_after(after, middleware, builder, *args, &block); end

    # Add Rack middleware before another in the stack
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#52
    def add_middleware_before(before, middleware, builder, *args, &block); end

    # Add Rack middleware at the top of the stack
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#45
    def append_middleware(middleware, builder, *args, &block); end

    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#20
    def config_with_defaults(datadog_config); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#96
    def include_middleware?(middleware, builder); end

    # Insert a middleware class in the builder as it expects it internally.
    # The block gets passed prepared arguments for the caller to decide
    # how to insert.
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#83
    def insert_middleware(builder, middleware, args, block); end

    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#109
    def inspect_middlewares(builder); end

    # Introspect middlewares from a builder
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#101
    def middlewares(builder); end

    # Configure Rack from Sinatra, but only if Rack has not been configured manually beforehand
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#13
    def setup; end

    # Add Rack middleware at the top of the stack
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#41
    def unshift_middleare(middleware, builder, *args, &block); end

    # Wrap the middleware class instantiation in a proc, like Sinatra does internally
    # The `middleware` local variable name in the proc is important for introspection
    # (see Framework#middlewares)
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/framework.rb#76
    def wrap_middleware(middleware, *args, &block); end
  end
end

# Description of Sinatra integration
#
# source://datadog//lib/datadog/tracing/contrib/sinatra/integration.rb#12
class Datadog::Tracing::Contrib::Sinatra::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/sinatra/integration.rb#32
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sinatra/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/sinatra/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/sinatra/integration.rb#15
Datadog::Tracing::Contrib::Sinatra::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sinatra' module.
#
# source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#42
module Datadog::Tracing::Contrib::Sinatra::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#51
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#68
  def patch_default_middlewares; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#59
  def register_tracer; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#64
  def setup_tracer; end

  # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#47
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#51
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#68
    def patch_default_middlewares; end

    # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#59
    def register_tracer; end

    # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#64
    def setup_tracer; end

    # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#47
    def target_version; end
  end
end

# Set tracer configuration at a late enough time
#
# source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#13
module Datadog::Tracing::Contrib::Sinatra::TracerSetupPatch
  # source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#16
  def setup_middleware(*args, &block); end
end

# source://datadog//lib/datadog/tracing/contrib/sinatra/patcher.rb#14
Datadog::Tracing::Contrib::Sinatra::TracerSetupPatch::ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#6
module Datadog::Tracing::Contrib::Sneakers; end

# source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#9
module Datadog::Tracing::Contrib::Sneakers::Configuration; end

# Default settings for the Shoryuken integration
#
# source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#11
class Datadog::Tracing::Contrib::Sneakers::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#19
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#19
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#25
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#25
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#12
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#12
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#33
  def on_error; end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#33
  def on_error=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#31
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#31
  def service_name=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#37
  def tag_body; end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#37
  def tag_body=(value); end
end

# Sneakers integration constants
#
# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#9
module Datadog::Tracing::Contrib::Sneakers::Ext; end

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#12
Datadog::Tracing::Contrib::Sneakers::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#13
Datadog::Tracing::Contrib::Sneakers::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#10
Datadog::Tracing::Contrib::Sneakers::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#14
Datadog::Tracing::Contrib::Sneakers::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#15
Datadog::Tracing::Contrib::Sneakers::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#19
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#18
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_JOB_BODY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#17
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#16
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_JOB_ROUTING_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#21
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_MESSAGING_SYSTEM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#20
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sneakers/ext.rb#22
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_RABBITMQ_ROUTING_KEY = T.let(T.unsafe(nil), String)

# Description of Sneakers integration
#
# source://datadog//lib/datadog/tracing/contrib/sneakers/integration.rb#13
class Datadog::Tracing::Contrib::Sneakers::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/sneakers/integration.rb#33
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sneakers/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sneakers/integration.rb#25
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/sneakers/integration.rb#21
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/sneakers/integration.rb#16
Datadog::Tracing::Contrib::Sneakers::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sneakers' module.
#
# source://datadog//lib/datadog/tracing/contrib/sneakers/patcher.rb#11
module Datadog::Tracing::Contrib::Sneakers::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/sneakers/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/sneakers/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/sneakers/patcher.rb#16
    def target_version; end
  end
end

# Tracer is a Sneakers server-side middleware which traces executed jobs
#
# source://datadog//lib/datadog/tracing/contrib/sneakers/tracer.rb#11
class Datadog::Tracing::Contrib::Sneakers::Tracer
  # @return [Tracer] a new instance of Tracer
  #
  # source://datadog//lib/datadog/tracing/contrib/sneakers/tracer.rb#12
  def initialize(app, *args); end

  # source://datadog//lib/datadog/tracing/contrib/sneakers/tracer.rb#17
  def call(deserialized_msg, delivery_info, metadata, handler); end

  private

  # source://datadog//lib/datadog/tracing/contrib/sneakers/tracer.rb#53
  def configuration; end
end

# Contains methods for fetching values according to span attributes schema
#
# source://datadog//lib/datadog/tracing/contrib/span_attribute_schema.rb#9
module Datadog::Tracing::Contrib::SpanAttributeSchema
  class << self
    # source://datadog//lib/datadog/tracing/contrib/span_attribute_schema.rb#13
    def fetch_service_name(env, default); end

    # source://datadog//lib/datadog/tracing/contrib/span_attribute_schema.rb#23
    def set_peer_service!(span, sources); end

    private

    # filter_peer_service_sources: returns filtered sources based on existence of peer.service tag
    # If peer.service exists, we do not read from any other source rather use peer.service as source
    # This is to prevent overwriting of pre-existing peer.service tags
    #
    # source://datadog//lib/datadog/tracing/contrib/span_attribute_schema.rb#73
    def filter_peer_service_sources(span, sources); end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/span_attribute_schema.rb#89
    def not_empty_tag?(tag); end

    # set_peer_service_from_source: Implements the extraction logic to determine the peer.service value
    # based on the list of source tags passed as a parameter.
    #
    # If no values are found, it checks the default list for all spans before returning false for no result
    # Sets the source of where the information for peer.service was extracted from
    # Returns a peer.service value if successfully set or not
    #
    # source://datadog//lib/datadog/tracing/contrib/span_attribute_schema.rb#54
    def set_peer_service_from_source(span, sources = T.unsafe(nil)); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/span_attribute_schema.rb#11
Datadog::Tracing::Contrib::SpanAttributeSchema::NO_SOURCE = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/span_attribute_schema.rb#10
Datadog::Tracing::Contrib::SpanAttributeSchema::REFLEXIVE_SOURCES = T.let(T.unsafe(nil), Array)

# Parsing status range from environment variable
#
# source://datadog//lib/datadog/tracing/contrib/status_range_env_parser.rb#7
class Datadog::Tracing::Contrib::StatusRangeEnvParser
  class << self
    # source://datadog//lib/datadog/tracing/contrib/status_range_env_parser.rb#9
    def call(value); end
  end
end

# Useful checking whether the defined range covers status code
#
# source://datadog//lib/datadog/tracing/contrib/status_range_matcher.rb#7
class Datadog::Tracing::Contrib::StatusRangeMatcher
  # @return [StatusRangeMatcher] a new instance of StatusRangeMatcher
  #
  # source://datadog//lib/datadog/tracing/contrib/status_range_matcher.rb#8
  def initialize(ranges); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/status_range_matcher.rb#12
  def include?(status); end
end

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#6
module Datadog::Tracing::Contrib::Stripe; end

# source://datadog//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Stripe::Configuration; end

# Custom settings for the Stripe integration
#
# source://datadog//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Stripe::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#14
  def enabled=(value); end
end

# Stripe integration constants
#
# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#9
module Datadog::Tracing::Contrib::Stripe::Ext; end

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#12
Datadog::Tracing::Contrib::Stripe::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#13
Datadog::Tracing::Contrib::Stripe::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#10
Datadog::Tracing::Contrib::Stripe::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#14
Datadog::Tracing::Contrib::Stripe::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#15
Datadog::Tracing::Contrib::Stripe::Ext::SPAN_TYPE_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#16
Datadog::Tracing::Contrib::Stripe::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#17
Datadog::Tracing::Contrib::Stripe::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#18
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_HTTP_STATUS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#19
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#20
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#21
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_NUM_RETRIES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/stripe/ext.rb#22
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_PATH = T.let(T.unsafe(nil), String)

# Description of Stripe integration
#
# source://datadog//lib/datadog/tracing/contrib/stripe/integration.rb#12
class Datadog::Tracing::Contrib::Stripe::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/stripe/integration.rb#32
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/stripe/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/stripe/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/stripe/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/stripe/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/stripe/integration.rb#15
Datadog::Tracing::Contrib::Stripe::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Provides instrumentation for `stripe` through the Stripe instrumentation framework
#
# source://datadog//lib/datadog/tracing/contrib/stripe/patcher.rb#11
module Datadog::Tracing::Contrib::Stripe::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/stripe/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/stripe/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/stripe/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/stripe/patcher.rb#16
    def target_version; end
  end
end

# Defines instrumentation for Stripe requests
#
# source://datadog//lib/datadog/tracing/contrib/stripe/request.rb#12
module Datadog::Tracing::Contrib::Stripe::Request
  private

  # source://datadog//lib/datadog/tracing/contrib/stripe/request.rb#61
  def configuration; end

  # source://datadog//lib/datadog/tracing/contrib/stripe/request.rb#22
  def finish_span(event); end

  # source://datadog//lib/datadog/tracing/contrib/stripe/request.rb#15
  def start_span(event); end

  # source://datadog//lib/datadog/tracing/contrib/stripe/request.rb#35
  def tag_span(span, event); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/stripe/request.rb#61
    def configuration; end

    # source://datadog//lib/datadog/tracing/contrib/stripe/request.rb#22
    def finish_span(event); end

    # source://datadog//lib/datadog/tracing/contrib/stripe/request.rb#15
    def start_span(event); end

    # source://datadog//lib/datadog/tracing/contrib/stripe/request.rb#35
    def tag_span(span, event); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#6
module Datadog::Tracing::Contrib::SuckerPunch; end

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#10
module Datadog::Tracing::Contrib::SuckerPunch::Configuration; end

# Custom settings for the SuckerPunch integration
#
# source://datadog//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#13
class Datadog::Tracing::Contrib::SuckerPunch::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#21
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#21
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#27
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#27
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#14
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#14
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#33
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#33
  def service_name=(value); end
end

# SuckerPunch integration constants
#
# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#9
module Datadog::Tracing::Contrib::SuckerPunch::Ext; end

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#12
Datadog::Tracing::Contrib::SuckerPunch::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#13
Datadog::Tracing::Contrib::SuckerPunch::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#10
Datadog::Tracing::Contrib::SuckerPunch::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#14
Datadog::Tracing::Contrib::SuckerPunch::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#15
Datadog::Tracing::Contrib::SuckerPunch::Ext::SPAN_PERFORM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#16
Datadog::Tracing::Contrib::SuckerPunch::Ext::SPAN_PERFORM_ASYNC = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#17
Datadog::Tracing::Contrib::SuckerPunch::Ext::SPAN_PERFORM_IN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#20
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#21
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_OPERATION_PERFORM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#22
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_OPERATION_PERFORM_ASYNC = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#23
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_OPERATION_PERFORM_IN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#18
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_PERFORM_IN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/ext.rb#19
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_QUEUE = T.let(T.unsafe(nil), String)

# Description of SuckerPunch integration
#
# source://datadog//lib/datadog/tracing/contrib/sucker_punch/integration.rb#12
class Datadog::Tracing::Contrib::SuckerPunch::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/integration.rb#32
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sucker_punch/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/sucker_punch/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/sucker_punch/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/sucker_punch/integration.rb#15
Datadog::Tracing::Contrib::SuckerPunch::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sucker_punch' module.
#
# source://datadog//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#11
module Datadog::Tracing::Contrib::SuckerPunch::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#28
  def get_option(option); end

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#28
    def get_option(option); end

    # source://datadog//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#16
    def target_version; end
  end
end

# Miscellaneous support methods to aid in the creation of integrations.
#
# source://datadog//lib/datadog/tracing/contrib/support.rb#7
module Datadog::Tracing::Contrib::Support
  private

  # Checks if a constant is loaded in a module, handling autoloaded constants correctly.
  #
  # This method is particularly useful when you need to check if a constant is fully loaded,
  # not just defined. It handles the special case of autoloaded constants, which return
  # non-nil for `defined?` even when they haven't been loaded yet.
  #
  # @param base_module [Module] the module to check for the constant
  # @param constant [Symbol] the name of the constant to check
  # @return [Boolean] true if the constant has been loaded, false otherwise
  #
  # source://datadog//lib/datadog/tracing/contrib/support.rb#19
  def fully_loaded?(base_module, constant); end

  class << self
    # Checks if a constant is loaded in a module, handling autoloaded constants correctly.
    #
    # This method is particularly useful when you need to check if a constant is fully loaded,
    # not just defined. It handles the special case of autoloaded constants, which return
    # non-nil for `defined?` even when they haven't been loaded yet.
    #
    # @param base_module [Module] the module to check for the constant
    # @param constant [Symbol] the name of the constant to check
    # @return [Boolean] true if the constant has been loaded, false otherwise
    #
    # source://datadog//lib/datadog/tracing/contrib/support.rb#19
    def fully_loaded?(base_module, constant); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#6
module Datadog::Tracing::Contrib::Trilogy; end

# source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Trilogy::Configuration; end

# Custom settings for the Trilogy integration
#
# source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Trilogy::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#22
  def analytics_enabled; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#22
  def analytics_enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#28
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#28
  def analytics_sample_rate=(value); end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#49
  def append_comment; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#49
  def append_comment=(value); end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#43
  def comment_propagation; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#43
  def comment_propagation=(value); end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#16
  def enabled; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#16
  def enabled=(value); end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#54
  def peer_service; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#54
  def peer_service=(value); end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#34
  def service_name; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/configuration/settings.rb#34
  def service_name=(value); end
end

# Trilogy integration constants
#
# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#9
module Datadog::Tracing::Contrib::Trilogy::Ext; end

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#16
Datadog::Tracing::Contrib::Trilogy::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#14
Datadog::Tracing::Contrib::Trilogy::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#15
Datadog::Tracing::Contrib::Trilogy::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#10
Datadog::Tracing::Contrib::Trilogy::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#12
Datadog::Tracing::Contrib::Trilogy::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#11
Datadog::Tracing::Contrib::Trilogy::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#22
Datadog::Tracing::Contrib::Trilogy::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#17
Datadog::Tracing::Contrib::Trilogy::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#19
Datadog::Tracing::Contrib::Trilogy::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#18
Datadog::Tracing::Contrib::Trilogy::Ext::TAG_DB_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#20
Datadog::Tracing::Contrib::Trilogy::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/trilogy/ext.rb#21
Datadog::Tracing::Contrib::Trilogy::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Trilogy patch module
#
# source://datadog//lib/datadog/tracing/contrib/trilogy/instrumentation.rb#15
module Datadog::Tracing::Contrib::Trilogy::Instrumentation
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/contrib/trilogy/instrumentation.rb#16
    def included(base); end
  end
end

# Trilogy patch instance methods
#
# source://datadog//lib/datadog/tracing/contrib/trilogy/instrumentation.rb#21
module Datadog::Tracing::Contrib::Trilogy::Instrumentation::InstanceMethods
  # source://datadog//lib/datadog/tracing/contrib/trilogy/instrumentation.rb#22
  def query(sql); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/contrib/trilogy/instrumentation.rb#81
  def analytics_enabled?; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/instrumentation.rb#85
  def analytics_sample_rate; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/instrumentation.rb#89
  def comment_propagation; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/instrumentation.rb#77
  def datadog_configuration; end
end

# Description of Trilogy integration
#
# source://datadog//lib/datadog/tracing/contrib/trilogy/integration.rb#12
class Datadog::Tracing::Contrib::Trilogy::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://datadog//lib/datadog/tracing/contrib/trilogy/integration.rb#32
  def new_configuration; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/trilogy/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/contrib/trilogy/integration.rb#24
    def loaded?; end

    # source://datadog//lib/datadog/tracing/contrib/trilogy/integration.rb#20
    def version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/trilogy/integration.rb#15
Datadog::Tracing::Contrib::Trilogy::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'trilogy' module.
#
# source://datadog//lib/datadog/tracing/contrib/trilogy/patcher.rb#11
module Datadog::Tracing::Contrib::Trilogy::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://datadog//lib/datadog/tracing/contrib/trilogy/patcher.rb#20
  def patch; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/patcher.rb#24
  def patch_trilogy_client; end

  # source://datadog//lib/datadog/tracing/contrib/trilogy/patcher.rb#16
  def target_version; end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/trilogy/patcher.rb#20
    def patch; end

    # source://datadog//lib/datadog/tracing/contrib/trilogy/patcher.rb#24
    def patch_trilogy_client; end

    # source://datadog//lib/datadog/tracing/contrib/trilogy/patcher.rb#16
    def target_version; end
  end
end

# source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#9
module Datadog::Tracing::Contrib::Utils; end

# Common database-related utility functions.
#
# source://datadog//lib/datadog/tracing/contrib/utils/database.rb#8
module Datadog::Tracing::Contrib::Utils::Database
  private

  # source://datadog//lib/datadog/tracing/contrib/utils/database.rb#15
  def normalize_vendor(vendor); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/utils/database.rb#15
    def normalize_vendor(vendor); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/utils/database.rb#9
Datadog::Tracing::Contrib::Utils::Database::VENDOR_DEFAULT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/utils/database.rb#10
Datadog::Tracing::Contrib::Utils::Database::VENDOR_POSTGRES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/utils/database.rb#11
Datadog::Tracing::Contrib::Utils::Database::VENDOR_SQLITE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#10
module Datadog::Tracing::Contrib::Utils::Quantization; end

# Quantization for HTTP resources
#
# source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#12
module Datadog::Tracing::Contrib::Utils::Quantization::HTTP
  private

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#31
  def base_url(url, options = T.unsafe(nil)); end

  # Iterate over each key value pair, yielding to the block given.
  # Accepts :uniq option, which keeps uniq copies of keys without values.
  # e.g. Reduces "foo&bar=bar&bar=bar&foo" to "foo&bar=bar&bar=bar"
  #
  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#93
  def collect_query(query, options = T.unsafe(nil)); end

  # Scans over the query string and obfuscates sensitive data by
  # replacing matches with an opaque value
  #
  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#121
  def obfuscate_query(query, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#60
  def query(query, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#66
  def query!(query, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#23
  def url(url, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#39
  def url!(url, options = T.unsafe(nil)); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#31
    def base_url(url, options = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#60
    def query(query, options = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#66
    def query!(query, options = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#23
    def url(url, options = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#39
    def url!(url, options = T.unsafe(nil)); end

    private

    # Iterate over each key value pair, yielding to the block given.
    # Accepts :uniq option, which keeps uniq copies of keys without values.
    # e.g. Reduces "foo&bar=bar&bar=bar&foo" to "foo&bar=bar&bar=bar"
    #
    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#93
    def collect_query(query, options = T.unsafe(nil)); end

    # Scans over the query string and obfuscates sensitive data by
    # replacing matches with an opaque value
    #
    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#121
    def obfuscate_query(query, options = T.unsafe(nil)); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#134
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::OBFUSCATOR_REGEX = T.let(T.unsafe(nil), Regexp)

# source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#131
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::OBFUSCATOR_WITH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#13
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::PLACEHOLDER = T.let(T.unsafe(nil), String)

# taken from Ruby https://github.com/ruby/uri/blob/eaf89cc31619d49e67c64d0b58ea9dc38892d175/lib/uri/rfc3986_parser.rb
# but adjusted to parse only <scheme>://<host>:<port>/ components
# and stop there, since we don't care about the path, query string,
# and fragment components
#
# source://datadog//lib/datadog/tracing/contrib/utils/quantization/http.rb#19
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::RFC3986_URL_BASE = T.let(T.unsafe(nil), Regexp)

# Quantization for Hash
#
# source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#9
module Datadog::Tracing::Contrib::Utils::Quantization::Hash
  private

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#103
  def convert_value(value); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#21
  def format(hash_obj, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#28
  def format!(hash_obj, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#66
  def format_array(value, options); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#34
  def format_hash(hash_obj, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#52
  def format_value(value, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#98
  def indifferent_equals(value); end

  # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#76
  def merge_options(original, additional); end

  class << self
    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#103
    def convert_value(value); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#21
    def format(hash_obj, options = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#28
    def format!(hash_obj, options = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#66
    def format_array(value, options); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#34
    def format_hash(hash_obj, options = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#52
    def format_value(value, options = T.unsafe(nil)); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#98
    def indifferent_equals(value); end

    # source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#76
    def merge_options(original, additional); end
  end
end

# source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#13
Datadog::Tracing::Contrib::Utils::Quantization::Hash::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#11
Datadog::Tracing::Contrib::Utils::Quantization::Hash::EXCLUDE_KEYS = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#10
Datadog::Tracing::Contrib::Utils::Quantization::Hash::PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/contrib/utils/quantization/hash.rb#12
Datadog::Tracing::Contrib::Utils::Quantization::Hash::SHOW_KEYS = T.let(T.unsafe(nil), Array)

# Contains behavior for managing correlations with tracing
# e.g. Retrieve a correlation to the current trace for logging, etc.
# This class is for usage with log correlation.
# To continue from a trace, users should use TraceDigest instead.
#
# source://datadog//lib/datadog/tracing/correlation.rb#12
module Datadog::Tracing::Correlation
  private

  # source://datadog//lib/datadog/tracing/correlation.rb#96
  def format_trace_id(trace_id); end

  # source://datadog//lib/datadog/tracing/correlation.rb#104
  def format_trace_id_128(trace_id); end

  # Produces a CorrelationIdentifier from the TraceDigest provided
  #
  # DEV: can we memoize this object, give it can be common to
  # use a correlation multiple times, specially in the context of logging?
  #
  # source://datadog//lib/datadog/tracing/correlation.rb#87
  def identifier_from_digest(digest); end

  class << self
    # source://datadog//lib/datadog/tracing/correlation.rb#96
    def format_trace_id(trace_id); end

    # source://datadog//lib/datadog/tracing/correlation.rb#104
    def format_trace_id_128(trace_id); end

    # Produces a CorrelationIdentifier from the TraceDigest provided
    #
    # DEV: can we memoize this object, give it can be common to
    # use a correlation multiple times, specially in the context of logging?
    #
    # source://datadog//lib/datadog/tracing/correlation.rb#87
    def identifier_from_digest(digest); end
  end
end

# Represents current trace state with key identifiers
#
# source://datadog//lib/datadog/tracing/correlation.rb#15
class Datadog::Tracing::Correlation::Identifier
  # @return [Identifier] a new instance of Identifier
  #
  # source://datadog//lib/datadog/tracing/correlation.rb#30
  def initialize(env: T.unsafe(nil), service: T.unsafe(nil), span_id: T.unsafe(nil), trace_id: T.unsafe(nil), version: T.unsafe(nil)); end

  # Returns the value of attribute env.
  #
  # source://datadog//lib/datadog/tracing/correlation.rb#23
  def env; end

  # Returns the value of attribute service.
  #
  # source://datadog//lib/datadog/tracing/correlation.rb#23
  def service; end

  # Returns the value of attribute span_id.
  #
  # source://datadog//lib/datadog/tracing/correlation.rb#23
  def span_id; end

  # source://datadog//lib/datadog/tracing/correlation.rb#45
  def to_h; end

  # This method (#to_log_format) implements an algorithm by prefixing keys for nested values
  # but the algorithm makes the constants implicit. Hence, we use it for validation during test.
  #
  # source://datadog//lib/datadog/tracing/correlation.rb#62
  def to_log_format; end

  # source://datadog//lib/datadog/tracing/correlation.rb#75
  def trace_id; end

  # Returns the value of attribute version.
  #
  # source://datadog//lib/datadog/tracing/correlation.rb#23
  def version; end
end

# source://datadog//lib/datadog/tracing/correlation.rb#16
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_ENV = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/correlation.rb#17
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_SERVICE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/correlation.rb#21
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_SOURCE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/correlation.rb#18
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_SPAN_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/correlation.rb#19
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_TRACE_ID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/correlation.rb#20
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_VERSION = T.let(T.unsafe(nil), String)

# DefaultContextProvider is a default context provider that retrieves
# all contexts from the current fiber-local storage. It is suitable for
# synchronous programming.
#
# @see https://ruby-doc.org/core-3.1.2/Thread.html#method-i-5B-5D Thread attributes are fiber-local
#
# source://datadog//lib/datadog/tracing/context_provider.rb#13
class Datadog::Tracing::DefaultContextProvider
  # Initializes the default context provider with a fiber-bound context.
  #
  # @return [DefaultContextProvider] a new instance of DefaultContextProvider
  #
  # source://datadog//lib/datadog/tracing/context_provider.rb#15
  def initialize; end

  # Return the local context.
  #
  # source://datadog//lib/datadog/tracing/context_provider.rb#25
  def context(key = T.unsafe(nil)); end

  # Sets the current context.
  #
  # source://datadog//lib/datadog/tracing/context_provider.rb#20
  def context=(ctx); end
end

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#5
module Datadog::Tracing::Diagnostics; end

# Collects environment information for Tracing diagnostic logging
#
# source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#32
module Datadog::Tracing::Diagnostics::EnvironmentCollector
  class << self
    # Error returned by Datadog agent during a tracer flush attempt
    #
    # @return [String] concatenated list of transport errors
    #
    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#71
    def agent_error(responses); end

    # @return [String, nil] target agent URL for trace flushing
    #
    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#58
    def agent_url; end

    # @return [Boolean, nil] analytics enabled in configuration
    #
    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#80
    def analytics_enabled; end

    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#34
    def collect_config!; end

    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#46
    def collect_errors!(responses); end

    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#136
    def collect_integrations_settings!; end

    # @return [Boolean, nil]
    #
    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#53
    def enabled; end

    # Concatenated list of integrations activated, with their gem version.
    # Example: "rails@6.0.3,rack@2.2.3"
    #
    # @return [String, nil]
    #
    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#124
    def integrations_loaded; end

    # @return [Boolean, nil] partial flushing enabled in configuration
    #
    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#132
    def partial_flushing_enabled; end

    # @return [Numeric, nil] tracer sample rate configured
    #
    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#85
    def sample_rate; end

    # DEV: We currently only support SimpleRule instances.
    # DEV: These are the most commonly used rules.
    # DEV: We should expand support for other rules in the future,
    # DEV: although it is tricky to serialize arbitrary rules.
    #
    # @return [Hash, nil] sample rules configured
    #
    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#102
    def sampling_rules; end

    private

    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#150
    def instrumented_integrations; end
  end
end

# Collects and logs Tracing diagnostic and error information
#
# source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#12
module Datadog::Tracing::Diagnostics::EnvironmentLogger
  extend ::Datadog::Core::Diagnostics::EnvironmentLogging

  class << self
    # source://datadog//lib/datadog/tracing/diagnostics/environment_logger.rb#15
    def collect_and_log!(responses: T.unsafe(nil)); end
  end
end

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#7
module Datadog::Tracing::Diagnostics::Ext; end

# Health
#
# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#9
module Datadog::Tracing::Diagnostics::Ext::Health; end

# Metrics
#
# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#11
module Datadog::Tracing::Diagnostics::Ext::Health::Metrics; end

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#12
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_API_ERRORS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#13
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_API_REQUESTS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#14
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_API_RESPONSES = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#15
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_CONTEXT_OVERFLOW = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#16
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_INSTRUMENTATION_PATCH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#17
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_SPAN_FINISH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#18
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_UNFINISHED_SPANS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#19
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_INSTRUMENTATION_PATCHED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#20
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_ACCEPTED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#21
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_ACCEPTED_LENGTHS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#22
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_DROPPED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#23
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_LENGTH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#24
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_MAX_LENGTH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#25
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_SPANS = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#26
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_SAMPLING_SERVICE_CACHE_LENGTH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#27
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_TRACES_FILTERED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#28
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_TRANSPORT_CHUNKED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#29
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_TRANSPORT_TRACE_TOO_LARGE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/diagnostics/ext.rb#30
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_WRITER_CPU_TIME = T.let(T.unsafe(nil), String)

# Health-related diagnostics
#
# source://datadog//lib/datadog/tracing/diagnostics/health.rb#9
module Datadog::Tracing::Diagnostics::Health; end

# Health metrics for diagnostics
#
# source://datadog//lib/datadog/tracing/diagnostics/health.rb#11
module Datadog::Tracing::Diagnostics::Health::Metrics
  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/diagnostics/health.rb#12
    def extended(base); end
  end
end

# source://datadog//lib/datadog/tracing/distributed/helpers.rb#8
module Datadog::Tracing::Distributed; end

# B3 multi header-style trace propagation.
#
# @see https://github.com/openzipkin/b3-propagation#multiple-headers
#
# source://datadog//lib/datadog/tracing/distributed/b3_multi.rb#12
class Datadog::Tracing::Distributed::B3Multi
  # @return [B3Multi] a new instance of B3Multi
  #
  # source://datadog//lib/datadog/tracing/distributed/b3_multi.rb#17
  def initialize(fetcher:, trace_id_key: T.unsafe(nil), span_id_key: T.unsafe(nil), sampled_key: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/distributed/b3_multi.rb#46
  def extract(data); end

  # source://datadog//lib/datadog/tracing/distributed/b3_multi.rb#29
  def inject!(digest, data = T.unsafe(nil)); end
end

# source://datadog//lib/datadog/tracing/distributed/b3_multi.rb#15
Datadog::Tracing::Distributed::B3Multi::B3_SAMPLED_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/distributed/b3_multi.rb#14
Datadog::Tracing::Distributed::B3Multi::B3_SPAN_ID_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/distributed/b3_multi.rb#13
Datadog::Tracing::Distributed::B3Multi::B3_TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# B3 single header-style trace propagation.
#
# DEV: Format:
# DEV:   b3: {TraceId}-{SpanId}-{SamplingState}-{ParentSpanId}
# DEV: https://github.com/apache/incubator-zipkin-b3-propagation/tree/7c6e9f14d6627832bd80baa87ac7dabee7be23cf#single-header
# DEV: `{SamplingState}` and `{ParentSpanId}` are optional
#
# @see https://github.com/openzipkin/b3-propagation#single-header
#
# source://datadog//lib/datadog/tracing/distributed/b3_single.rb#17
class Datadog::Tracing::Distributed::B3Single
  # @return [B3Single] a new instance of B3Single
  #
  # source://datadog//lib/datadog/tracing/distributed/b3_single.rb#20
  def initialize(fetcher:, key: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/distributed/b3_single.rb#44
  def extract(env); end

  # source://datadog//lib/datadog/tracing/distributed/b3_single.rb#25
  def inject!(digest, env); end
end

# source://datadog//lib/datadog/tracing/distributed/b3_single.rb#18
Datadog::Tracing::Distributed::B3Single::B3_SINGLE_HEADER_KEY = T.let(T.unsafe(nil), String)

# W3C Baggage propagator implementation.
# The baggage header is propagated through `baggage`.
#
# @see https://www.w3.org/TR/baggage/
#
# source://datadog//lib/datadog/tracing/distributed/baggage.rb#16
class Datadog::Tracing::Distributed::Baggage
  # @return [Baggage] a new instance of Baggage
  #
  # source://datadog//lib/datadog/tracing/distributed/baggage.rb#24
  def initialize(fetcher:, baggage_key: T.unsafe(nil), baggage_tag_keys: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/distributed/baggage.rb#84
  def extract(data); end

  # source://datadog//lib/datadog/tracing/distributed/baggage.rb#34
  def inject!(digest, data); end

  private

  # Convert selected baggage items to span tags
  # Baggage carries important contextual information (like user.id, session.id) across distributed services,
  # but isn't searchable by default.
  #
  # source://datadog//lib/datadog/tracing/distributed/baggage.rb#166
  def build_baggage_tags(baggage); end

  # source://datadog//lib/datadog/tracing/distributed/baggage.rb#108
  def encode_item(item, safe_characters); end

  # Parses a W3C Baggage header string into a hash of key-value pairs
  # The header format follows the W3C Baggage specification:
  # - Multiple baggage items are separated by commas
  # - Each baggage item is a key-value pair separated by '='
  # - Keys and values are URL-encoded
  # - Returns an empty hash if the baggage header is malformed
  #
  # @param baggage_header [String] The W3C Baggage header string to parse
  # @return [Hash<String, String>] A hash of decoded baggage items
  #
  # source://datadog//lib/datadog/tracing/distributed/baggage.rb#138
  def parse_baggage_header(baggage_header); end

  # Record telemetry metrics for baggage operations
  #
  # source://datadog//lib/datadog/tracing/distributed/baggage.rb#189
  def record_telemetry_metric(metric_name, value, tags); end
end

# source://datadog//lib/datadog/tracing/distributed/baggage.rb#17
Datadog::Tracing::Distributed::Baggage::BAGGAGE_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/distributed/baggage.rb#20
Datadog::Tracing::Distributed::Baggage::BAGGAGE_TAG_KEYS_MATCH_ALL = T.let(T.unsafe(nil), Array)

# source://datadog//lib/datadog/tracing/distributed/baggage.rb#19
Datadog::Tracing::Distributed::Baggage::DD_TRACE_BAGGAGE_MAX_BYTES = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/distributed/baggage.rb#18
Datadog::Tracing::Distributed::Baggage::DD_TRACE_BAGGAGE_MAX_ITEMS = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/distributed/baggage.rb#21
Datadog::Tracing::Distributed::Baggage::SAFE_CHARACTERS_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/distributed/baggage.rb#22
Datadog::Tracing::Distributed::Baggage::SAFE_CHARACTERS_VALUE = T.let(T.unsafe(nil), String)

# Datadog-style trace propagation.
#
# source://datadog//lib/datadog/tracing/distributed/datadog.rb#13
class Datadog::Tracing::Distributed::Datadog
  # @return [Datadog] a new instance of Datadog
  #
  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#24
  def initialize(fetcher:, trace_id_key: T.unsafe(nil), parent_id_key: T.unsafe(nil), sampling_priority_key: T.unsafe(nil), origin_key: T.unsafe(nil), tags_key: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#55
  def extract(data); end

  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#40
  def inject!(digest, data); end

  private

  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#105
  def build_tags(digest); end

  # Import `x-datadog-tags` tags as trace distributed tags.
  # Only tags that have the `_dd.p.` prefix are processed.
  #
  # DEV: This method accesses global state (the active trace) to record its error state as a trace tag.
  # DEV: This means errors cannot be reported if there's not active span.
  # DEV: Ideally, we'd have a dedicated error reporting stream for all of datadog.
  #
  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#153
  def extract_tags(fetcher); end

  # Side effect: Remove high order 64 bit hex-encoded `tid` tag from distributed tags
  #
  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#115
  def extract_trace_id!(trace_id, tags); end

  # Export trace distributed tags through the `x-datadog-tags` key.
  #
  # DEV: This method accesses global state (the active trace) to record its error state as a trace tag.
  # DEV: This means errors cannot be reported if there's not active span.
  # DEV: Ideally, we'd have a dedicated error reporting stream for all of datadog.
  #
  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#129
  def inject_tags!(tags, data); end

  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#96
  def parse_parent_id(fetcher_object); end

  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#87
  def parse_trace_id(fetcher_object); end

  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#173
  def set_tags_propagation_error(reason:); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#179
  def tags_disabled?; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/distributed/datadog.rb#183
  def tags_too_large?(size, scenario:); end
end

# We want to exclude tags that we don't want to propagate downstream.
#
# source://datadog//lib/datadog/tracing/distributed/datadog.rb#196
Datadog::Tracing::Distributed::Datadog::EXCLUDED_TAG = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/distributed/datadog.rb#17
Datadog::Tracing::Distributed::Datadog::ORIGIN_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/distributed/datadog.rb#15
Datadog::Tracing::Distributed::Datadog::PARENT_ID_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/distributed/datadog.rb#16
Datadog::Tracing::Distributed::Datadog::SAMPLING_PRIORITY_KEY = T.let(T.unsafe(nil), String)

# Distributed trace-level tags
#
# source://datadog//lib/datadog/tracing/distributed/datadog.rb#19
Datadog::Tracing::Distributed::Datadog::TAGS_KEY = T.let(T.unsafe(nil), String)

# Prefix used by all Datadog-specific distributed tags
#
# source://datadog//lib/datadog/tracing/distributed/datadog.rb#22
Datadog::Tracing::Distributed::Datadog::TAGS_PREFIX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/distributed/datadog.rb#14
Datadog::Tracing::Distributed::Datadog::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# Encodes and decodes distributed 'x-datadog-tags' tags for transport
# to and from external processes.
#
# source://datadog//lib/datadog/tracing/distributed/datadog_tags_codec.rb#8
module Datadog::Tracing::Distributed::DatadogTagsCodec
  class << self
    # Deserializes a `x-datadog-tags`-formatted String into a {Hash<String,String>}.
    #
    # @param string [String] tags as serialized by {#encode}
    # @raise [DecodingError] if string does not conform to the `x-datadog-tags` format
    # @return [Hash<String,String>] decoded input as a hash of strings
    #
    # source://datadog//lib/datadog/tracing/distributed/datadog_tags_codec.rb#52
    def decode(string); end

    # Serializes a {Hash<String,String>} into a `x-datadog-tags`-compatible
    # String.
    #
    # @param tags [Hash<String,String>] trace tag hash
    # @raise [EncodingError] if tags cannot be serialized to the `x-datadog-tags` format
    # @return [String] serialized tags hash
    #
    # source://datadog//lib/datadog/tracing/distributed/datadog_tags_codec.rb#33
    def encode(tags); end
  end
end

# An error occurred during distributed tags decoding.
# See {#message} for more information.
#
# source://datadog//lib/datadog/tracing/distributed/datadog_tags_codec.rb#77
class Datadog::Tracing::Distributed::DatadogTagsCodec::DecodingError < ::StandardError; end

# An error occurred during distributed tags encoding.
# See {#message} for more information.
#
# source://datadog//lib/datadog/tracing/distributed/datadog_tags_codec.rb#72
class Datadog::Tracing::Distributed::DatadogTagsCodec::EncodingError < ::StandardError; end

# Backport `Regexp::match?` because it is measurably the most performant
# way to check if a string matches a regular expression.
#
# source://datadog//lib/datadog/tracing/distributed/datadog_tags_codec.rb#11
module Datadog::Tracing::Distributed::DatadogTagsCodec::RefineRegexp; end

# ASCII characters 32-126, except `,`, `=`, and ` `. At least one character.
#
# source://datadog//lib/datadog/tracing/distributed/datadog_tags_codec.rb#23
Datadog::Tracing::Distributed::DatadogTagsCodec::VALID_KEY_CHARS = T.let(T.unsafe(nil), Regexp)

# ASCII characters 32-126, except `,`. At least one character.
#
# source://datadog//lib/datadog/tracing/distributed/datadog_tags_codec.rb#25
Datadog::Tracing::Distributed::DatadogTagsCodec::VALID_VALUE_CHARS = T.let(T.unsafe(nil), Regexp)

# Common fetcher that retrieves fields from a Hash data input
#
# source://datadog//lib/datadog/tracing/distributed/fetcher.rb#9
class Datadog::Tracing::Distributed::Fetcher
  # @param data [Hash]
  # @return [Fetcher] a new instance of Fetcher
  #
  # source://datadog//lib/datadog/tracing/distributed/fetcher.rb#11
  def initialize(data); end

  # source://datadog//lib/datadog/tracing/distributed/fetcher.rb#15
  def [](key); end
end

# Helpers module provides common helper functions for distributed tracing data
#
# source://datadog//lib/datadog/tracing/distributed/helpers.rb#10
module Datadog::Tracing::Distributed::Helpers
  class << self
    # Base provides common methods for distributed helper classes
    #
    # source://datadog//lib/datadog/tracing/distributed/helpers.rb#12
    def clamp_sampling_priority(sampling_priority); end

    # source://datadog//lib/datadog/tracing/distributed/helpers.rb#23
    def parse_decimal_id(value); end

    # source://datadog//lib/datadog/tracing/distributed/helpers.rb#37
    def parse_hex_id(value); end
  end
end

# Propagator that does not inject nor extract data. It performs no operation.
# Supported for feature parity with OpenTelemetry.
#
# @see https://github.com/open-telemetry/opentelemetry-specification/blob/255a6c52b8914a2ed7e26bb5585abecab276aafc/specification/sdk-environment-variables.md?plain=1#L88
#
# source://datadog//lib/datadog/tracing/distributed/none.rb#9
class Datadog::Tracing::Distributed::None
  # No-op
  #
  # source://datadog//lib/datadog/tracing/distributed/none.rb#15
  def extract(_data); end

  # No-op
  #
  # source://datadog//lib/datadog/tracing/distributed/none.rb#11
  def inject!(_digest, _data); end
end

# Provides extraction and injection of distributed trace data.
#
# source://datadog//lib/datadog/tracing/distributed/propagation.rb#13
class Datadog::Tracing::Distributed::Propagation
  # @param propagation_extract_first [Boolean] if true, only the first successfully extracted trace will be used
  # @param propagation_style_extract [Array<String>] a list of styles to use when extracting distributed trace data
  # @param propagation_style_inject [Array<String>] a list of styles to use when injecting distributed trace data
  # @param propagation_styles [Hash<String,Object>] a map of propagation styles to their corresponding implementations
  # @return [Propagation] a new instance of Propagation
  #
  # source://datadog//lib/datadog/tracing/distributed/propagation.rb#22
  def initialize(propagation_styles:, propagation_style_inject:, propagation_style_extract:, propagation_extract_first:); end

  # extract returns {TraceDigest} containing the distributed trace information.
  # sampling priority defined in data.
  #
  # This method will never raise errors, but instead log them to `Datadog.logger`.
  #
  # @param data [Hash]
  #
  # source://datadog//lib/datadog/tracing/distributed/propagation.rb#96
  def extract(data); end

  # inject! populates the env with span ID, trace ID and sampling priority
  #
  # This method will never raise errors.
  # It can propagate partial data, if deemed useful, instead of failing.
  # In case of unrecoverable errors, it will log them to `Datadog.logger`.
  #
  # DEV-2.0: inject! should work without arguments, injecting the active_trace's digest
  # DEV-2.0: and returning a new Hash with the injected data.
  # DEV-2.0: inject! should also accept either a `trace` or a `digest`, as a `trace`
  # DEV-2.0: argument is the common use case, but also allows us to set error tags in the `trace`
  # DEV-2.0: if needed.
  # DEV-2.0: Ideally, we'd have a separate stream to report tracer errors and never
  # DEV-2.0: touch the active span.
  # DEV-3.0: Sample trace here instead of when generating digest.
  #
  # @param data [Hash]
  # @param digest [TraceDigest]
  # @return [Boolean] `true` if injected successfully, `false` if no propagation style is configured
  # @return [nil] in case of unrecoverable errors, see `Datadog.logger` output for details.
  #
  # source://datadog//lib/datadog/tracing/distributed/propagation.rb#58
  def inject!(digest, data); end

  private

  # source://datadog//lib/datadog/tracing/distributed/propagation.rb#171
  def last_datadog_parent_id(headers, tracecontext_tags); end

  # source://datadog//lib/datadog/tracing/distributed/propagation.rb#153
  def propagate_baggage(data, extracted_trace_digest); end
end

# Helper method to decide when to skip distributed tracing
#
# source://datadog//lib/datadog/tracing/distributed/propagation_policy.rb#7
module Datadog::Tracing::Distributed::PropagationPolicy
  private

  # Skips distributed tracing if disabled for this instrumentation
  # or if APM is disabled unless there is an AppSec event (from upstream distributed trace or local)
  #
  # Both pin_config and global_config are configuration for integrations.
  # pin_config is a Datadog::Core::Pin object, which gives the configuration of a single instance of an integration.
  # global_config is the config for all instances of an integration.
  #
  # source://datadog//lib/datadog/tracing/distributed/propagation_policy.rb#16
  def enabled?(pin_config: T.unsafe(nil), global_config: T.unsafe(nil), trace: T.unsafe(nil)); end

  class << self
    # Skips distributed tracing if disabled for this instrumentation
    # or if APM is disabled unless there is an AppSec event (from upstream distributed trace or local)
    #
    # Both pin_config and global_config are configuration for integrations.
    # pin_config is a Datadog::Core::Pin object, which gives the configuration of a single instance of an integration.
    # global_config is the config for all instances of an integration.
    #
    # @return [Boolean]
    #
    # source://datadog//lib/datadog/tracing/distributed/propagation_policy.rb#16
    def enabled?(pin_config: T.unsafe(nil), global_config: T.unsafe(nil), trace: T.unsafe(nil)); end
  end
end

# W3C Trace Context propagator implementation, version 00.
# The trace is propagated through two fields: `traceparent` and `tracestate`.
#
# @see https://www.w3.org/TR/trace-context/
#
# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#9
class Datadog::Tracing::Distributed::TraceContext
  # @return [TraceContext] a new instance of TraceContext
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#14
  def initialize(fetcher:, traceparent_key: T.unsafe(nil), tracestate_key: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#38
  def extract(data); end

  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#24
  def inject!(digest, data); end

  private

  # Sets the trace flag to an existing `trace_flags`.
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#135
  def build_trace_flags(digest); end

  # @see https://www.w3.org/TR/trace-context/#traceparent-header
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#107
  def build_traceparent(digest); end

  # For the current version (00), the traceparent has the following format:
  #
  # `"#{version}-#{trace_id}-#{parent_id}-#{trace_flags}"`
  #
  # Where:
  #   * `version`: 2 hex-encoded digits, zero padded.
  #   * `trace_id`: 32 hex-encoded digits, zero padded.
  #   * `parent_id`: 16 hex-encoded digits, zero padded.
  #   * `trace_flags`: 2 hex-encoded digits, zero padded.
  #
  # All hex values should be lowercase.
  #
  # @param parent_id [Integer] 64-bit
  # @param trace_flags [Integer] 8-bit
  # @param trace_id [Integer] 128-bit
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#130
  def build_traceparent_string(trace_id, parent_id, trace_flags); end

  # @see https://www.w3.org/TR/trace-context/#tracestate-header
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#150
  def build_tracestate(digest); end

  # Restore `~` back to `=`.
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#369
  def deserialize_tag_value(value); end

  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#326
  def extract_datadog_fields(dd_tracestate); end

  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#271
  def extract_traceparent(traceparent); end

  # tracestate, sampling_priority, ts_parent_id, origin, tags.
  #
  # @return [Array<String,Integer,String,String,Hash>] returns 4 values:
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#308
  def extract_tracestate(tracestate); end

  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#201
  def last_dd_parent_id(digest); end

  # If `sampled` and `sampling_priority` disagree, `sampled` overrides the decision.
  #
  # @return [Integer] one of the {Datadog::Tracing::Sampling::Ext::Priority} values
  # @yieldparam the new decision maker (either :drop or a new decision maker String value).
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#377
  def parse_priority_sampling(sampled, sampling_priority); end

  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#302
  def parse_sampled_flag(trace_flags); end

  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#282
  def parse_traceparent_string(traceparent); end

  # If any characters in <origin_value> are invalid, replace each invalid character with 0x5F (underscore).
  # Invalid characters are: characters outside the ASCII range 0x20 to 0x7E,
  # 0x2C (comma), 0x3B (semi-colon), and 0x7E (tilde).
  # Then, remap 0x3D (equals) to 0x7E (tilde)
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#216
  def serialize_origin(value); end

  # Serialize `_dd.p.{key}` by first removing the `_dd.p.` prefix.
  # Then replacing invalid characters with `_`.
  #
  # The argument `name` is always frozen.
  # Returns a new String object for the serialized key.
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#238
  def serialize_tag_key(name); end

  # Replaces invalid characters with `_`, then replaces `=` with `~`.
  #
  # The argument `value` belongs to {TraceDigest}, thus should not be directly modified.
  # Returns a new String object for the serialized value.
  #
  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#253
  def serialize_tag_value(value); end

  # source://datadog//lib/datadog/tracing/distributed/trace_context.rb#399
  def split_tracestate(tracestate); end
end

# Empty 8-bit `trace-flags`.
#
# @see https://www.w3.org/TR/trace-context/#trace-flags
#
# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#410
Datadog::Tracing::Distributed::TraceContext::DEFAULT_TRACE_FLAGS = T.let(T.unsafe(nil), Integer)

# Replace all characters with `_`, except ASCII characters 0x20-0x7E.
# Additionally, `,`, ';', and `~` must also be replaced by `_`.
#
# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#425
Datadog::Tracing::Distributed::TraceContext::INVALID_ORIGIN_CHARS = T.let(T.unsafe(nil), Regexp)

# Replace all characters with `_`, except ASCII characters 0x21-0x7E.
# Additionally, `,` and `=` must also be replaced by `_`.
#
# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#434
Datadog::Tracing::Distributed::TraceContext::INVALID_TAG_KEY_CHARS = T.let(T.unsafe(nil), Regexp)

# Replace all characters with `_`, except ASCII characters 0x20-0x7D.
# Additionally, `,` and `;` must also be replaced by `_`.
#
# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#439
Datadog::Tracing::Distributed::TraceContext::INVALID_TAG_VALUE_CHARS = T.let(T.unsafe(nil), Regexp)

# Version 0xFF is invalid as per spec
#
# @see https://www.w3.org/TR/trace-context/#version
#
# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#405
Datadog::Tracing::Distributed::TraceContext::INVALID_VERSION = T.let(T.unsafe(nil), String)

# Additionally, remap `=` to `~`
#
# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#429
Datadog::Tracing::Distributed::TraceContext::REMAP_ORIGIN_CHARS = T.let(T.unsafe(nil), Regexp)

# Refinements to ensure newer rubies do not suffer performance impact
# by needing to use older APIs.
#
# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#80
module Datadog::Tracing::Distributed::TraceContext::Refine; end

# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#12
Datadog::Tracing::Distributed::TraceContext::SPEC_VERSION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#10
Datadog::Tracing::Distributed::TraceContext::TRACEPARENT_KEY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#11
Datadog::Tracing::Distributed::TraceContext::TRACESTATE_KEY = T.let(T.unsafe(nil), String)

# The limit is inclusive: sizes *greater* than 256 are disallowed.
#
# @see https://www.w3.org/TR/trace-context/#value
#
# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#420
Datadog::Tracing::Distributed::TraceContext::TRACESTATE_VALUE_SIZE_LIMIT = T.let(T.unsafe(nil), Integer)

# Bit-mask for `trace-flags` that represents a sampled span (sampled==true).
#
# @see https://www.w3.org/TR/trace-context/#trace-flags
#
# source://datadog//lib/datadog/tracing/distributed/trace_context.rb#415
Datadog::Tracing::Distributed::TraceContext::TRACE_FLAGS_SAMPLED = T.let(T.unsafe(nil), Integer)

# A simple pub-sub event model for components to exchange messages through.
#
# source://datadog//lib/datadog/tracing/event.rb#38
class Datadog::Tracing::Event
  # @return [Event] a new instance of Event
  #
  # source://datadog//lib/datadog/tracing/event.rb#43
  def initialize(name); end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/tracing/event.rb#39
  def name; end

  # source://datadog//lib/datadog/tracing/event.rb#60
  def publish(*args); end

  # @raise [ArgumentError]
  #
  # source://datadog//lib/datadog/tracing/event.rb#48
  def subscribe(&block); end

  # Returns the value of attribute subscriptions.
  #
  # source://datadog//lib/datadog/tracing/event.rb#39
  def subscriptions; end

  # source://datadog//lib/datadog/tracing/event.rb#54
  def unsubscribe_all!; end
end

# Event behavior and DSL
#
# source://datadog//lib/datadog/tracing/event.rb#6
module Datadog::Tracing::Events
  include ::Datadog::Tracing::Events::InstanceMethods

  mixes_in_class_methods ::Datadog::Tracing::Events::ClassMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/event.rb#7
    def included(base); end
  end
end

# Class methods
#
# source://datadog//lib/datadog/tracing/event.rb#13
module Datadog::Tracing::Events::ClassMethods
  # source://datadog//lib/datadog/tracing/event.rb#14
  def build(**event_handlers); end
end

# Instance methods
#
# source://datadog//lib/datadog/tracing/event.rb#22
module Datadog::Tracing::Events::InstanceMethods
  # source://datadog//lib/datadog/tracing/event.rb#23
  def subscribe(**event_handlers); end
end

# FiberLocalContext can be used as a tracer global reference to create
# a different {Datadog::Tracing::Context} for each fiber. This allows for the tracer
# to create a serial execution graph regardless of any concurrent execution: each
# concurrent execution path creates a new trace graph.
#
# @see https://ruby-doc.org/core-3.1.2/Thread.html#method-i-5B-5D Thread attributes are fiber-local
#
# source://datadog//lib/datadog/tracing/context_provider.rb#48
class Datadog::Tracing::FiberLocalContext
  # To support multiple tracers simultaneously, each {Datadog::Tracing::FiberLocalContext}
  # instance has its own fiber-local variable.
  #
  # @return [FiberLocalContext] a new instance of FiberLocalContext
  #
  # source://datadog//lib/datadog/tracing/context_provider.rb#51
  def initialize; end

  # Return the fiber-local context.
  #
  # source://datadog//lib/datadog/tracing/context_provider.rb#63
  def local(storage = T.unsafe(nil)); end

  # Override the fiber-local context with a new context.
  #
  # source://datadog//lib/datadog/tracing/context_provider.rb#58
  def local=(ctx); end

  class << self
    # source://datadog//lib/datadog/tracing/context_provider.rb#77
    def next_instance_id; end
  end
end

# source://datadog//lib/datadog/tracing/context_provider.rb#73
Datadog::Tracing::FiberLocalContext::UNIQUE_INSTANCE_GENERATOR = T.let(T.unsafe(nil), Datadog::Core::Utils::Sequence)

# Ensure two instances of {FiberLocalContext} do not conflict.
# We previously used {FiberLocalContext#object_id} to ensure uniqueness
# but the VM is allowed to reuse `object_id`, allow for the possibility that
# a new FiberLocalContext would be able to read an old FiberLocalContext's
# value.
#
# source://datadog//lib/datadog/tracing/context_provider.rb#72
Datadog::Tracing::FiberLocalContext::UNIQUE_INSTANCE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# source://datadog//lib/datadog/tracing/flush.rb#5
module Datadog::Tracing::Flush; end

# Consumes and returns a {TraceSegment} to be flushed, from
# the provided {TraceSegment}.
#
# Only finished spans are consumed. Any spans consumed are
# removed from +trace_op+ as a side effect. Unfinished spans are
# unaffected.
#
# @abstract
#
# source://datadog//lib/datadog/tracing/flush.rb#14
class Datadog::Tracing::Flush::Base
  # Consumes and returns a {TraceSegment} to be flushed, from
  # the provided {TraceSegment}.
  #
  # Only finished spans are consumed. Any spans consumed are
  # removed from +trace_op+ as a side effect. Unfinished spans are
  # unaffected.
  #
  # @param trace_op [TraceOperation]
  # @return [TraceSegment] trace to be flushed, or +nil+ if the trace is not finished
  #
  # source://datadog//lib/datadog/tracing/flush.rb#24
  def consume!(trace_op); end

  # Should we consume spans from the +trace_op+?
  #
  # @abstract
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/flush.rb#32
  def flush?(trace_op); end

  protected

  # Consumes all finished spans from trace.
  #
  # @return [TraceSegment]
  #
  # source://datadog//lib/datadog/tracing/flush.rb#40
  def get_trace(trace_op); end

  # Single Span Sampling has chosen to keep this span
  # regardless of the trace-level sampling decision
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/flush.rb#50
  def single_sampled?(span); end
end

# Consumes and returns completed traces (where all spans have finished),
# if any, from the provided +trace_op+.
#
# Spans consumed are removed from +trace_op+ as a side effect.
#
# source://datadog//lib/datadog/tracing/flush.rb#59
class Datadog::Tracing::Flush::Finished < ::Datadog::Tracing::Flush::Base
  # Are all spans finished?
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/flush.rb#61
  def flush?(trace_op); end
end

# Consumes and returns completed or partially completed
# traces from the provided +trace_op+, if any.
#
# Partial trace flushing avoids large traces residing in memory for too long.
#
# Partially completed traces, where not all spans have finished,
# will only be returned if there are at least
# +@min_spans_for_partial+ finished spans.
#
# Spans consumed are removed from +trace_op+ as a side effect.
#
# source://datadog//lib/datadog/tracing/flush.rb#76
class Datadog::Tracing::Flush::Partial < ::Datadog::Tracing::Flush::Base
  # @return [Partial] a new instance of Partial
  #
  # source://datadog//lib/datadog/tracing/flush.rb#82
  def initialize(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/flush.rb#87
  def flush?(trace_op); end

  # Returns the value of attribute min_spans_for_partial.
  #
  # source://datadog//lib/datadog/tracing/flush.rb#80
  def min_spans_for_partial; end
end

# Start flushing partial trace after this many active spans in one trace
#
# source://datadog//lib/datadog/tracing/flush.rb#78
Datadog::Tracing::Flush::Partial::DEFAULT_MIN_SPANS_FOR_PARTIAL_FLUSH = T.let(T.unsafe(nil), Integer)

# Health metrics for trace buffers.
#
# source://datadog//lib/datadog/tracing/buffer.rb#11
module Datadog::Tracing::MeasuredBuffer
  # source://datadog//lib/datadog/tracing/buffer.rb#12
  def initialize(*_); end

  # source://datadog//lib/datadog/tracing/buffer.rb#21
  def add!(trace); end

  # source://datadog//lib/datadog/tracing/buffer.rb#28
  def add_all!(traces); end

  # Stored traces are returned and the local buffer is reset.
  #
  # source://datadog//lib/datadog/tracing/buffer.rb#46
  def drain!; end

  # source://datadog//lib/datadog/tracing/buffer.rb#52
  def measure_accept(trace); end

  # source://datadog//lib/datadog/tracing/buffer.rb#63
  def measure_drop(trace); end

  # source://datadog//lib/datadog/tracing/buffer.rb#73
  def measure_pop(traces); end

  # source://datadog//lib/datadog/tracing/buffer.rb#35
  def replace!(trace); end
end

# Adds common tagging behavior
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#5
module Datadog::Tracing::Metadata
  include ::Datadog::Tracing::Metadata::Tagging
  include ::Datadog::Tracing::Metadata::MetastructTagging
  include ::Datadog::Tracing::Metadata::Errors

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/metadata.rb#12
    def included(base); end
  end
end

# Defines analytics tagging behavior
#
# source://datadog//lib/datadog/tracing/metadata/analytics.rb#10
module Datadog::Tracing::Metadata::Analytics
  # source://datadog//lib/datadog/tracing/metadata/analytics.rb#11
  def set_tag(key, value); end
end

# Adds error tagging behavior
#
# source://datadog//lib/datadog/tracing/metadata/errors.rb#12
module Datadog::Tracing::Metadata::Errors
  # source://datadog//lib/datadog/tracing/metadata/errors.rb#13
  def set_error(error); end

  # Mark the span with the given error.
  #
  # source://datadog//lib/datadog/tracing/metadata/errors.rb#22
  def set_error_tags(error); end
end

# Trace and span tags that represent meta information
# regarding the trace. These fields are normally only used
# internally, and can have special meaning to downstream
# trace processing.
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#11
module Datadog::Tracing::Metadata::Ext; end

# Defines constants for trace analytics
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#38
module Datadog::Tracing::Metadata::Ext::Analytics; end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#39
Datadog::Tracing::Metadata::Ext::Analytics::DEFAULT_SAMPLE_RATE = T.let(T.unsafe(nil), Float)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#40
Datadog::Tracing::Metadata::Ext::Analytics::TAG_ENABLED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#41
Datadog::Tracing::Metadata::Ext::Analytics::TAG_MEASURED = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#42
Datadog::Tracing::Metadata::Ext::Analytics::TAG_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#45
module Datadog::Tracing::Metadata::Ext::AppTypes; end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#48
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_CACHE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#50
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_CUSTOM = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#47
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_DB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#46
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_WEB = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#49
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_WORKER = T.let(T.unsafe(nil), String)

# Tags related to distributed tracing
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#55
module Datadog::Tracing::Metadata::Ext::Distributed; end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#67
Datadog::Tracing::Metadata::Ext::Distributed::DD_PARENT_ID_DEFAULT = T.let(T.unsafe(nil), String)

# Trace tags with this prefix will propagate from a trace through distributed tracing.
# Distributed headers tags with this prefix will be injected into the active trace.
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#71
Datadog::Tracing::Metadata::Ext::Distributed::TAGS_PREFIX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#66
Datadog::Tracing::Metadata::Ext::Distributed::TAG_DD_PARENT_ID = T.let(T.unsafe(nil), String)

# What mechanism was used to make this trace's sampling decision.
#
# @see Datadog::Tracing::Sampling::Ext::Mechanism
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#58
Datadog::Tracing::Metadata::Ext::Distributed::TAG_DECISION_MAKER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#63
Datadog::Tracing::Metadata::Ext::Distributed::TAG_ORIGIN = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#64
Datadog::Tracing::Metadata::Ext::Distributed::TAG_SAMPLING_PRIORITY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#76
Datadog::Tracing::Metadata::Ext::Distributed::TAG_TID = T.let(T.unsafe(nil), String)

# Bitmask for which product generated an event. E.g.: 2 for an AppSec event.
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#61
Datadog::Tracing::Metadata::Ext::Distributed::TAG_TRACE_SOURCE = T.let(T.unsafe(nil), String)

# The distributed tag to carry hex encoded high order 64 bits of 127 bits trace id during
# the context restricted with 64 bits. Such as, Datadog propagation and messagepack encoding
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#75
Datadog::Tracing::Metadata::Ext::Distributed::TID = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#80
module Datadog::Tracing::Metadata::Ext::Errors; end

# From https://opentelemetry.io/docs/specs/semconv/registry/attributes/exception/#exception-stacktrace
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#87
Datadog::Tracing::Metadata::Ext::Errors::ATTRIBUTE_MESSAGE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#88
Datadog::Tracing::Metadata::Ext::Errors::ATTRIBUTE_STACKTRACE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#89
Datadog::Tracing::Metadata::Ext::Errors::ATTRIBUTE_TYPE = T.let(T.unsafe(nil), String)

# From https://opentelemetry.io/docs/specs/semconv/exceptions/exceptions-spans/#exception-event
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#92
Datadog::Tracing::Metadata::Ext::Errors::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#81
Datadog::Tracing::Metadata::Ext::Errors::STATUS = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#82
Datadog::Tracing::Metadata::Ext::Errors::TAG_MSG = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#83
Datadog::Tracing::Metadata::Ext::Errors::TAG_STACK = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#84
Datadog::Tracing::Metadata::Ext::Errors::TAG_TYPE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#96
module Datadog::Tracing::Metadata::Ext::HTTP; end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#97
Datadog::Tracing::Metadata::Ext::HTTP::ERROR_RANGE = T.let(T.unsafe(nil), Range)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#110
Datadog::Tracing::Metadata::Ext::HTTP::HEADER_USER_AGENT = T.let(T.unsafe(nil), String)

# General header functionality
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#113
module Datadog::Tracing::Metadata::Ext::HTTP::Headers
  private

  # Normalizes an HTTP header string into a valid tag string.
  #
  # By default, tags cannot create nested span tag levels:
  # `allow_nested` allows you to override this behavior.
  #
  # source://datadog//lib/datadog/tracing/metadata/ext.rb#122
  def to_tag(name, allow_nested: T.unsafe(nil)); end

  class << self
    # Normalizes an HTTP header string into a valid tag string.
    #
    # By default, tags cannot create nested span tag levels:
    # `allow_nested` allows you to override this behavior.
    #
    # source://datadog//lib/datadog/tracing/metadata/ext.rb#122
    def to_tag(name, allow_nested: T.unsafe(nil)); end
  end
end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#116
Datadog::Tracing::Metadata::Ext::HTTP::Headers::INVALID_TAG_CHARACTERS = T.let(T.unsafe(nil), Regexp)

# Request headers
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#147
module Datadog::Tracing::Metadata::Ext::HTTP::RequestHeaders
  private

  # source://datadog//lib/datadog/tracing/metadata/ext.rb#152
  def to_tag(name); end

  class << self
    # source://datadog//lib/datadog/tracing/metadata/ext.rb#152
    def to_tag(name); end
  end
end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#148
Datadog::Tracing::Metadata::Ext::HTTP::RequestHeaders::PREFIX = T.let(T.unsafe(nil), String)

# Response headers
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#158
module Datadog::Tracing::Metadata::Ext::HTTP::ResponseHeaders
  private

  # source://datadog//lib/datadog/tracing/metadata/ext.rb#163
  def to_tag(name); end

  class << self
    # source://datadog//lib/datadog/tracing/metadata/ext.rb#163
    def to_tag(name); end
  end
end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#159
Datadog::Tracing::Metadata::Ext::HTTP::ResponseHeaders::PREFIX = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#98
Datadog::Tracing::Metadata::Ext::HTTP::TAG_BASE_URL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#109
Datadog::Tracing::Metadata::Ext::HTTP::TAG_CLIENT_IP = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#99
Datadog::Tracing::Metadata::Ext::HTTP::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#103
Datadog::Tracing::Metadata::Ext::HTTP::TAG_ROUTE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#104
Datadog::Tracing::Metadata::Ext::HTTP::TAG_ROUTE_PATH = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#100
Datadog::Tracing::Metadata::Ext::HTTP::TAG_STATUS_CODE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#102
Datadog::Tracing::Metadata::Ext::HTTP::TAG_URL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#101
Datadog::Tracing::Metadata::Ext::HTTP::TAG_USER_AGENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#105
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_INBOUND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#106
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_OUTBOUND = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#107
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_PROXY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#108
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_TEMPLATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#170
module Datadog::Tracing::Metadata::Ext::NET; end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#174
Datadog::Tracing::Metadata::Ext::NET::TAG_DESTINATION_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#175
Datadog::Tracing::Metadata::Ext::NET::TAG_DESTINATION_PORT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#171
Datadog::Tracing::Metadata::Ext::NET::TAG_HOSTNAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#172
Datadog::Tracing::Metadata::Ext::NET::TAG_TARGET_HOST = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#173
Datadog::Tracing::Metadata::Ext::NET::TAG_TARGET_PORT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#194
module Datadog::Tracing::Metadata::Ext::SQL; end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#196
Datadog::Tracing::Metadata::Ext::SQL::TAG_QUERY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#195
Datadog::Tracing::Metadata::Ext::SQL::TYPE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#179
module Datadog::Tracing::Metadata::Ext::Sampling; end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#180
Datadog::Tracing::Metadata::Ext::Sampling::TAG_AGENT_RATE = T.let(T.unsafe(nil), String)

# If rate limiting is checked on a span, set this metric the effective rate limiting rate applied.
# This should be done regardless of rate limiting outcome.
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#188
Datadog::Tracing::Metadata::Ext::Sampling::TAG_RATE_LIMITER_RATE = T.let(T.unsafe(nil), String)

# If rule sampling is applied to a span, set this metric the sample rate configured for that rule.
# This should be done regardless of sampling outcome.
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#184
Datadog::Tracing::Metadata::Ext::Sampling::TAG_RULE_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#190
Datadog::Tracing::Metadata::Ext::Sampling::TAG_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#200
module Datadog::Tracing::Metadata::Ext::SpanKind; end

# source://datadog//lib/datadog/tracing/metadata/ext.rb#203
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_CLIENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#205
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_CONSUMER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#206
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_INTERNAL = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#204
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_PRODUCER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#201
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_PROXY = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#202
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_SERVER = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#34
Datadog::Tracing::Metadata::Ext::TAG_APM_ENABLED = T.let(T.unsafe(nil), String)

# Name of package that was instrumented
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#13
Datadog::Tracing::Metadata::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/metadata/ext.rb#25
Datadog::Tracing::Metadata::Ext::TAG_KIND = T.let(T.unsafe(nil), String)

# Type of operation being performed (e.g. )
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#15
Datadog::Tracing::Metadata::Ext::TAG_OPERATION = T.let(T.unsafe(nil), String)

# Hostname of external service interacted with
#
# This tag also doesn't strictly need to be a hostname. It can be a raw IP address and in some cases it
# can even be a unix domain socket (i.e. postgres client setting host=/var/run/postgres).
# It should be whatever the client uses to point at the server its trying to talk to.
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#21
Datadog::Tracing::Metadata::Ext::TAG_PEER_HOSTNAME = T.let(T.unsafe(nil), String)

# Name of external service that performed the work
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#23
Datadog::Tracing::Metadata::Ext::TAG_PEER_SERVICE = T.let(T.unsafe(nil), String)

# Set to `1.0` if profiling is enabled together with tracing, and `0.0` otherwise
# See Datadog-internal "RFC: Identifying which spans have profiling enabled " for details
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#32
Datadog::Tracing::Metadata::Ext::TAG_PROFILING_ENABLED = T.let(T.unsafe(nil), String)

# Set this tag to `1.0` if the span is a Service Entry span.
#
# source://datadog//lib/datadog/tracing/metadata/ext.rb#28
Datadog::Tracing::Metadata::Ext::TAG_TOP_LEVEL = T.let(T.unsafe(nil), String)

# This class is a data structure that is used to store
# complex metadata, such as an array of objects.
#
# It is serialized to MessagePack format when sent to the agent.
#
# source://datadog//lib/datadog/tracing/metadata/metastruct.rb#12
class Datadog::Tracing::Metadata::Metastruct
  extend ::Forwardable

  # @return [Metastruct] a new instance of Metastruct
  #
  # source://datadog//lib/datadog/tracing/metadata/metastruct.rb#17
  def initialize; end

  # source://datadog//lib/datadog/tracing/metadata/metastruct.rb#15
  def [](*args, **_arg1, &block); end

  # source://datadog//lib/datadog/tracing/metadata/metastruct.rb#15
  def []=(*args, **_arg1, &block); end

  # source://datadog//lib/datadog/tracing/metadata/metastruct.rb#28
  def pretty_print(q); end

  # source://datadog//lib/datadog/tracing/metadata/metastruct.rb#15
  def to_h(*args, **_arg1, &block); end

  # source://datadog//lib/datadog/tracing/metadata/metastruct.rb#21
  def to_msgpack(packer = T.unsafe(nil)); end
end

# Adds data storage for the `meta_struct` field.
#
# This field is used to send more complex data like an array of objects
# in MessagePack format to the agent, and has no size limitations.
#
# The agent fully supports meta_struct from version v7.35.0 (April 2022).
#
# On versions older than v7.35.0, sending traces containing meta_struct
# has no unexpected side-effects; traces are sent to the backend as expected,
# while the meta_struct field is stripped.
#
# source://datadog//lib/datadog/tracing/metadata/metastruct_tagging.rb#18
module Datadog::Tracing::Metadata::MetastructTagging
  # Return the metastruct tag value for the given key,
  # returns nil if the key doesn't exist.
  #
  # source://datadog//lib/datadog/tracing/metadata/metastruct_tagging.rb#30
  def get_metastruct_tag(key); end

  # Set the given key / value tag pair on the metastruct.
  #
  # A valid example is:
  #
  #   span.set_metastruct_tag('_dd.stack', [])
  #
  # source://datadog//lib/datadog/tracing/metadata/metastruct_tagging.rb#24
  def set_metastruct_tag(key, value); end

  private

  # source://datadog//lib/datadog/tracing/metadata/metastruct_tagging.rb#36
  def metastruct; end
end

# Adds metadata & metric tag behavior
#
# source://datadog//lib/datadog/tracing/metadata/tagging.rb#12
module Datadog::Tracing::Metadata::Tagging
  # Return the tag with the given key, nil if it doesn't exist.
  # Convenient interface for getting a single tag.
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#86
  def [](key); end

  # Set the given key / value tag pair on the span. Keys and values
  # must be strings. A valid example is:
  #
  #   span.set_tag('http.method', request.method)
  # Convenient interface for setting a single tag.
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#83
  def []=(key, value = T.unsafe(nil)); end

  # This method removes a metric for the given key. It acts like {#clear_tag}.
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#109
  def clear_metric(key); end

  # This method removes a tag for the given key.
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#78
  def clear_tag(key); end

  # Return the metric with the given key, nil if it doesn't exist.
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#89
  def get_metric(key); end

  # Return the tag with the given key, nil if it doesn't exist.
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#28
  def get_tag(key); end

  # Returns true if the provided `tag` was set to a non-nil value.
  # False otherwise.
  #
  # @param tag [String] the tag or metric to check for presence
  # @return [Boolean] if the tag is present and not nil
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#73
  def has_tag?(tag); end

  # This method sets a tag with a floating point value for the given key. It acts
  # like `set_tag()` and it simply add a tag without further processing.
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#95
  def set_metric(key, value); end

  # Set the given key / value tag pair on the span. Keys and values
  # must be strings. A valid example is:
  #
  #   span.set_tag('http.method', request.method)
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#36
  def set_tag(key, value = T.unsafe(nil)); end

  # Sets tags from given hash, for each key in hash it sets the tag with that key
  # and associated value from the hash. It is shortcut for `set_tag`. Keys and values
  # of the hash must be strings. Note that nested hashes are not supported.
  # A valid example is:
  #
  #   span.set_tags({ "http.method" => "GET", "user.id" => "234" })
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#64
  def set_tags(hash); end

  # Returns a copy of all metadata.
  # Keys for `@meta` and `@metrics` don't collide, by construction.
  #
  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#115
  def tags; end

  protected

  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#121
  def meta; end

  # source://datadog//lib/datadog/tracing/metadata/tagging.rb#125
  def metrics; end
end

# Some associated values should always be sent as Tags, never as Metrics, regardless
# if their value is numeric or not.
# The Datadog agent will look for these values only as Tags, not Metrics.
#
# @see https://github.com/DataDog/datadog-agent/blob/2ae2cdd315bcda53166dd8fa0dedcfc448087b9d/pkg/trace/stats/aggregation.go#L13-L17
#
# source://datadog//lib/datadog/tracing/metadata/tagging.rb#20
Datadog::Tracing::Metadata::Tagging::ENSURE_AGENT_TAGS = T.let(T.unsafe(nil), Hash)

# This limit is for numeric tags because uint64 could end up rounded.
#
# source://datadog//lib/datadog/tracing/metadata/tagging.rb#14
Datadog::Tracing::Metadata::Tagging::NUMERIC_TAG_SIZE_RANGE = T.let(T.unsafe(nil), Range)

# Modifies traces through a set of filters and processors
#
# source://datadog//lib/datadog/tracing/pipeline/span_processor.rb#5
module Datadog::Tracing::Pipeline
  class << self
    # @overload before_flush
    # @overload before_flush
    # @see file:docs/GettingStarted.md#configuring-the-transport-layer Configuring the transport layer
    #
    # source://datadog//lib/datadog/tracing/pipeline.rb#25
    def before_flush(*processors, &processor_block); end

    # source://datadog//lib/datadog/tracing/pipeline.rb#33
    def process!(traces); end

    # source://datadog//lib/datadog/tracing/pipeline.rb#41
    def processors=(value); end

    private

    # source://datadog//lib/datadog/tracing/pipeline.rb#45
    def apply_processors!(trace); end
  end
end

# SpanFilter implements a processor that filters entire span subtrees
# This processor executes the configured `operation` for each {Datadog::Tracing::Span}
# in a {Datadog::Tracing::TraceSegment}.
#
# If `operation` returns a truthy value for a span, that span is dropped,
# otherwise the span is kept.
#
# source://datadog//lib/datadog/tracing/pipeline/span_filter.rb#17
class Datadog::Tracing::Pipeline::SpanFilter < ::Datadog::Tracing::Pipeline::SpanProcessor
  # NOTE: This SpanFilter implementation only handles traces in which child spans appear
  # before parent spans in the trace array. If in the future child spans can be after
  # parent spans, then the code below will need to be updated.
  #
  # source://datadog//lib/datadog/tracing/pipeline/span_filter.rb#22
  def call(trace); end

  private

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/pipeline/span_filter.rb#40
  def drop_it?(span); end
end

# This processor executes the configured `operation` for each {Datadog::Tracing::Span}
# in a {Datadog::Tracing::TraceSegment}.
#
# source://datadog//lib/datadog/tracing/pipeline/span_processor.rb#10
class Datadog::Tracing::Pipeline::SpanProcessor
  # You can either provide an `operation` object or a block to this method.
  #
  # Both have the same semantics as `operation`.
  # `operation` is used if both `operation` and a block are present.
  #
  # @param operation [#call(Datadog::Tracing::Span)] a callable that can modify the span.
  # @raise [ArgumentError]
  # @return [SpanProcessor] a new instance of SpanProcessor
  #
  # source://datadog//lib/datadog/tracing/pipeline/span_processor.rb#17
  def initialize(operation = T.unsafe(nil), &block); end

  # Invokes `operation#call` for each spans in the `trace` argument.
  #
  # @param trace [Datadog::Tracing::TraceSegment] a trace segment.
  # @return [Datadog::Tracing::TraceSegment] the `trace` provided as an argument.
  #
  # source://datadog//lib/datadog/tracing/pipeline/span_processor.rb#29
  def call(trace); end
end

# Remote configuration declaration
#
# source://datadog//lib/datadog/tracing/remote.rb#9
module Datadog::Tracing::Remote
  class << self
    # source://datadog//lib/datadog/tracing/remote.rb#26
    def capabilities; end

    # source://datadog//lib/datadog/tracing/remote.rb#30
    def process_config(config, content); end

    # source://datadog//lib/datadog/tracing/remote.rb#22
    def products; end

    # source://datadog//lib/datadog/tracing/remote.rb#66
    def receiver(products = T.unsafe(nil), &block); end

    # source://datadog//lib/datadog/tracing/remote.rb#51
    def receivers(_telemetry); end

    private

    # @raise [ReadError]
    #
    # source://datadog//lib/datadog/tracing/remote.rb#73
    def parse_content(content); end
  end
end

# source://datadog//lib/datadog/tracing/remote.rb#10
class Datadog::Tracing::Remote::ReadError < ::StandardError; end

# source://datadog//lib/datadog/tracing/runtime/metrics.rb#5
module Datadog::Tracing::Runtime; end

# Decorates runtime metrics feature
#
# source://datadog//lib/datadog/tracing/runtime/metrics.rb#7
module Datadog::Tracing::Runtime::Metrics
  class << self
    # source://datadog//lib/datadog/tracing/runtime/metrics.rb#8
    def associate_trace(trace); end
  end
end

# source://datadog//lib/datadog/tracing/sampling/sampler.rb#5
module Datadog::Tracing::Sampling; end

# {Datadog::Tracing::Sampling::AllSampler} samples all the traces.
#
# source://datadog//lib/datadog/tracing/sampling/all_sampler.rb#9
class Datadog::Tracing::Sampling::AllSampler < ::Datadog::Tracing::Sampling::Sampler
  # source://datadog//lib/datadog/tracing/sampling/all_sampler.rb#14
  def sample!(trace); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/sampling/all_sampler.rb#10
  def sample?(_trace); end

  # source://datadog//lib/datadog/tracing/sampling/all_sampler.rb#18
  def sample_rate(*_); end
end

# source://datadog//lib/datadog/tracing/sampling/ext.rb#6
module Datadog::Tracing::Sampling::Ext; end

# List of how the decision was made for the trace-level sampling.
#
# These values used to populate the {Datadog::Tracing::Metadata::Ext::Distributed::TAG_DECISION_MAKER} tag.
#
# The decision has two parts, separated by a `-`:
# `part1-sampling_mechanism`. `part1` is currently not populated, thus
# this tag is currently formatted as `"-sampling_mechanism"`.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#38
module Datadog::Tracing::Sampling::Ext::Decision; end

# The sampling rate received in the agent's http response.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#42
Datadog::Tracing::Sampling::Ext::Decision::AGENT_RATE = T.let(T.unsafe(nil), String)

# Formerly AppSec.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#49
Datadog::Tracing::Sampling::Ext::Decision::ASM = T.let(T.unsafe(nil), String)

# Used before the tracer receives any rates from agent and there are no rules configured.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#40
Datadog::Tracing::Sampling::Ext::Decision::DEFAULT = T.let(T.unsafe(nil), String)

# User directly sets sampling priority via {Tracing.reject!} or {Tracing.keep!},
# or by a custom sampler implementation.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#47
Datadog::Tracing::Sampling::Ext::Decision::MANUAL = T.let(T.unsafe(nil), String)

# Dynamically configured  rule, automatically generated by Datadog.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#53
Datadog::Tracing::Sampling::Ext::Decision::REMOTE_DYNAMIC_RULE = T.let(T.unsafe(nil), String)

# Dynamically configured rule, explicitly created by the user.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#51
Datadog::Tracing::Sampling::Ext::Decision::REMOTE_USER_RULE = T.let(T.unsafe(nil), String)

# Locally configured rule.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#44
Datadog::Tracing::Sampling::Ext::Decision::TRACE_SAMPLING_RULE = T.let(T.unsafe(nil), String)

# List of what mechanism was used to make the trace-level sampling decision.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#26
module Datadog::Tracing::Sampling::Ext::Mechanism; end

# Single Span Sampled.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#28
Datadog::Tracing::Sampling::Ext::Mechanism::SPAN_SAMPLING_RATE = T.let(T.unsafe(nil), Integer)

# Priority is a hint given to the backend so that it knows which traces to reject or kept.
# In a distributed context, it should be set before any context propagation (fork, RPC calls) to be effective.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#10
module Datadog::Tracing::Sampling::Ext::Priority; end

# Used by the {PrioritySampler} to inform the backend that a trace should be kept and stored.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#18
Datadog::Tracing::Sampling::Ext::Priority::AUTO_KEEP = T.let(T.unsafe(nil), Integer)

# Used by the {PrioritySampler} to inform the backend that a trace should be rejected and not stored.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#16
Datadog::Tracing::Sampling::Ext::Priority::AUTO_REJECT = T.let(T.unsafe(nil), Integer)

# Use this to explicitly inform the backend that a trace MUST be kept and stored.
# This includes rules and rate limits configured by the user
# through the {Datadog::Tracing::Sampling::RuleSampler}.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#22
Datadog::Tracing::Sampling::Ext::Priority::USER_KEEP = T.let(T.unsafe(nil), Integer)

# Use this to explicitly inform the backend that a trace MUST be rejected and not stored.
# This includes rules and rate limits configured by the user
# through the {Datadog::Tracing::Sampling::RuleSampler}.
#
# source://datadog//lib/datadog/tracing/sampling/ext.rb#14
Datadog::Tracing::Sampling::Ext::Priority::USER_REJECT = T.let(T.unsafe(nil), Integer)

# Checks if a trace conforms to a matching criteria.
#
# @abstract
#
# source://datadog//lib/datadog/tracing/sampling/matcher.rb#8
class Datadog::Tracing::Sampling::Matcher
  # Returns `true` if the trace should conforms to this rule, `false` otherwise
  #
  # @param trace [TraceOperation]
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/sampling/matcher.rb#16
  def match?(trace); end

  class << self
    # Converts a glob pattern String to a case-insensitive String matcher object.
    # The match object will only return `true` if it matches the complete String.
    #
    # The following special characters are supported:
    # - `?` matches any single character
    # - `*` matches any substring
    #
    # @param glob [String]
    # @return [#match?(String)]
    #
    # source://datadog//lib/datadog/tracing/sampling/matcher.rb#29
    def glob_to_regex(glob); end
  end
end

# Returns `true` for any input
#
# source://datadog//lib/datadog/tracing/sampling/matcher.rb#48
Datadog::Tracing::Sampling::Matcher::MATCH_ALL = T.let(T.unsafe(nil), T.untyped)

# Pattern that matches any string
#
# source://datadog//lib/datadog/tracing/sampling/matcher.rb#10
Datadog::Tracing::Sampling::Matcher::MATCH_ALL_PATTERN = T.let(T.unsafe(nil), String)

# {Datadog::Tracing::Sampling::PrioritySampler}
#
# source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#12
class Datadog::Tracing::Sampling::PrioritySampler
  # @return [PrioritySampler] a new instance of PrioritySampler
  #
  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#21
  def initialize(opts = T.unsafe(nil)); end

  # NOTE: We do not advise using a pre-sampler. It can save resources,
  # but pre-sampling at rates < 100% may result in partial traces, unless
  # the pre-sampler knows exactly how to drop a span without dropping its ancestors.
  #
  # Additionally, as service metrics are calculated in the Datadog Agent,
  # the service's throughput will be underestimated.
  #
  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#19
  def pre_sampler; end

  # NOTE: We do not advise using a pre-sampler. It can save resources,
  # but pre-sampling at rates < 100% may result in partial traces, unless
  # the pre-sampler knows exactly how to drop a span without dropping its ancestors.
  #
  # Additionally, as service metrics are calculated in the Datadog Agent,
  # the service's throughput will be underestimated.
  #
  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#19
  def priority_sampler; end

  # DEV-2.0:We should get rid of this complicated interaction between @pre_sampler and @priority_sampler.
  # DEV-2.0:If the user wants to configure a custom sampler, we should only allow them to provide a complete
  # DEV-2.0:sampling suite, not having this convoluted support for mixing arbitrary provided samplers in
  # DEV-2.0:the PrioritySampler. Ideally, the PrioritySampler is only used by Datadog.
  # DEV-2.0:There are too many edge cases and combinations to work around currently in this class.
  #
  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#31
  def sample!(trace); end

  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#79
  def update(rate_by_service, decision: T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#154
  def assign_priority!(trace, priority); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#96
  def pre_sample?(trace); end

  # Ensures the trace's priority sampling decision is not changed by the @pre_sampler.
  # The @pre_sampler should only change `trace.sampled`.
  #
  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#119
  def preserving_priority_sampling(trace); end

  # Ensures the trace is always propagated to the writer and that
  # the sample rate metric represents the true client-side sampling.
  #
  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#136
  def preserving_sampling(trace); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#107
  def priority_assigned?(trace); end

  # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#111
  def priority_sample!(trace); end

  class << self
    # Check if the Priority Sampling decision is to keep or drop the trace.
    # Other factors can influence the sampling decision; this method is only
    # responsible for interpreting the Sampling Priority decision.
    #
    # @param priority_sampling [Integer] priority sampling number
    # @return [Boolean] true if trace is "kept" by priority sampling
    # @return [Boolean] false if trace is "dropped" by priority sampling
    #
    # source://datadog//lib/datadog/tracing/sampling/priority_sampler.rb#90
    def sampled?(priority_sampling); end
  end
end

# Samples at different rates by key.
#
# source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#10
class Datadog::Tracing::Sampling::RateByKeySampler < ::Datadog::Tracing::Sampling::Sampler
  # @raise [ArgumentError]
  # @return [RateByKeySampler] a new instance of RateByKeySampler
  #
  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#14
  def initialize(default_key, default_rate = T.unsafe(nil), decision: T.unsafe(nil), &block); end

  # Returns the value of attribute default_key.
  #
  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#11
  def default_key; end

  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#31
  def default_sampler; end

  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#63
  def delete(key); end

  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#69
  def delete_if(&block); end

  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#75
  def length; end

  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#27
  def resolve(trace); end

  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#35
  def sample!(trace); end

  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#43
  def sample_rate(trace); end

  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#51
  def update(key, rate, decision: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#57
  def update_all(rate_by_key, decision: T.unsafe(nil)); end

  private

  # source://datadog//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#81
  def set_rate(key, rate, decision); end
end

# {Datadog::Tracing::Sampling::RateByServiceSampler} samples different services at different rates
#
# source://datadog//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#9
class Datadog::Tracing::Sampling::RateByServiceSampler < ::Datadog::Tracing::Sampling::RateByKeySampler
  # @return [RateByServiceSampler] a new instance of RateByServiceSampler
  #
  # source://datadog//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#12
  def initialize(default_rate = T.unsafe(nil), env: T.unsafe(nil), decision: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#23
  def update(rate_by_service, decision: T.unsafe(nil)); end

  private

  # DEV: Creating a string on every trace to perform a single Hash lookup is expensive.
  #
  # Using 2 nested hashes: 1 for env and 1 for service is the fastest option.
  # This approach requires large API changes to `RateByKeySampler`.
  #
  # Reducing the interpolated string size, by using a 1 character separator,
  # is also measurably faster than the current method. This approach does not
  # require changes to `RateByKeySampler`.
  #
  # Keep in mind that these changes also require changes to `#update`.
  #
  # Comparison:
  #  2 nested hashes: `service_hash.fetch(service, {}).fetch(env, default_rate)`
  #                   7730045 i/s
  # 1 char separator: `hash.fetch("#{service}\0#{env}", default_rate)`
  #                   4302801 i/s - 1.80x slower
  #          current: `hash.fetch("service:#{service},env:#{env}", default_rate)`
  #                   2720459 i/s - 2.84x slower
  #
  # source://datadog//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#54
  def key_for(trace); end
end

# source://datadog//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#10
Datadog::Tracing::Sampling::RateByServiceSampler::DEFAULT_KEY = T.let(T.unsafe(nil), String)

# {Datadog::Tracing::Sampling::RateSampler} is based on a sample rate.
#
# source://datadog//lib/datadog/tracing/sampling/rate_sampler.rb#10
class Datadog::Tracing::Sampling::RateSampler < ::Datadog::Tracing::Sampling::Sampler
  # Initialize a {Datadog::Tracing::Sampling::RateSampler}.
  # This sampler keeps a random subset of the traces. Its main purpose is to
  # reduce the instrumentation footprint.
  #
  # @param sample_rate [Numeric] the sample rate between 0.0 and 1.0, inclusive.
  #   0.0 means that no trace will be sampled; 1.0 means that all traces will be  sampled.
  # @return [RateSampler] a new instance of RateSampler
  #
  # source://datadog//lib/datadog/tracing/sampling/rate_sampler.rb#20
  def initialize(sample_rate = T.unsafe(nil), decision: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/sampling/rate_sampler.rb#46
  def sample!(trace); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/sampling/rate_sampler.rb#42
  def sample?(trace); end

  # source://datadog//lib/datadog/tracing/sampling/rate_sampler.rb#33
  def sample_rate(*_); end

  # source://datadog//lib/datadog/tracing/sampling/rate_sampler.rb#37
  def sample_rate=(sample_rate); end
end

# source://datadog//lib/datadog/tracing/sampling/rate_sampler.rb#11
Datadog::Tracing::Sampling::RateSampler::KNUTH_FACTOR = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/sampling/rate_sampler.rb#12
Datadog::Tracing::Sampling::RateSampler::UINT64_MODULO = T.let(T.unsafe(nil), Integer)

# Sampling rule that dictates if a trace matches
# a specific criteria and what sampling strategy to
# apply in case of a positive match.
#
# source://datadog//lib/datadog/tracing/sampling/rule.rb#13
class Datadog::Tracing::Sampling::Rule
  # @param matcher [Matcher] A matcher to verify trace conformity against
  # @param sampler [Sampler] A sampler to be consulted on a positive match
  # @return [Rule] a new instance of Rule
  #
  # source://datadog//lib/datadog/tracing/sampling/rule.rb#22
  def initialize(matcher, sampler, provenance); end

  # Evaluates if the provided `trace` conforms to the `matcher`.
  #
  # @param trace [TraceOperation]
  # @return [Boolean] whether this rules applies to the trace
  # @return [NilClass] if the matcher fails errs during evaluation
  #
  # source://datadog//lib/datadog/tracing/sampling/rule.rb#33
  def match?(trace); end

  # Returns the value of attribute matcher.
  #
  # source://datadog//lib/datadog/tracing/sampling/rule.rb#18
  def matcher; end

  # Returns the value of attribute provenance.
  #
  # source://datadog//lib/datadog/tracing/sampling/rule.rb#18
  def provenance; end

  # Returns `true` if the provided trace should be kept.
  # Otherwise, `false`.
  #
  # This method *may* modify the `trace`, in case changes are necessary based on the
  # sampling decision.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @return [Boolean] should this trace be kept?
  #
  # source://datadog//lib/datadog/tracing/sampling/rule.rb#44
  def sample!(trace); end

  # The sampling rate, if this sampler has such concept.
  # Otherwise, `nil`.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @return [Float, nil] sampling ratio between 0.0 and 1.0 (inclusive), or `nil` if not applicable
  #
  # source://datadog//lib/datadog/tracing/sampling/rule.rb#49
  def sample_rate(trace); end

  # Returns the value of attribute sampler.
  #
  # source://datadog//lib/datadog/tracing/sampling/rule.rb#18
  def sampler; end
end

# source://datadog//lib/datadog/tracing/sampling/rule.rb#14
Datadog::Tracing::Sampling::Rule::PROVENANCE_LOCAL = T.let(T.unsafe(nil), Symbol)

# source://datadog//lib/datadog/tracing/sampling/rule.rb#16
Datadog::Tracing::Sampling::Rule::PROVENANCE_REMOTE_DYNAMIC = T.let(T.unsafe(nil), Symbol)

# source://datadog//lib/datadog/tracing/sampling/rule.rb#15
Datadog::Tracing::Sampling::Rule::PROVENANCE_REMOTE_USER = T.let(T.unsafe(nil), Symbol)

# Span {Sampler} that applies a set of {Rule}s to decide
# on sampling outcome. Then, a rate limiter is applied.
#
# If a trace does not conform to any rules, a default
# sampling strategy is applied.
#
# source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#16
class Datadog::Tracing::Sampling::RuleSampler
  # @param default_sample_rate [Float] fallback sample rate when no rules apply to a trace,
  #   between +[0,1]+, defaults to +1+
  # @param default_sampler [Sample] fallback strategy when no rules apply to a trace
  # @param rate_limit [Float] number of traces per second, defaults to +100+
  # @param rate_limiter [RateLimiter] limiter applied after rule matching
  # @param rules [Array<Rule>] ordered list of rules to be applied to a trace
  # @return [RuleSampler] a new instance of RuleSampler
  #
  # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#25
  def initialize(rules = T.unsafe(nil), rate_limit: T.unsafe(nil), rate_limiter: T.unsafe(nil), default_sample_rate: T.unsafe(nil), default_sampler: T.unsafe(nil)); end

  # Returns the value of attribute default_sampler.
  #
  # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#17
  def default_sampler; end

  # Returns the value of attribute rate_limiter.
  #
  # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#17
  def rate_limiter; end

  # Returns the value of attribute rules.
  #
  # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#17
  def rules; end

  # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#93
  def sample!(trace); end

  # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#107
  def update(*args, **kwargs); end

  private

  # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#115
  def sample_trace(trace); end

  # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#166
  def set_limiter_metrics(trace, limiter_rate); end

  # Span priority should only be set when the {RuleSampler}
  # was responsible for the sampling decision.
  #
  # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#154
  def set_priority(trace, sampled); end

  # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#162
  def set_rule_metrics(trace, sample_rate); end

  class << self
    # source://datadog//lib/datadog/tracing/sampling/rule_sampler.rb#55
    def parse(rules, rate_limit, default_sample_rate); end
  end
end

# Interface for client-side trace sampling.
#
# @abstract
#
# source://datadog//lib/datadog/tracing/sampling/sampler.rb#8
class Datadog::Tracing::Sampling::Sampler
  # Returns `true` if the provided trace should be kept.
  # Otherwise, `false`.
  #
  # This method *may* modify the `trace`, in case changes are necessary based on the
  # sampling decision.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @raise [NotImplementedError]
  # @return [Boolean] should this trace be kept?
  #
  # source://datadog//lib/datadog/tracing/sampling/sampler.rb#17
  def sample!(trace); end

  # The sampling rate, if this sampler has such concept.
  # Otherwise, `nil`.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @raise [NotImplementedError]
  # @return [Float, nil] sampling ratio between 0.0 and 1.0 (inclusive), or `nil` if not applicable
  #
  # source://datadog//lib/datadog/tracing/sampling/sampler.rb#26
  def sample_rate(trace); end
end

# A {Datadog::Sampling::Matcher} that supports matching a trace by
# trace name and/or service name.
#
# source://datadog//lib/datadog/tracing/sampling/matcher.rb#61
class Datadog::Tracing::Sampling::SimpleMatcher < ::Datadog::Tracing::Sampling::Matcher
  # @param name [String, Regexp, Proc] Matcher for case equality (===) with the trace name,
  #   defaults to always match
  # @param resource [String, Regexp, Proc] Matcher for case equality (===) with the resource name,
  #   defaults to always match
  # @param service [String, Regexp, Proc] Matcher for case equality (===) with the service name,
  #   defaults to always match
  # @return [SimpleMatcher] a new instance of SimpleMatcher
  #
  # source://datadog//lib/datadog/tracing/sampling/matcher.rb#70
  def initialize(name: T.unsafe(nil), service: T.unsafe(nil), resource: T.unsafe(nil), tags: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/sampling/matcher.rb#89
  def match?(trace); end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/tracing/sampling/matcher.rb#62
  def name; end

  # Returns the value of attribute resource.
  #
  # source://datadog//lib/datadog/tracing/sampling/matcher.rb#62
  def resource; end

  # Returns the value of attribute service.
  #
  # source://datadog//lib/datadog/tracing/sampling/matcher.rb#62
  def service; end

  # Returns the value of attribute tags.
  #
  # source://datadog//lib/datadog/tracing/sampling/matcher.rb#62
  def tags; end

  private

  # Match against the trace tags and metrics.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/sampling/matcher.rb#99
  def tags_match?(trace); end
end

# A {Datadog::Tracing::Sampling::Rule} that matches a trace based on
# trace name and/or service name and
# applies a fixed sampling to matching spans.
#
# source://datadog//lib/datadog/tracing/sampling/rule.rb#57
class Datadog::Tracing::Sampling::SimpleRule < ::Datadog::Tracing::Sampling::Rule
  # @param name [String, Regexp, Proc] Matcher for case equality (===) with the trace name, defaults to always match
  # @param resource [String, Regexp, Proc] Matcher for case equality (===) with the resource name,
  #   defaults to always match
  # @param sample_rate [Float] Sampling rate between +[0,1]+
  # @param service [String, Regexp, Proc] Matcher for case equality (===) with the service name,
  #   defaults to always match
  # @return [SimpleRule] a new instance of SimpleRule
  #
  # source://datadog//lib/datadog/tracing/sampling/rule.rb#64
  def initialize(name: T.unsafe(nil), service: T.unsafe(nil), resource: T.unsafe(nil), tags: T.unsafe(nil), provenance: T.unsafe(nil), sample_rate: T.unsafe(nil)); end
end

# source://datadog//lib/datadog/tracing/sampling/span/sampler.rb#6
module Datadog::Tracing::Sampling::Span; end

# Single Span Sampling constants.
#
# source://datadog//lib/datadog/tracing/sampling/span/ext.rb#8
module Datadog::Tracing::Sampling::Span::Ext; end

# Unlimited.
#
# @see Datadog::Core::TokenBucket
#
# source://datadog//lib/datadog/tracing/sampling/span/ext.rb#13
Datadog::Tracing::Sampling::Span::Ext::DEFAULT_MAX_PER_SECOND = T.let(T.unsafe(nil), Integer)

# Accept all spans (100% retention).
#
# source://datadog//lib/datadog/tracing/sampling/span/ext.rb#10
Datadog::Tracing::Sampling::Span::Ext::DEFAULT_SAMPLE_RATE = T.let(T.unsafe(nil), Float)

# Rate limit configured for this span, if a rule applies
#
# source://datadog//lib/datadog/tracing/sampling/span/ext.rb#20
Datadog::Tracing::Sampling::Span::Ext::TAG_MAX_PER_SECOND = T.let(T.unsafe(nil), String)

# Sampling decision method used to come to the sampling decision for this span
#
# source://datadog//lib/datadog/tracing/sampling/span/ext.rb#16
Datadog::Tracing::Sampling::Span::Ext::TAG_MECHANISM = T.let(T.unsafe(nil), String)

# Sampling rate applied to this span, if a rule applies
#
# source://datadog//lib/datadog/tracing/sampling/span/ext.rb#18
Datadog::Tracing::Sampling::Span::Ext::TAG_RULE_RATE = T.let(T.unsafe(nil), String)

# Checks if a span conforms to a matching criteria.
#
# source://datadog//lib/datadog/tracing/sampling/span/matcher.rb#10
class Datadog::Tracing::Sampling::Span::Matcher
  # Matches span name and service to their respective patterns provided.
  #
  # The patterns are {String}s with two special characters available:
  # 1. `?`: matches exactly one of any character.
  # 2. `*`: matches a substring of any size, including zero.
  # These patterns can occur any point of the string, any number of times.
  #
  # Both {SpanOperation#name} and {SpanOperation#service} must match the provided patterns.
  #
  # The whole String has to match the provided patterns: providing a pattern that
  # matches a portion of the provided String is not considered a match.
  #
  # @example cache-?
  #   `'cache-?'` will match any string starting with `database-` followed by exactly one character.
  # @example web-*
  #   `'web-*'` will match any string starting with `web-`.
  # @param name_pattern [String] a pattern to be matched against {SpanOperation#name}
  # @param service_pattern [String] a pattern to be matched against {SpanOperation#service}
  # @return [Matcher] a new instance of Matcher
  #
  # source://datadog//lib/datadog/tracing/sampling/span/matcher.rb#35
  def initialize(name_pattern: T.unsafe(nil), service_pattern: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/sampling/span/matcher.rb#51
  def ==(other); end

  # Returns `true` if the span conforms to the configured patterns,
  # `false` otherwise
  #
  # @param span [SpanOperation]
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/sampling/span/matcher.rb#45
  def match?(span); end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/tracing/sampling/span/matcher.rb#11
  def name; end

  # Returns the value of attribute service.
  #
  # source://datadog//lib/datadog/tracing/sampling/span/matcher.rb#11
  def service; end
end

# Pattern that matches any string
#
# source://datadog//lib/datadog/tracing/sampling/span/matcher.rb#14
Datadog::Tracing::Sampling::Span::Matcher::MATCH_ALL_PATTERN = T.let(T.unsafe(nil), String)

# Span sampling rule that applies a sampling rate if the span
# matches the provided {Matcher}.
# Additionally, a rate limiter is also applied.
#
# If a span does not conform to the matcher, no changes are made.
#
# source://datadog//lib/datadog/tracing/sampling/span/rule.rb#14
class Datadog::Tracing::Sampling::Span::Rule
  # Creates a new span sampling rule.
  #
  # @param matcher [Sampling::Span::Matcher] whether this rule applies to a specific span
  # @param rate_limit [Numeric] maximum number of spans sampled per second. Negative numbers mean unlimited spans.
  # @param sample_rate [Float] span sampling ratio, between 0.0 (0%) and 1.0 (100%).
  # @return [Rule] a new instance of Rule
  #
  # source://datadog//lib/datadog/tracing/sampling/span/rule.rb#22
  def initialize(matcher, sample_rate: T.unsafe(nil), rate_limit: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/sampling/span/rule.rb#66
  def ==(other); end

  # Returns the value of attribute matcher.
  #
  # source://datadog//lib/datadog/tracing/sampling/span/rule.rb#15
  def matcher; end

  # Returns the value of attribute rate_limit.
  #
  # source://datadog//lib/datadog/tracing/sampling/span/rule.rb#15
  def rate_limit; end

  # This method should only be invoked for spans that are part
  # of a trace that has been dropped by trace-level sampling.
  # Invoking it for other spans will cause incorrect sampling
  # metrics to be reported by the Datadog App.
  #
  # Returns `true` if the provided span is sampled.
  # If the span is dropped due to sampling rate or rate limiting,
  # it returns `false`.
  #
  # Returns `nil` if the span did not meet the matching criteria by the
  # provided matcher.
  #
  # This method modifies the `span` if it matches the provided matcher.
  #
  # @param span_op [Datadog::Tracing::SpanOperation] span to be sampled
  # @param trace_op [Datadog::Tracing::TraceOperation] trace for the span to be sampled
  # @return [:kept, :rejected] should this span be sampled?
  # @return [:not_matched] span did not satisfy the matcher, no changes are made to the span
  #
  # source://datadog//lib/datadog/tracing/sampling/span/rule.rb#53
  def sample!(trace_op, span_op); end

  # Returns the value of attribute sample_rate.
  #
  # source://datadog//lib/datadog/tracing/sampling/span/rule.rb#15
  def sample_rate; end
end

# Converts user configuration into {Datadog::Tracing::Sampling::Span::Rule} objects,
# handling any parsing errors.
#
# source://datadog//lib/datadog/tracing/sampling/span/rule_parser.rb#15
module Datadog::Tracing::Sampling::Span::RuleParser
  class << self
    # Parses the provided JSON string containing the Single Span
    # Sampling configuration list.
    # In case of parsing errors, `nil` is returned.
    #
    # @param rules [String] the JSON configuration rules to be parsed
    # @return [Array<Datadog::Tracing::Sampling::Span::Rule>] a list of parsed rules
    # @return [nil] if parsing failed
    #
    # source://datadog//lib/datadog/tracing/sampling/span/rule_parser.rb#24
    def parse_json(rules); end

    # Parses a list of Hashes containing the parsed JSON information
    # for Single Span Sampling configuration.
    # In case of parsing errors, `nil` is returned.
    #
    # @param rules [Array<String] the JSON configuration rules to be parsed] ules [Array<String] the JSON configuration rules to be parsed
    # @return [Array<Datadog::Tracing::Sampling::Span::Rule>] a list of parsed rules
    # @return [nil] if parsing failed
    #
    # source://datadog//lib/datadog/tracing/sampling/span/rule_parser.rb#47
    def parse_list(rules); end

    private

    # source://datadog//lib/datadog/tracing/sampling/span/rule_parser.rb#76
    def parse_rule(hash); end
  end
end

# Applies Single Span Sampling rules to spans.
# When matching the configured rules, a span is ensured to
# be processed Datadog App. In other words, a single sampled span
# will never be dropped by the tracer or Datadog agent.
#
# All spans in a trace are subject to the single sampling rules, if
# any rules are configured.
#
# Single Span Sampling is distinct from trace-level sampling:
# Single Span Sampling can ensure a span is kept, even if its
# enclosing trace is rejected by trace-level sampling.
#
# This class only applies operations to spans that are part
# of traces that was rejected by trace sampling.
# A trace is rejected if either of the following conditions is true:
# * The priority sampling for a trace is set to either {USER_REJECT} or {AUTO_REJECT}.
# * The trace was rejected by internal sampling, thus never flushed.
#
# Single-sampled spans are tagged and the tracer ensures they will
# reach the Datadog App, regardless of their enclosing trace sampling decision.
#
# Single Span Sampling does not inspect spans that are part of a trace
# that has been accepted by trace-level sampling rules: all spans from such
# trace are guaranteed to reach the Datadog App.
#
# source://datadog//lib/datadog/tracing/sampling/span/sampler.rb#31
class Datadog::Tracing::Sampling::Span::Sampler
  # Receives sampling rules to apply to individual spans.
  #
  # @param rules [Array<Datadog::Tracing::Sampling::Span::Rule>] list of rules to apply to spans
  # @return [Sampler] a new instance of Sampler
  #
  # source://datadog//lib/datadog/tracing/sampling/span/sampler.rb#37
  def initialize(rules = T.unsafe(nil)); end

  # Returns the value of attribute rules.
  #
  # source://datadog//lib/datadog/tracing/sampling/span/sampler.rb#32
  def rules; end

  # Applies Single Span Sampling rules to the span if the trace has been rejected.
  #
  # The trace can be outright rejected, and never reach the transport,
  # or be set as rejected by priority sampling. In both cases, the trace
  # is considered rejected for Single Span Sampling purposes.
  #
  # If multiple rules match, only the first one is applied.
  #
  # @param span_op [Datadog::Tracing::SpanOperation] Span to apply sampling rules
  # @param trace_op [Datadog::Tracing::TraceOperation] trace for the provided span
  # @return [void]
  #
  # source://datadog//lib/datadog/tracing/sampling/span/sampler.rb#52
  def sample!(trace_op, span_op); end
end

# Represents a logical unit of work in the system. Each trace consists of one or more spans.
# Each span consists of a start time and a duration. For example, a span can describe the time
# spent on a distributed call on a separate machine, or the time spent in a small component
# within a larger operation. Spans can be nested within each other, and in those instances
# will have a parent-child relationship.
#
# source://datadog//lib/datadog/tracing/span.rb#17
class Datadog::Tracing::Span
  include ::Datadog::Tracing::Metadata::Analytics
  include ::Datadog::Tracing::Metadata
  include ::Datadog::Tracing::Metadata::Tagging
  include ::Datadog::Tracing::Metadata::MetastructTagging
  include ::Datadog::Tracing::Metadata::Errors

  # Create a new span manually. Call the <tt>start()</tt> method to start the time
  # measurement and then <tt>stop()</tt> once the timing operation is over.
  #
  # * +service+: the service name for this span
  # * +resource+: the resource this span refers, or +name+ if it's missing.
  #     +nil+ can be used as a placeholder, when the resource value is not yet known at +#initialize+ time.
  # * +type+: the type of the span (such as +http+, +db+ and so on)
  # * +parent_id+: the identifier of the parent span
  # * +trace_id+: the identifier of the root span for this trace
  # * +service_entry+: whether it is a service entry span.
  # * +events+: the list of events that occurred while a span was active.
  #
  # @return [Span] a new instance of Span
  #
  # source://datadog//lib/datadog/tracing/span.rb#53
  def initialize(name, duration: T.unsafe(nil), end_time: T.unsafe(nil), id: T.unsafe(nil), meta: T.unsafe(nil), metrics: T.unsafe(nil), metastruct: T.unsafe(nil), parent_id: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), status: T.unsafe(nil), type: T.unsafe(nil), trace_id: T.unsafe(nil), service_entry: T.unsafe(nil), links: T.unsafe(nil), events: T.unsafe(nil)); end

  # Spans with the same ID are considered the same span
  #
  # source://datadog//lib/datadog/tracing/span.rb#132
  def ==(other); end

  # source://datadog//lib/datadog/tracing/span.rb#118
  def duration; end

  # Sets the attribute duration
  #
  # @param value the value to set the attribute duration to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#39
  def duration=(_arg0); end

  # Returns the value of attribute end_time.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def end_time; end

  # Sets the attribute end_time
  #
  # @param value the value to set the attribute end_time to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def end_time=(_arg0); end

  # Returns the value of attribute events.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def events; end

  # Sets the attribute events
  #
  # @param value the value to set the attribute events to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def events=(_arg0); end

  # Return whether the duration is stopped or not.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/span.rb#116
  def finished?; end

  # Returns the value of attribute id.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def id=(_arg0); end

  # Returns the value of attribute links.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def links; end

  # Sets the attribute links
  #
  # @param value the value to set the attribute links to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def links=(_arg0); end

  # Returns the value of attribute meta.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def meta; end

  # Sets the attribute meta
  #
  # @param value the value to set the attribute meta to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def meta=(_arg0); end

  # Returns the value of attribute metastruct.
  #
  # source://datadog//lib/datadog/tracing/span.rb#36
  def metastruct; end

  # Returns the value of attribute metrics.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def metrics; end

  # Sets the attribute metrics
  #
  # @param value the value to set the attribute metrics to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def metrics=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def name=(_arg0); end

  # Returns the value of attribute parent_id.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def parent_id; end

  # Sets the attribute parent_id
  #
  # @param value the value to set the attribute parent_id to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def parent_id=(_arg0); end

  # Return a human readable version of the span
  #
  # source://datadog//lib/datadog/tracing/span.rb#172
  def pretty_print(q); end

  # Returns the value of attribute resource.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def resource; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def resource=(_arg0); end

  # Returns the value of attribute service.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def service; end

  # Sets the attribute service
  #
  # @param value the value to set the attribute service to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def service=(_arg0); end

  # source://datadog//lib/datadog/tracing/span.rb#126
  def set_error(e); end

  # Returns the value of attribute start_time.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def start_time; end

  # Sets the attribute start_time
  #
  # @param value the value to set the attribute start_time to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def start_time=(_arg0); end

  # Return whether the duration is started or not
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/span.rb#108
  def started?; end

  # Returns the value of attribute status.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def status=(_arg0); end

  # Return whether the duration is stopped or not.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/span.rb#113
  def stopped?; end

  # Return the hash representation of the current span.
  # TODO: Change this to reflect attributes when serialization
  # isn't handled by this method.
  #
  # source://datadog//lib/datadog/tracing/span.rb#145
  def to_hash; end

  # Return a string representation of the span.
  #
  # source://datadog//lib/datadog/tracing/span.rb#138
  def to_s; end

  # Returns the value of attribute trace_id.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def trace_id; end

  # Sets the attribute trace_id
  #
  # @param value the value to set the attribute trace_id to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def trace_id=(_arg0); end

  # Returns the value of attribute type.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://datadog//lib/datadog/tracing/span.rb#20
  def type=(_arg0); end

  private

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://datadog//lib/datadog/tracing/span.rb#218
  def duration_nano; end

  # https://docs.datadoghq.com/tracing/visualization/#service-entry-span
  # A span is a service entry span when it is the entrypoint method for a request to a service.
  # You can visualize this within Datadog APM when the color of the immediate parent on a flame graph is a different
  # color. Services are also listed on the right when viewing a flame graph.
  #
  # @return [Boolean] `true` if the span is a serivce entry span
  #
  # source://datadog//lib/datadog/tracing/span.rb#231
  def service_entry?; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://datadog//lib/datadog/tracing/span.rb#210
  def start_time_nano; end
end

# Represents a timestamped annotation on a span. It is analogous to structured log message.
#
# source://datadog//lib/datadog/tracing/span_event.rb#9
class Datadog::Tracing::SpanEvent
  # TODO: Accept {Time} as the time_unix_nano parameter, possibly in addition to the current nano integer.
  #
  # @return [SpanEvent] a new instance of SpanEvent
  #
  # source://datadog//lib/datadog/tracing/span_event.rb#23
  def initialize(name, attributes: T.unsafe(nil), time_unix_nano: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  #
  # source://datadog//lib/datadog/tracing/span_event.rb#16
  def attributes; end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/tracing/span_event.rb#12
  def name; end

  # Returns the value of attribute time_unix_nano.
  #
  # source://datadog//lib/datadog/tracing/span_event.rb#20
  def time_unix_nano; end

  # Converts the span event into a hash to be used by with the span tag serialization
  # (`span.set_tag('events) = [event.to_hash]`). This serialization format has the drawback
  # of being limiting span events to the size limit of a span tag.
  # All Datadog agents support this format.
  #
  # source://datadog//lib/datadog/tracing/span_event.rb#43
  def to_hash; end

  # Converts the span event into a hash to be used by the MessagePack serialization as a
  # top-level span field (span.span_events = [event.to_native_format]).
  # This serialization format removes the serialization limitations of the `span.set_tag('events)` approach,
  # but is only supported by newer version of the Datadog agent.
  #
  # source://datadog//lib/datadog/tracing/span_event.rb#53
  def to_native_format; end

  private

  # Serializes individual scalar attributes into the native format.
  #
  # source://datadog//lib/datadog/tracing/span_event.rb#144
  def serialize_native_attribute(value); end

  # Checks the attributes hash to ensure it only contains serializable values.
  # Invalid values are removed from the hash.
  #
  # source://datadog//lib/datadog/tracing/span_event.rb#77
  def validate_attributes!(attributes); end

  # source://datadog//lib/datadog/tracing/span_event.rb#113
  def validate_scalar_attribute!(key, value); end
end

# source://datadog//lib/datadog/tracing/span_event.rb#141
Datadog::Tracing::SpanEvent::ARRAY_TYPE = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/span_event.rb#138
Datadog::Tracing::SpanEvent::BOOLEAN_TYPE = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/span_event.rb#140
Datadog::Tracing::SpanEvent::DOUBLE_TYPE = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/span_event.rb#139
Datadog::Tracing::SpanEvent::INTEGER_TYPE = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/span_event.rb#73
Datadog::Tracing::SpanEvent::MAX_INT64_SIGNED = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/span_event.rb#72
Datadog::Tracing::SpanEvent::MIN_INT64_SIGNED = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/span_event.rb#137
Datadog::Tracing::SpanEvent::STRING_TYPE = T.let(T.unsafe(nil), Integer)

# SpanLink represents a causal link between two spans.
#
# source://datadog//lib/datadog/tracing/span_link.rb#7
class Datadog::Tracing::SpanLink
  # @return [SpanLink] a new instance of SpanLink
  #
  # source://datadog//lib/datadog/tracing/span_link.rb#43
  def initialize(digest, attributes: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  #
  # source://datadog//lib/datadog/tracing/span_link.rb#21
  def attributes; end

  # Returns the value of attribute dropped_attributes.
  #
  # source://datadog//lib/datadog/tracing/span_link.rb#41
  def dropped_attributes; end

  # Returns the value of attribute span_id.
  #
  # source://datadog//lib/datadog/tracing/span_link.rb#11
  def span_id; end

  # source://datadog//lib/datadog/tracing/span_link.rb#61
  def to_hash; end

  # Returns the value of attribute trace_flags.
  #
  # source://datadog//lib/datadog/tracing/span_link.rb#27
  def trace_flags; end

  # Returns the value of attribute trace_id.
  #
  # source://datadog//lib/datadog/tracing/span_link.rb#16
  def trace_id; end

  # Returns the value of attribute trace_state.
  #
  # source://datadog//lib/datadog/tracing/span_link.rb#36
  def trace_state; end
end

# Represents the act of taking a span measurement.
# It gives a Span a context which can be used to
# build a Span. When completed, it yields the Span.
#
# source://datadog//lib/datadog/tracing/span_operation.rb#25
class Datadog::Tracing::SpanOperation
  include ::Datadog::Tracing::Metadata::Analytics
  include ::Datadog::Tracing::Metadata
  include ::Datadog::Tracing::Metadata::Tagging
  include ::Datadog::Tracing::Metadata::MetastructTagging
  include ::Datadog::Tracing::Metadata::Errors

  # @return [SpanOperation] a new instance of SpanOperation
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#44
  def initialize(name, logger: T.unsafe(nil), events: T.unsafe(nil), on_error: T.unsafe(nil), parent_id: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), trace_id: T.unsafe(nil), type: T.unsafe(nil), links: T.unsafe(nil), span_events: T.unsafe(nil), id: T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/span_operation.rb#289
  def duration; end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#30
  def end_time; end

  # for backwards compatibility
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#264
  def end_time=(time); end

  # source://datadog//lib/datadog/tracing/span_operation.rb#268
  def finish(end_time = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#285
  def finished?; end

  # source://datadog//lib/datadog/tracing/span_operation.rb#144
  def get_collector_or_initialize; end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#30
  def id; end

  # Returns the value of attribute links.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#42
  def links; end

  # Sets the attribute links
  #
  # @param value the value to set the attribute links to.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#42
  def links=(_arg0); end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#30
  def logger; end

  # @raise [ArgumentError]
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#148
  def measure; end

  # Operation name.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#30
  def name; end

  # Operation name.
  #
  # @raise [ArgumentError]
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#117
  def name=(name); end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#30
  def parent_id; end

  # Return a human readable version of the span
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#352
  def pretty_print(q); end

  # Record an exception during the execution of this span. Multiple exceptions
  # can be recorded on a span.
  #
  # @param attributes [optional Hash{String => String, Numeric, Boolean, Array<String, Numeric, Boolean>}] One or more key:value pairs, where the keys must be
  #   strings and the values may be (array of) string, boolean or numeric
  #   type.
  # @param exception [Exception] The exception to record
  # @return [void]
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#310
  def record_exception(exception, attributes: T.unsafe(nil)); end

  # Span resource.
  #
  # @return [String] String
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#30
  def resource; end

  # Span resource.
  #
  # @return [String] String
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#140
  def resource=(resource); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#254
  def root?; end

  # Service name.
  #
  # @return [String] String
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#30
  def service; end

  # Service name.
  #
  # @return [String] String
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#133
  def service=(service); end

  # source://datadog//lib/datadog/tracing/span_operation.rb#295
  def set_error(e); end

  # Returns the value of attribute span_events.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#42
  def span_events; end

  # Sets the attribute span_events
  #
  # @param value the value to set the attribute span_events to.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#42
  def span_events=(_arg0); end

  # source://datadog//lib/datadog/tracing/span_operation.rb#202
  def start(start_time = T.unsafe(nil)); end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#30
  def start_time; end

  # for backwards compatibility
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#259
  def start_time=(time); end

  # Return whether the duration is started or not
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#245
  def started?; end

  # Returns the value of attribute status.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#42
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#42
  def status=(_arg0); end

  # Mark the span stopped at the current time
  #
  # steep:ignore:start
  # Steep issue fixed in https://github.com/soutaro/steep/pull/1467
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#220
  def stop(stop_time = T.unsafe(nil), exception: T.unsafe(nil)); end

  # Return whether the duration is stopped or not.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#250
  def stopped?; end

  # Return the hash representation of the current span.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#328
  def to_hash; end

  # Return a string representation of the span.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#323
  def to_s; end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#30
  def trace_id; end

  # Span type.
  #
  # @return [String] String
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#30
  def type; end

  # Span type.
  #
  # @return [String] String
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#126
  def type=(type); end

  private

  # Create a Span from the operation which represents
  # the finalized measurement. We #dup here to prevent
  # mutation by reference; when this span is returned,
  # we don't want this SpanOperation to modify it further.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#500
  def build_span; end

  # source://datadog//lib/datadog/tracing/span_operation.rb#544
  def duration_marker; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#556
  def duration_nano; end

  # Keep span reference private: we don't want users
  # modifying the finalized span from the operation after
  # it has been finished.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#488
  def events; end

  # Stored only for `service_entry` calculation.
  # Use `parent_id` for the effective parent span id.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#494
  def parent; end

  # Set this span's parent, setting this span's trace_id to the parent's trace_id.
  #
  # If the parent is nil, set this span as the root span.
  #
  # DEV: This method creates a false expectation that
  # `self.parent.id == self.parent_id`, which is not the case
  # for distributed traces, as the parent Span object does not exist
  # in this application. `#parent_id` is the only reliable parent
  # identifier. We should remove the ability to set a parent Span
  # object in the future.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#532
  def parent=(parent); end

  # Keep span reference private: we don't want users
  # modifying the finalized span from the operation after
  # it has been finished.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#488
  def span; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#550
  def start_time_nano; end
end

# Error when the span attempts to start again after being started
#
# source://datadog//lib/datadog/tracing/span_operation.rb#477
class Datadog::Tracing::SpanOperation::AlreadyStartedError < ::StandardError
  # source://datadog//lib/datadog/tracing/span_operation.rb#478
  def message; end
end

# Callback behavior
#
# source://datadog//lib/datadog/tracing/span_operation.rb#387
class Datadog::Tracing::SpanOperation::Events
  include ::Datadog::Tracing::Events
  include ::Datadog::Tracing::Events::InstanceMethods
  extend ::Datadog::Tracing::Events::ClassMethods

  # @return [Events] a new instance of Events
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#398
  def initialize(logger: T.unsafe(nil), on_error: T.unsafe(nil)); end

  # Returns the value of attribute after_finish.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#392
  def after_finish; end

  # Returns the value of attribute after_stop.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#392
  def after_stop; end

  # Returns the value of attribute before_start.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#392
  def before_start; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#392
  def logger; end

  # This event is lazily initialized as error paths
  # are normally less common that non-error paths.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#407
  def on_error; end
end

# Triggered when the span is finished, regardless of error.
#
# source://datadog//lib/datadog/tracing/span_operation.rb#412
class Datadog::Tracing::SpanOperation::Events::AfterFinish < ::Datadog::Tracing::Event
  # @return [AfterFinish] a new instance of AfterFinish
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#413
  def initialize; end
end

# Triggered when the span is stopped, regardless of error.
#
# source://datadog//lib/datadog/tracing/span_operation.rb#419
class Datadog::Tracing::SpanOperation::Events::AfterStop < ::Datadog::Tracing::Event
  # @return [AfterStop] a new instance of AfterStop
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#420
  def initialize; end
end

# Triggered just before the span is started.
#
# source://datadog//lib/datadog/tracing/span_operation.rb#426
class Datadog::Tracing::SpanOperation::Events::BeforeStart < ::Datadog::Tracing::Event
  # @return [BeforeStart] a new instance of BeforeStart
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#427
  def initialize; end
end

# source://datadog//lib/datadog/tracing/span_operation.rb#390
Datadog::Tracing::SpanOperation::Events::DEFAULT_ON_ERROR = T.let(T.unsafe(nil), Proc)

# Triggered when the span raises an error during measurement.
#
# source://datadog//lib/datadog/tracing/span_operation.rb#433
class Datadog::Tracing::SpanOperation::Events::OnError
  # @return [OnError] a new instance of OnError
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#434
  def initialize(default, logger: T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#439
  def logger; end

  # source://datadog//lib/datadog/tracing/span_operation.rb#462
  def publish(*args); end

  # DEV: Revisit this before full 1.0 release.
  # It seems like OnError wants to behave like a middleware stack,
  # where each "subscriber"'s executed is chained to the previous one.
  # This is different from how {Tracing::Event} works, and might be incompatible.
  #
  # source://datadog//lib/datadog/tracing/span_operation.rb#447
  def wrap_default; end
end

# SyncWriter flushes both services and traces synchronously
# DEV: To be replaced by Datadog::Tracing::Workers::TraceWriter.
#
# Note: If you're wondering if this class is used at all, since there are no other references to it on the codebase,
# the separate `datadog-lambda` uses it as of February 2021:
# <https://github.com/DataDog/datadog-lambda-rb/blob/c15f0f0916c90123416dc44e7d6800ef4a7cfdbf/lib/datadog/lambda.rb#L38>
#
# source://datadog//lib/datadog/tracing/sync_writer.rb#18
class Datadog::Tracing::SyncWriter
  # @param agent_settings [Datadog::Tracing::Configuration::AgentSettings] agent options for
  #   the default transport instance.
  # @param transport [Datadog::Tracing::Transport::Traces::Transport] a custom transport instance.
  #   If provided, overrides `transport_options` and `agent_settings`.
  # @param transport_options [Hash<Symbol,Object>] options for the default transport instance.
  # @return [SyncWriter] a new instance of SyncWriter
  #
  # source://datadog//lib/datadog/tracing/sync_writer.rb#30
  def initialize(transport: T.unsafe(nil), transport_options: T.unsafe(nil), agent_settings: T.unsafe(nil), logger: T.unsafe(nil)); end

  # Returns the value of attribute agent_settings.
  #
  # source://datadog//lib/datadog/tracing/sync_writer.rb#19
  def agent_settings; end

  # Returns the value of attribute events.
  #
  # source://datadog//lib/datadog/tracing/sync_writer.rb#19
  def events; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/tracing/sync_writer.rb#19
  def logger; end

  # Does nothing.
  # The {SyncWriter} does not need to be stopped as it holds no state.
  #
  # source://datadog//lib/datadog/tracing/sync_writer.rb#52
  def stop; end

  # Returns the value of attribute transport.
  #
  # source://datadog//lib/datadog/tracing/sync_writer.rb#19
  def transport; end

  # Sends traces to the configured transport.
  #
  # Traces are flushed immediately.
  #
  # source://datadog//lib/datadog/tracing/sync_writer.rb#44
  def write(trace); end

  private

  # source://datadog//lib/datadog/tracing/sync_writer.rb#59
  def flush_trace(trace); end
end

# Trace buffer that stores application traces, has a maximum size, and
# can be safely used concurrently on any environment.
#
# @see Datadog::Core::Buffer::ThreadSafe
#
# source://datadog//lib/datadog/tracing/buffer.rb#103
class Datadog::Tracing::ThreadSafeTraceBuffer < ::Datadog::Core::Buffer::ThreadSafe
  include ::Datadog::Tracing::MeasuredBuffer
end

# Trace buffer that stores application traces. The buffer has a maximum size and when
# the buffer is full, a random trace is discarded. This class is thread-safe and is used
# automatically by the ``Tracer`` instance when a ``Span`` is finished.
#
# We choose the default TraceBuffer implementation for current platform dynamically here.
#
# TODO We should restructure this module, so that classes are not declared at top-level ::Datadog.
# TODO Making such a change is potentially breaking for users manually configuring the tracer.
#
# source://datadog//lib/datadog/tracing/buffer.rb#123
Datadog::Tracing::TraceBuffer = Datadog::Tracing::CRubyTraceBuffer

# Trace digest that represents the important parts of an active trace.
# Used to propagate context and continue traces across execution boundaries.
# TODO: Update all references from span to parent (ex: span_id -> parent_id)
#
# source://datadog//lib/datadog/tracing/trace_digest.rb#9
class Datadog::Tracing::TraceDigest
  # @return [TraceDigest] a new instance of TraceDigest
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#111
  def initialize(span_id: T.unsafe(nil), span_name: T.unsafe(nil), span_resource: T.unsafe(nil), span_service: T.unsafe(nil), span_type: T.unsafe(nil), trace_distributed_tags: T.unsafe(nil), trace_hostname: T.unsafe(nil), trace_id: T.unsafe(nil), trace_name: T.unsafe(nil), trace_origin: T.unsafe(nil), trace_process_id: T.unsafe(nil), trace_resource: T.unsafe(nil), trace_runtime_id: T.unsafe(nil), trace_sampling_priority: T.unsafe(nil), trace_service: T.unsafe(nil), trace_distributed_id: T.unsafe(nil), trace_flags: T.unsafe(nil), trace_state: T.unsafe(nil), trace_state_unknown_fields: T.unsafe(nil), span_remote: T.unsafe(nil), baggage: T.unsafe(nil)); end

  # TODO: The documentation for the last attribute above won't be rendered.
  # TODO: This might be a YARD bug as adding an attribute, making it now second-last attribute, renders correctly.
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def baggage; end

  # Creates a copy of this object, modifying the provided fields.
  #
  # @param field_value_pairs [Hash<String>] the fields to be overwritten
  # @return [TraceDigest] returns a copy of this object with the `field_value_pairs` modified
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#161
  def merge(field_value_pairs); end

  # Datadog id for the currently active span.
  #
  # @return [Integer]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def span_id; end

  # The operation name of the currently active span.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def span_name; end

  # Represents whether a TraceDigest was propagated from a remote parent or created locally.
  #
  # @return [Boolean]
  # @see https://opentelemetry.io/docs/specs/otel/trace/api/#isremote
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def span_remote; end

  # The resource name of the currently active span.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def span_resource; end

  # The service of the currently active span.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def span_service; end

  # The type of the currently active span.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def span_type; end

  # The trace id extracted from a distributed context, if different from `trace_id`.
  #
  # The current use case is when the distributed context has a trace id integer larger than 64-bit:
  # This attribute will preserve the original id, while `trace_id` will only contain the lower 64 bits.
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/trace-context/#trace-id
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_distributed_id; end

  # Datadog-specific tags that support richer distributed tracing association.
  #
  # @return [Hash<String,String>]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_distributed_tags; end

  # The W3C "trace-flags" extracted from a distributed context. This field is an 8-bit unsigned integer.
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/trace-context/#trace-flags
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_flags; end

  # The hostname of the currently active trace. Use to attribute traces to hosts.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_hostname; end

  # Datadog id for the currently active trace.
  #
  # @return [Integer]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_id; end

  # Operation name for the currently active trace.
  #
  # @return [Integer]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_name; end

  # Datadog-specific attribution of this trace's creation.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_origin; end

  # The OS-specific process id.
  #
  # @return [Integer]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_process_id; end

  # The resource name of the currently active trace.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_resource; end

  # Unique id to this Ruby process. Used to differentiate traces coming from
  # child processes forked from same parent process.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_runtime_id; end

  # Datadog-specific sampling decision for the currently active trace.
  #
  # @return [Integer]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_sampling_priority; end

  # The service of the currently active trace.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_service; end

  # The W3C "tracestate" extracted from a distributed context.
  # This field is a string representing vendor-specific distribution data.
  # The `dd=` entry is removed from `trace_state` as its value is dynamically calculated
  # on every propagation injection.
  #
  # @return [String]
  # @see https://www.w3.org/TR/trace-context/#tracestate-header
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_state; end

  # From W3C "tracestate"'s `dd=` entry, when keys are not recognized they are stored here long with their values.
  # This allows later propagation to include those unknown fields, as they can represent future versions of the spec
  # sending data through this service. This value ends in a trailing `;` to facilitate serialization.
  #
  # @return [String]
  #
  # source://datadog//lib/datadog/tracing/trace_digest.rb#88
  def trace_state_unknown_fields; end
end

# Represents the act of tracing a series of operations,
# by generating and collecting span measurements.
# When completed, it yields a trace.
#
# Supports synchronous code flow *only*. Usage across
# multiple threads will result in incorrect relationships.
# For async support, a {Datadog::Tracing::TraceOperation} should be employed
# per execution context (e.g. Thread, etc.)
#
# source://datadog//lib/datadog/tracing/trace_operation.rb#26
class Datadog::Tracing::TraceOperation
  include ::Datadog::Tracing::Metadata::Tagging

  # @return [TraceOperation] a new instance of TraceOperation
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#58
  def initialize(logger: T.unsafe(nil), agent_sample_rate: T.unsafe(nil), events: T.unsafe(nil), hostname: T.unsafe(nil), id: T.unsafe(nil), max_length: T.unsafe(nil), name: T.unsafe(nil), origin: T.unsafe(nil), parent_span_id: T.unsafe(nil), rate_limiter_rate: T.unsafe(nil), resource: T.unsafe(nil), rule_sample_rate: T.unsafe(nil), sample_rate: T.unsafe(nil), sampled: T.unsafe(nil), sampling_priority: T.unsafe(nil), service: T.unsafe(nil), profiling_enabled: T.unsafe(nil), apm_tracing_enabled: T.unsafe(nil), tags: T.unsafe(nil), metrics: T.unsafe(nil), trace_state: T.unsafe(nil), trace_state_unknown_fields: T.unsafe(nil), remote_parent: T.unsafe(nil), tracer: T.unsafe(nil), baggage: T.unsafe(nil)); end

  # Returns the value of attribute active_span.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#42
  def active_span; end

  # Returns the value of attribute active_span_count.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#42
  def active_span_count; end

  # Returns the value of attribute agent_sample_rate.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def agent_sample_rate; end

  # Sets the attribute agent_sample_rate
  #
  # @param value the value to set the attribute agent_sample_rate to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def agent_sample_rate=(_arg0); end

  # Returns the value of attribute baggage.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def baggage; end

  # Sets the attribute baggage
  #
  # @param value the value to set the attribute baggage to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def baggage=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#246
  def build_span(op_name, logger: T.unsafe(nil), events: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), id: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#132
  def finished?; end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#128
  def finished_span_count; end

  # Returns a {TraceSegment} with all finished spans that can be flushed
  # at invocation time. All other **finished** spans are discarded.
  #
  # @return [TraceSegment]
  # @yield [spans] spans that will be returned as part of the trace segment returned
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#308
  def flush!; end

  # Returns a copy of this trace suitable for forks (w/o spans.)
  # Used for continuation of traces across forks.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#369
  def fork_clone; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#124
  def full?; end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#178
  def get_metric(key); end

  # When retrieving tags or metrics we need to include root span tags for sampling purposes
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#174
  def get_tag(key); end

  # Returns the value of attribute hostname.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def hostname; end

  # Sets the attribute hostname
  #
  # @param value the value to set the attribute hostname to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def hostname=(_arg0); end

  # Returns the value of attribute id.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#42
  def id; end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#154
  def keep!; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#42
  def logger; end

  # Returns the value of attribute max_length.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#42
  def max_length; end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#207
  def measure(op_name, logger: T.unsafe(nil), events: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), id: T.unsafe(nil), &block); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#165
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#52
  def name=(_arg0); end

  # Returns the value of attribute origin.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def origin; end

  # Sets the attribute origin
  #
  # @param value the value to set the attribute origin to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def origin=(_arg0); end

  # Returns the value of attribute parent_span_id.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#42
  def parent_span_id; end

  # Has the priority sampling chosen to keep this span?
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#150
  def priority_sampled?; end

  # Returns the value of attribute rate_limiter_rate.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def rate_limiter_rate; end

  # Sets the attribute rate_limiter_rate
  #
  # @param value the value to set the attribute rate_limiter_rate to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def rate_limiter_rate=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#160
  def reject!; end

  # Returns the value of attribute remote_parent.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def remote_parent; end

  # Sets the attribute remote_parent
  #
  # @param value the value to set the attribute remote_parent to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def remote_parent=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#169
  def resource; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#52
  def resource=(_arg0); end

  # Returns true if the resource has been explicitly set
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#199
  def resource_override?; end

  # Returns the value of attribute rule_sample_rate.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def rule_sample_rate; end

  # Sets the attribute rule_sample_rate
  #
  # @param value the value to set the attribute rule_sample_rate to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def rule_sample_rate=(_arg0); end

  # Returns the value of attribute sample_rate.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def sample_rate; end

  # Sets the attribute sample_rate
  #
  # @param value the value to set the attribute sample_rate to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def sample_rate=(_arg0); end

  # Sets the attribute sampled
  #
  # @param value the value to set the attribute sampled to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#52
  def sampled=(_arg0); end

  # Will this trace be flushed by the tracer transport?
  # This includes cases where the span is kept solely due to priority sampling.
  #
  # This is not the ultimate Datadog App sampling decision. Downstream systems
  # can decide to reject this trace, especially for cases where priority
  # sampling is set to AUTO_KEEP.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#144
  def sampled?; end

  # Returns the value of attribute sampling_priority.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def sampling_priority; end

  # Sets the attribute sampling_priority
  #
  # @param value the value to set the attribute sampling_priority to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#31
  def sampling_priority=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#203
  def service; end

  # Sets the attribute service
  #
  # @param value the value to set the attribute service to.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#52
  def service=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#182
  def set_distributed_source(product_bit); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#188
  def tags; end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#356
  def to_correlation; end

  # Returns a set of trace headers used for continuing traces.
  # Used for propagation across execution contexts.
  # Data should reflect the active state of the trace.
  # DEV-3.0: Sampling is a side effect of generating the digest.
  # We should move the sample call to inject and right before moving to new contexts(threads, forking etc.)
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#326
  def to_digest; end

  # Returns the value of attribute trace_state.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#42
  def trace_state; end

  # Returns the value of attribute trace_state_unknown_fields.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#42
  def trace_state_unknown_fields; end

  private

  # source://datadog//lib/datadog/tracing/trace_operation.rb#456
  def activate_span!(span_op); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#515
  def build_trace(spans, partial = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#466
  def deactivate_span!(span_op); end

  # Returns tracer tags that will be propagated if this span's context
  # is exported through {.to_digest}.
  #
  # @return [Hash] key value pairs of distributed tags
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#543
  def distributed_tags; end

  # Returns the value of attribute events.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#452
  def events; end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#486
  def finish_span(span, span_op, parent); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#547
  def reset; end

  # Returns the value of attribute root_span.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#452
  def root_span; end

  # Track the root span
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#509
  def set_root_span!(span); end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#474
  def start_span(span_op); end
end

# source://datadog//lib/datadog/tracing/trace_operation.rb#29
Datadog::Tracing::TraceOperation::DEFAULT_MAX_LENGTH = T.let(T.unsafe(nil), Integer)

# Callback behavior
#
# source://datadog//lib/datadog/tracing/trace_operation.rb#395
class Datadog::Tracing::TraceOperation::Events
  include ::Datadog::Tracing::Events
  include ::Datadog::Tracing::Events::InstanceMethods
  extend ::Datadog::Tracing::Events::ClassMethods

  # @return [Events] a new instance of Events
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#404
  def initialize; end

  # Returns the value of attribute span_before_start.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#398
  def span_before_start; end

  # Returns the value of attribute span_finished.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#398
  def span_finished; end

  # Returns the value of attribute trace_finished.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#398
  def trace_finished; end

  # Returns the value of attribute trace_propagated.
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#398
  def trace_propagated; end
end

# Triggered before a span starts.
#
# source://datadog//lib/datadog/tracing/trace_operation.rb#412
class Datadog::Tracing::TraceOperation::Events::SpanBeforeStart < ::Datadog::Tracing::Event
  # @return [SpanBeforeStart] a new instance of SpanBeforeStart
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#413
  def initialize; end
end

# Triggered when a span finishes, regardless of error.
#
# source://datadog//lib/datadog/tracing/trace_operation.rb#419
class Datadog::Tracing::TraceOperation::Events::SpanFinished < ::Datadog::Tracing::Event
  # @return [SpanFinished] a new instance of SpanFinished
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#420
  def initialize; end
end

# Triggered when the trace finishes, regardless of error.
#
# source://datadog//lib/datadog/tracing/trace_operation.rb#433
class Datadog::Tracing::TraceOperation::Events::TraceFinished < ::Datadog::Tracing::Event
  # @return [TraceFinished] a new instance of TraceFinished
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#434
  def initialize; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#439
  def deactivate_trace_subscribed?; end

  # source://datadog//lib/datadog/tracing/trace_operation.rb#443
  def subscribe_deactivate_trace(&block); end
end

# Triggered when trace is being propagated between applications or contexts
#
# source://datadog//lib/datadog/tracing/trace_operation.rb#426
class Datadog::Tracing::TraceOperation::Events::TracePropagated < ::Datadog::Tracing::Event
  # @return [TracePropagated] a new instance of TracePropagated
  #
  # source://datadog//lib/datadog/tracing/trace_operation.rb#427
  def initialize; end
end

# Serializable construct representing a trace
#
# source://datadog//lib/datadog/tracing/trace_segment.rb#15
class Datadog::Tracing::TraceSegment
  # @param spans [Array<Datadog::Span>]
  # @return [TraceSegment] a new instance of TraceSegment
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#43
  def initialize(spans, agent_sample_rate: T.unsafe(nil), hostname: T.unsafe(nil), id: T.unsafe(nil), lang: T.unsafe(nil), name: T.unsafe(nil), origin: T.unsafe(nil), process_id: T.unsafe(nil), rate_limiter_rate: T.unsafe(nil), resource: T.unsafe(nil), root_span_id: T.unsafe(nil), rule_sample_rate: T.unsafe(nil), runtime_id: T.unsafe(nil), sample_rate: T.unsafe(nil), sampling_priority: T.unsafe(nil), service: T.unsafe(nil), tags: T.unsafe(nil), metrics: T.unsafe(nil), profiling_enabled: T.unsafe(nil), apm_tracing_enabled: T.unsafe(nil)); end

  # Returns the value of attribute agent_sample_rate.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def agent_sample_rate; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#95
  def any?; end

  # Returns the value of attribute apm_tracing_enabled.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def apm_tracing_enabled; end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#99
  def count; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#103
  def empty?; end

  # Returns the high order part of the trace id as a hexadecimal string; the most significant 64 bits.
  # The String returned is padded with zeros, having a fixed length of 16 characters.
  # If the high order part is zero, it returns nil.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#140
  def high_order_tid; end

  # Returns the value of attribute hostname.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def hostname; end

  # Returns the value of attribute id.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def id; end

  # If an active trace is present, forces it to be retained by the Datadog backend.
  #
  # Any sampling logic will not be able to change this decision.
  #
  # @return [void]
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#120
  def keep!; end

  # Returns the value of attribute lang.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def lang; end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#107
  def length; end

  # Returns the value of attribute name.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def name; end

  # Returns the value of attribute origin.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def origin; end

  # Returns the value of attribute process_id.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def process_id; end

  # Returns the value of attribute profiling_enabled.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def profiling_enabled; end

  # Returns the value of attribute rate_limiter_rate.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def rate_limiter_rate; end

  # If an active trace is present, forces it to be dropped and not stored by the Datadog backend.
  #
  # Any sampling logic will not be able to change this decision.
  #
  # @return [void]
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#129
  def reject!; end

  # Returns the value of attribute resource.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def resource; end

  # Returns the value of attribute rule_sample_rate.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def rule_sample_rate; end

  # Returns the value of attribute runtime_id.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def runtime_id; end

  # Returns the value of attribute sample_rate.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def sample_rate; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#133
  def sampled?; end

  # Returns the value of attribute sampling_decision_maker.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def sampling_decision_maker; end

  # Returns the value of attribute sampling_priority.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def sampling_priority; end

  # Returns the value of attribute service.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def service; end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#111
  def size; end

  # Returns the value of attribute spans.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#20
  def spans; end

  protected

  # Returns the value of attribute meta.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#148
  def meta; end

  # Returns the value of attribute metrics.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#148
  def metrics; end

  # Returns the value of attribute root_span_id.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#148
  def root_span_id; end

  private

  # Sets the attribute agent_sample_rate
  #
  # @param value the value to set the attribute agent_sample_rate to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def agent_sample_rate=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#170
  def agent_sample_rate_tag; end

  # Sets the attribute hostname
  #
  # @param value the value to set the attribute hostname to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def hostname=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#174
  def hostname_tag; end

  # Sets the attribute lang
  #
  # @param value the value to set the attribute lang to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def lang=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#178
  def lang_tag; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def name=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#182
  def name_tag; end

  # Sets the attribute origin
  #
  # @param value the value to set the attribute origin to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def origin=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#186
  def origin_tag; end

  # Sets the attribute process_id
  #
  # @param value the value to set the attribute process_id to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def process_id=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#190
  def process_id_tag; end

  # Sets the attribute rate_limiter_rate
  #
  # @param value the value to set the attribute rate_limiter_rate to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def rate_limiter_rate=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#194
  def rate_limiter_rate_tag; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def resource=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#198
  def resource_tag; end

  # Sets the attribute rule_sample_rate
  #
  # @param value the value to set the attribute rule_sample_rate to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def rule_sample_rate=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#202
  def rule_sample_rate_tag; end

  # Sets the attribute runtime_id
  #
  # @param value the value to set the attribute runtime_id to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def runtime_id=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#206
  def runtime_id_tag; end

  # Sets the attribute sample_rate
  #
  # @param value the value to set the attribute sample_rate to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def sample_rate=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#210
  def sample_rate_tag; end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#214
  def sampling_decision_maker_tag; end

  # Sets the attribute sampling_priority
  #
  # @param value the value to set the attribute sampling_priority to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def sampling_priority=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#218
  def sampling_priority_tag; end

  # Sets the attribute service
  #
  # @param value the value to set the attribute service to.
  #
  # source://datadog//lib/datadog/tracing/trace_segment.rb#155
  def service=(_arg0); end

  # source://datadog//lib/datadog/tracing/trace_segment.rb#222
  def service_tag; end
end

# source://datadog//lib/datadog/tracing/trace_segment.rb#16
Datadog::Tracing::TraceSegment::TAG_NAME = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/trace_segment.rb#17
Datadog::Tracing::TraceSegment::TAG_RESOURCE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/trace_segment.rb#18
Datadog::Tracing::TraceSegment::TAG_SERVICE = T.let(T.unsafe(nil), String)

# A {Datadog::Tracing::Tracer} keeps track of the time spent by an application processing a single operation. For
# example, a trace can be used to track the entire time spent processing a complicated web request.
# Even though the request may require multiple resources and machines to handle the request, all
# of these function calls and sub-requests would be encapsulated within a single trace.
#
# source://datadog//lib/datadog/tracing/tracer.rb#25
class Datadog::Tracing::Tracer
  # Initialize a new {Datadog::Tracing::Tracer} used to create, sample and submit spans that measure the
  # time of sections of code.
  #
  # @param context_provider [Datadog::Tracing::DefaultContextProvider] ensures different
  #   execution contexts have distinct traces
  # @param default_service [String] A fallback value for {Datadog::Tracing::Span#service}, as spans without
  #   service are rejected
  # @param enabled [Boolean] set if the tracer submits or not spans to the local agent
  # @param sampler [Datadog::Tracing::Sampler] a tracer sampler, responsible for filtering out spans when needed
  # @param tags [Hash] default tags added to all spans
  # @param trace_flush [Datadog::Tracing::TraceFlush] responsible for flushing spans from the execution context
  # @param writer [Datadog::Tracing::Writer] consumes traces returned by the provided +trace_flush+
  # @return [Tracer] a new instance of Tracer
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#51
  def initialize(writer:, trace_flush: T.unsafe(nil), context_provider: T.unsafe(nil), default_service: T.unsafe(nil), enabled: T.unsafe(nil), logger: T.unsafe(nil), sampler: T.unsafe(nil), span_sampler: T.unsafe(nil), tags: T.unsafe(nil)); end

  # Information about the currently active trace.
  #
  # The most common use cases are tagging log messages and metrics.
  #
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Datadog::Tracing::Correlation::Identifier] correlation object
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#236
  def active_correlation(key = T.unsafe(nil)); end

  # The active, unfinished span, representing the currently instrumented application section.
  #
  # The active span belongs to an {.active_trace}.
  #
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Datadog::Tracing::SpanOperation] the active span
  # @return [nil] if no trace is active, and thus no span is active
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#225
  def active_span(key = T.unsafe(nil)); end

  # The active, unfinished trace, representing the current instrumentation context.
  #
  # The active trace is fiber-local.
  #
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Datadog::Tracing::TraceSegment] the active trace
  # @return [nil] if no trace is active
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#214
  def active_trace(key = T.unsafe(nil)); end

  # Setup a new trace to continue from where another
  # trace left off.
  #
  # Used to continue distributed or async traces.
  #
  # @param digest [Datadog::Tracing::TraceDigest] continue from the {Datadog::Tracing::TraceDigest}.
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Object] If a block is provided, the result of the block execution.
  # @return [Datadog::Tracing::TraceOperation] If no block, the active {Datadog::Tracing::TraceOperation}.
  # @yield Optional block where this {#continue_trace!} `digest` scope is active.
  #   If no block, the `digest` remains active after {#continue_trace!} returns.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#255
  def continue_trace!(digest, key = T.unsafe(nil), &block); end

  # Returns the value of attribute default_service.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#34
  def default_service; end

  # Sets the attribute default_service
  #
  # @param value the value to set the attribute default_service to.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#34
  def default_service=(_arg0); end

  # Returns the value of attribute enabled.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#34
  def enabled; end

  # Sets the attribute enabled
  #
  # @param value the value to set the attribute enabled to.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#34
  def enabled=(_arg0); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#26
  def logger; end

  # Returns the value of attribute provider.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#26
  def provider; end

  # Sample a span, tagging the trace as appropriate.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#273
  def sample_trace(trace_op); end

  # Returns the value of attribute sampler.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#26
  def sampler; end

  # Set the given key / value tag pair at the tracer level. These tags will be
  # appended to each span created by the tracer. Keys and values must be strings.
  #
  # @example
  #   tracer.set_tags('env' => 'prod', 'component' => 'core')
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#202
  def set_tags(tags); end

  # Shorthand that calls the `shutdown!` method of a registered worker.
  # It's useful to ensure that the Trace Buffer is properly flushed before
  # shutting down the application.
  #
  # @example
  #   tracer.trace('operation_name', service='rake_tasks') do |span_op|
  #   span_op.set_tag('task.name', 'script')
  #   end
  #
  #   tracer.shutdown!
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#312
  def shutdown!; end

  # Returns the value of attribute span_sampler.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#26
  def span_sampler; end

  # Returns the value of attribute tags.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#26
  def tags; end

  # Return a {Datadog::Tracing::SpanOperation span_op} and {Datadog::Tracing::TraceOperation trace_op}
  # that will trace an operation called `name`.
  #
  # You could trace your code using a <tt>do-block</tt> like:
  #
  # ```
  # tracer.trace('web.request') do |span_op, trace_op|
  #   span_op.service = 'my-web-site'
  #   span_op.resource = '/'
  #   span_op.set_tag('http.method', request.request_method)
  #   do_something()
  # end
  # ```
  #
  # The {#trace} method can also be used without a block in this way:
  # ```
  # span_op = tracer.trace('web.request', service: 'my-web-site')
  # do_something()
  # span_op.finish()
  # ```
  #
  # Remember that in this case, calling {Datadog::Tracing::SpanOperation#finish} is mandatory.
  #
  # When a Trace is started, {#trace} will store the created span; subsequent spans will
  # become its children and will inherit some properties:
  # ```
  # parent = tracer.trace('parent')   # has no parent span
  # child  = tracer.trace('child')    # is a child of 'parent'
  # child.finish()
  # parent.finish()
  # parent2 = tracer.trace('parent2') # has no parent span
  # parent2.finish()
  # ```
  #
  #
  # @param continue_from [Datadog::Tracing::TraceDigest] continue a trace from a {Datadog::Tracing::TraceDigest}.
  #   Used for linking traces that are executed asynchronously.
  # @param name [String] {Datadog::Tracing::Span} operation name.
  #   See {https://docs.datadoghq.com/tracing/guide/configuring-primary-operation/ Primary Operations in Services}.
  # @param on_error [Proc] a block that overrides error handling behavior for this operation.
  # @param resource [String] the resource this span refers, or `name` if it's missing
  # @param service [String] the service name for this span.
  # @param start_time [Time] time which the span should have started.
  # @param tags [Hash<String,String>] extra tags which should be added to the span.
  # @param the [Integer] id of the new span.
  # @param type [String] the type of the span. See {Datadog::Tracing::Metadata::Ext::AppTypes}.
  # @return [Object] If a block is provided, returns the result of the block execution.
  # @return [Datadog::Tracing::SpanOperation] If no block is provided, returns the active,
  #   unfinished {Datadog::Tracing::SpanOperation}.
  # @yield Optional block where new newly created {Datadog::Tracing::SpanOperation} captures the execution.
  # @yieldparam span_op [Datadog::Tracing::SpanOperation] the newly created and active [Datadog::Tracing::SpanOperation]
  # @yieldparam trace_op [Datadog::Tracing::TraceOperation] the active [Datadog::Tracing::TraceOperation]
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#133
  def trace(name, continue_from: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), id: T.unsafe(nil), &block); end

  # TODO: make this private
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#283
  def trace_completed; end

  # Returns the value of attribute trace_flush.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#26
  def trace_flush; end

  # Returns the value of attribute writer.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#34
  def writer; end

  # Sets the attribute writer
  #
  # @param value the value to set the attribute writer to.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#34
  def writer=(_arg0); end

  private

  # Due to APM Tracing (the product) and Tracing (the transport) being intertwined, we cannot completely disabled APM
  # without also disabling the tracer. When setting `@apm_tracing_enabled` to `false`, it does not disable the tracer,
  # but rather only sends heartbeat traces (1 per minutes), so that the service is considered alive in the backend.
  # Other products (like ASM) can then set the sampling priority of their traces to `MANUAL_KEEP`,
  # effectively allowing standalone products to work without APM.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#591
  def apm_tracing_enabled; end

  # source://datadog//lib/datadog/tracing/tracer.rb#582
  def appsec_enabled; end

  # source://datadog//lib/datadog/tracing/tracer.rb#372
  def bind_trace_events!(trace_op); end

  # source://datadog//lib/datadog/tracing/tracer.rb#332
  def build_trace(digest = T.unsafe(nil)); end

  # Return the current active {Context} for this traced execution. This method is
  # automatically called when calling Tracer.trace or Tracer.start_span,
  # but it can be used in the application code during manual instrumentation.
  #
  # This method makes use of a {ContextProvider} that is automatically set during the tracer
  # initialization, or while using a library instrumentation.
  #
  # @param key [Thread] Thread to retrieve tracer from. Defaults to current thread.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#328
  def call_context(key = T.unsafe(nil)); end

  # Flush finished spans from the trace buffer, send them to writer.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#523
  def flush_trace(trace_op); end

  # Manually activate and deactivate the trace, when the span completes.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#477
  def manual_trace_activation!(context, trace); end

  # source://datadog//lib/datadog/tracing/tracer.rb#577
  def profiling_enabled; end

  # Decide whether upstream sampling priority should be propagated, by taking into account
  # the upstream tags and the configuration.
  # We should always propagate if APM is enabled.
  #
  # e.g.: upstream tags containing dd.p.ts: 02, and appsec is enabled, return true.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#565
  def propagate_sampling_priority?(upstream_tags:); end

  # source://datadog//lib/datadog/tracing/tracer.rb#460
  def resolve_tags(tags, service); end

  # source://datadog//lib/datadog/tracing/tracer.rb#511
  def sample_span(trace_op, span); end

  # TODO: Make these dummy objects singletons to preserve memory.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#549
  def skip_trace(name); end

  # source://datadog//lib/datadog/tracing/tracer.rb#406
  def start_span(name, continue_from: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), _trace: T.unsafe(nil), id: T.unsafe(nil), &block); end

  # Creates a new TraceOperation, with events bounds to this Tracer instance.
  #
  # @return [TraceOperation]
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#394
  def start_trace(continue_from: T.unsafe(nil)); end

  # Reactivate the original trace when trace completes
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#490
  def subscribe_trace_deactivation!(context, trace, original_trace); end

  # Send the trace to the writer to enqueue the spans list in the agent
  # sending queue.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#537
  def write(trace); end
end

# source://datadog//lib/datadog/tracing/tracer.rb#532
Datadog::Tracing::Tracer::FLUSH_TRACE_LOG_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://datadog//lib/datadog/tracing/tracer.rb#519
Datadog::Tracing::Tracer::SAMPLE_SPAN_LOG_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://datadog//lib/datadog/tracing/tracer.rb#508
Datadog::Tracing::Tracer::SAMPLE_TRACE_LOG_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# Triggered whenever a trace is completed
#
# source://datadog//lib/datadog/tracing/tracer.rb#288
class Datadog::Tracing::Tracer::TraceCompleted < ::Datadog::Tracing::Event
  # @return [TraceCompleted] a new instance of TraceCompleted
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#289
  def initialize; end

  # NOTE: Ignore Rubocop rule. This definition allows for
  #       description of and constraints on arguments.
  #
  # source://datadog//lib/datadog/tracing/tracer.rb#296
  def publish(trace); end
end

# source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#9
module Datadog::Tracing::Transport; end

# Namespace for HTTP transport components
#
# source://datadog//lib/datadog/tracing/transport/http/statistics.rb#8
module Datadog::Tracing::Transport::HTTP
  private

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # source://datadog//lib/datadog/tracing/transport/http.rb#19
  def default(agent_settings:, logger: T.unsafe(nil), api_version: T.unsafe(nil), headers: T.unsafe(nil)); end

  class << self
    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # source://datadog//lib/datadog/tracing/transport/http.rb#19
    def default(agent_settings:, logger: T.unsafe(nil), api_version: T.unsafe(nil), headers: T.unsafe(nil)); end
  end
end

# Namespace for API components
#
# source://datadog//lib/datadog/tracing/transport/http/api.rb#16
module Datadog::Tracing::Transport::HTTP::API
  private

  # source://datadog//lib/datadog/tracing/transport/http/api.rb#23
  def defaults; end

  class << self
    # source://datadog//lib/datadog/tracing/transport/http/api.rb#23
    def defaults; end
  end
end

# source://datadog//lib/datadog/tracing/transport/http/api.rb#19
Datadog::Tracing::Transport::HTTP::API::V3 = T.let(T.unsafe(nil), String)

# Default API versions
#
# source://datadog//lib/datadog/tracing/transport/http/api.rb#18
Datadog::Tracing::Transport::HTTP::API::V4 = T.let(T.unsafe(nil), String)

# Routes, encodes, and sends tracer data to the trace agent via HTTP.
#
# source://datadog//lib/datadog/tracing/transport/http/client.rb#12
class Datadog::Tracing::Transport::HTTP::Client
  include ::Datadog::Tracing::Transport::HTTP::Statistics
  include ::Datadog::Tracing::Transport::Statistics
  include ::Datadog::Tracing::Transport::HTTP::Statistics::InstanceMethods
  include ::Datadog::Tracing::Transport::HTTP::Traces::Client

  # @return [Client] a new instance of Client
  #
  # source://datadog//lib/datadog/tracing/transport/http/client.rb#17
  def initialize(api, logger: T.unsafe(nil)); end

  # Returns the value of attribute api.
  #
  # source://datadog//lib/datadog/tracing/transport/http/client.rb#15
  def api; end

  # source://datadog//lib/datadog/tracing/transport/http/client.rb#52
  def build_env(request); end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/tracing/transport/http/client.rb#15
  def logger; end

  # source://datadog//lib/datadog/tracing/transport/http/client.rb#22
  def send_request(request, &block); end
end

# Tracks statistics for HTTP transports
#
# source://datadog//lib/datadog/tracing/transport/http/statistics.rb#10
module Datadog::Tracing::Transport::HTTP::Statistics
  include ::Datadog::Tracing::Transport::Statistics
  include ::Datadog::Tracing::Transport::HTTP::Statistics::InstanceMethods

  class << self
    # @private
    #
    # source://datadog//lib/datadog/tracing/transport/http/statistics.rb#11
    def included(base); end
  end
end

# Instance methods for HTTP statistics
#
# source://datadog//lib/datadog/tracing/transport/http/statistics.rb#17
module Datadog::Tracing::Transport::HTTP::Statistics::InstanceMethods
  # Decorate metrics for HTTP responses
  #
  # source://datadog//lib/datadog/tracing/transport/http/statistics.rb#19
  def metrics_for_response(response); end

  private

  # source://datadog//lib/datadog/tracing/transport/http/statistics.rb#35
  def metrics_tag_value(status_code); end
end

# The most common status code on a healthy tracer
#
# source://datadog//lib/datadog/tracing/transport/http/statistics.rb#33
Datadog::Tracing::Transport::HTTP::Statistics::InstanceMethods::STATUS_CODE_200 = T.let(T.unsafe(nil), String)

# HTTP transport behavior for traces
#
# source://datadog//lib/datadog/tracing/transport/http/traces.rb#17
module Datadog::Tracing::Transport::HTTP::Traces; end

# source://datadog//lib/datadog/tracing/transport/http/traces.rb#39
module Datadog::Tracing::Transport::HTTP::Traces::API; end

# Endpoint for submitting trace data
#
# source://datadog//lib/datadog/tracing/transport/http/traces.rb#71
class Datadog::Tracing::Transport::HTTP::Traces::API::Endpoint < ::Datadog::Core::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#79
  def initialize(path, encoder, options = T.unsafe(nil)); end

  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#89
  def call(env, &block); end

  # Returns the value of attribute encoder.
  #
  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#76
  def encoder; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#85
  def service_rates?; end
end

# source://datadog//lib/datadog/tracing/transport/http/traces.rb#72
Datadog::Tracing::Transport::HTTP::Traces::API::Endpoint::HEADER_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/transport/http/traces.rb#73
Datadog::Tracing::Transport::HTTP::Traces::API::Endpoint::HEADER_TRACE_COUNT = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/tracing/transport/http/traces.rb#74
Datadog::Tracing::Transport::HTTP::Traces::API::Endpoint::SERVICE_RATE_KEY = T.let(T.unsafe(nil), String)

# HTTP API Instance
#
# source://datadog//lib/datadog/tracing/transport/http/traces.rb#56
class Datadog::Tracing::Transport::HTTP::Traces::API::Instance < ::Datadog::Core::Transport::HTTP::API::Instance
  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#57
  def send_traces(env); end
end

# HTTP API Spec
#
# source://datadog//lib/datadog/tracing/transport/http/traces.rb#41
class Datadog::Tracing::Transport::HTTP::Traces::API::Spec < ::Datadog::Core::Transport::HTTP::API::Spec
  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#50
  def encoder; end

  # @raise [Core::Transport::HTTP::API::Spec::EndpointNotDefinedError]
  #
  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#44
  def send_traces(env, &block); end

  # Returns the value of attribute traces.
  #
  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#42
  def traces; end

  # Sets the attribute traces
  #
  # @param value the value to set the attribute traces to.
  #
  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#42
  def traces=(_arg0); end
end

# Extensions for HTTP client
#
# source://datadog//lib/datadog/tracing/transport/http/traces.rb#31
module Datadog::Tracing::Transport::HTTP::Traces::Client
  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#32
  def send_traces_payload(request); end
end

# Response from HTTP transport for traces
#
# source://datadog//lib/datadog/tracing/transport/http/traces.rb#19
class Datadog::Tracing::Transport::HTTP::Traces::Response
  include ::Datadog::Core::Transport::HTTP::Response
  include ::Datadog::Tracing::Transport::Traces::Response

  # @return [Response] a new instance of Response
  #
  # source://datadog//lib/datadog/tracing/transport/http/traces.rb#23
  def initialize(http_response, options = T.unsafe(nil)); end
end

# Adds serialization functions to a {Datadog::Span}
#
# source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#47
class Datadog::Tracing::Transport::SerializableSpan
  # @param native_events_supported [Boolean] whether the agent supports span events as a top-level field
  # @param span [Datadog::Span] the span to serialize
  # @return [SerializableSpan] a new instance of SerializableSpan
  #
  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#53
  def initialize(span, native_events_supported:); end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#149
  def duration_nano(duration); end

  # Returns the value of attribute span.
  #
  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#48
  def span; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#139
  def time_nano(time); end

  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#143
  def to_hash; end

  # JSON serializer interface.
  # Used by older version of the transport.
  #
  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#133
  def to_json(*args); end

  # MessagePack serializer interface. Making this object
  # respond to `#to_msgpack` allows it to be automatically
  # serialized by MessagePack.
  #
  # This is more efficient than doing +MessagePack.pack(span.to_hash)+
  # as we don't have to create an intermediate Hash.
  #
  #
  # @param packer [MessagePack::Packer] serialization buffer, can be +nil+ with JRuby
  #
  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#69
  def to_msgpack(packer = T.unsafe(nil)); end
end

# Adds serialization functions to a {Datadog::TraceSegment}
#
# source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#11
class Datadog::Tracing::Transport::SerializableTrace
  # @param native_events_supported [Boolean] whether the agent supports span events as a top-level field
  # @param trace [Datadog::Trace] the trace to serialize
  # @return [SerializableTrace] a new instance of SerializableTrace
  #
  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#17
  def initialize(trace, native_events_supported:); end

  # JSON serializer interface.
  # Used by older version of the transport.
  #
  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#39
  def to_json(*args); end

  # MessagePack serializer interface. Making this object
  # respond to `#to_msgpack` allows it to be automatically
  # serialized by MessagePack.
  #
  # This is more efficient than doing +MessagePack.pack(span.to_hash)+
  # as we don't have to create an intermediate Hash.
  #
  # @param packer [MessagePack::Packer] serialization buffer, can be +nil+ with JRuby
  #
  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#30
  def to_msgpack(packer = T.unsafe(nil)); end

  # Returns the value of attribute trace.
  #
  # source://datadog//lib/datadog/tracing/transport/serializable_trace.rb#12
  def trace; end
end

# Tracks statistics for transports
#
# source://datadog//lib/datadog/tracing/transport/statistics.rb#10
module Datadog::Tracing::Transport::Statistics
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#49
  def metrics_for_exception(_exception); end

  # source://datadog//lib/datadog/tracing/transport/statistics.rb#32
  def metrics_for_response(response); end

  # source://datadog//lib/datadog/tracing/transport/statistics.rb#11
  def stats; end

  # source://datadog//lib/datadog/tracing/transport/statistics.rb#39
  def update_stats_from_exception!(exception); end

  # source://datadog//lib/datadog/tracing/transport/statistics.rb#15
  def update_stats_from_response!(response); end
end

# Stat counts
#
# source://datadog//lib/datadog/tracing/transport/statistics.rb#54
class Datadog::Tracing::Transport::Statistics::Counts
  # @return [Counts] a new instance of Counts
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#62
  def initialize; end

  # Returns the value of attribute client_error.
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#55
  def client_error; end

  # Sets the attribute client_error
  #
  # @param value the value to set the attribute client_error to.
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#55
  def client_error=(_arg0); end

  # Returns the value of attribute consecutive_errors.
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#55
  def consecutive_errors; end

  # Sets the attribute consecutive_errors
  #
  # @param value the value to set the attribute consecutive_errors to.
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#55
  def consecutive_errors=(_arg0); end

  # Returns the value of attribute internal_error.
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#55
  def internal_error; end

  # Sets the attribute internal_error
  #
  # @param value the value to set the attribute internal_error to.
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#55
  def internal_error=(_arg0); end

  # source://datadog//lib/datadog/tracing/transport/statistics.rb#66
  def reset!; end

  # Returns the value of attribute server_error.
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#55
  def server_error; end

  # Sets the attribute server_error
  #
  # @param value the value to set the attribute server_error to.
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#55
  def server_error=(_arg0); end

  # Returns the value of attribute success.
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#55
  def success; end

  # Sets the attribute success
  #
  # @param value the value to set the attribute success to.
  #
  # source://datadog//lib/datadog/tracing/transport/statistics.rb#55
  def success=(_arg0); end
end

# Prepares traces for transport
#
# source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#15
class Datadog::Tracing::Transport::TraceFormatter
  # @return [TraceFormatter] a new instance of TraceFormatter
  #
  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#25
  def initialize(trace); end

  # Returns the value of attribute first_span.
  #
  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#16
  def first_span; end

  # Modifies a trace so suitable for transport
  #
  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#34
  def format!; end

  # Returns the value of attribute root_span.
  #
  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#16
  def root_span; end

  # Returns the value of attribute trace.
  #
  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#16
  def trace; end

  protected

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#74
  def set_resource!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#83
  def set_trace_tags!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#93
  def tag_agent_sample_rate!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#200
  def tag_apm_tracing_disabled!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#212
  def tag_git_commit_sha!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#206
  def tag_git_repository_url!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#186
  def tag_high_order_trace_id!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#102
  def tag_hostname!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#111
  def tag_lang!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#120
  def tag_origin!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#129
  def tag_process_id!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#192
  def tag_profiling_enabled!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#135
  def tag_rate_limiter_rate!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#144
  def tag_rule_sample_rate!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#153
  def tag_runtime_id!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#162
  def tag_sample_rate!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#171
  def tag_sampling_decision_maker!; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#177
  def tag_sampling_priority!; end

  private

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#224
  def find_root_span(trace); end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#241
  def git_commit_sha; end

  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#237
  def git_repository_url; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#220
  def partial?; end

  class << self
    # source://datadog//lib/datadog/tracing/transport/trace_formatter.rb#21
    def format!(trace); end
  end
end

# source://datadog//lib/datadog/tracing/transport/traces.rb#12
module Datadog::Tracing::Transport::Traces; end

# Traces chunker
#
# source://datadog//lib/datadog/tracing/transport/traces.rb#39
class Datadog::Tracing::Transport::Traces::Chunker
  # Single traces larger than +max_size+ will be discarded.
  #
  # @param encoder [Datadog::Core::Encoding::Encoder]
  # @param logger [Datadog::Core::Logger]
  # @param max_size [String] maximum acceptable payload size
  # @return [Chunker] a new instance of Chunker
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#54
  def initialize(encoder, logger:, native_events_supported:, max_size: T.unsafe(nil)); end

  # Encodes a list of traces in chunks.
  # Before serializing, all traces are normalized. Trace nesting is not changed.
  #
  # @param traces [Enumerable<Trace>] list of traces
  # @return [Enumerable[Array[Bytes,Integer]]] list of encoded chunks: each containing a byte array and
  #   number of traces
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#67
  def encode_in_chunks(traces); end

  # Returns the value of attribute encoder.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#46
  def encoder; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#46
  def logger; end

  # Returns the value of attribute max_size.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#46
  def max_size; end

  private

  # source://datadog//lib/datadog/tracing/transport/traces.rb#82
  def encode_one(trace); end
end

# Trace agent limit payload size of 10 MiB (since agent v5.11.0):
# https://github.com/DataDog/datadog-agent/blob/6.14.1/pkg/trace/api/api.go#L46
#
# We set the value to a conservative 5 MiB, in case network speed is slow.
#
# source://datadog//lib/datadog/tracing/transport/traces.rb#44
Datadog::Tracing::Transport::Traces::Chunker::DEFAULT_MAX_PAYLOAD_SIZE = T.let(T.unsafe(nil), Integer)

# Data transfer object for encoded traces
#
# source://datadog//lib/datadog/tracing/transport/traces.rb#14
class Datadog::Tracing::Transport::Traces::EncodedParcel
  include ::Datadog::Core::Transport::Parcel

  # @return [EncodedParcel] a new instance of EncodedParcel
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#19
  def initialize(data, trace_count); end

  # source://datadog//lib/datadog/tracing/transport/traces.rb#24
  def count; end

  # Returns the value of attribute trace_count.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#17
  def trace_count; end
end

# Encodes traces using {Datadog::Core::Encoding::Encoder} instances.
#
# source://datadog//lib/datadog/tracing/transport/traces.rb#103
module Datadog::Tracing::Transport::Traces::Encoder
  private

  # source://datadog//lib/datadog/tracing/transport/traces.rb#106
  def encode_trace(encoder, trace, logger:, native_events_supported:); end

  class << self
    # source://datadog//lib/datadog/tracing/transport/traces.rb#106
    def encode_trace(encoder, trace, logger:, native_events_supported:); end
  end
end

# Traces request
#
# source://datadog//lib/datadog/tracing/transport/traces.rb#30
class Datadog::Tracing::Transport::Traces::Request < ::Datadog::Core::Transport::Request; end

# Traces response
#
# source://datadog//lib/datadog/tracing/transport/traces.rb#34
module Datadog::Tracing::Transport::Traces::Response
  # Returns the value of attribute service_rates.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#35
  def service_rates; end

  # Returns the value of attribute trace_count.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#35
  def trace_count; end
end

# Sends traces based on transport API configuration.
#
# This class initializes the HTTP client, breaks down large
# batches of traces into smaller chunks and handles
# API version downgrade handshake.
#
# source://datadog//lib/datadog/tracing/transport/traces.rb#126
class Datadog::Tracing::Transport::Traces::Transport
  # @return [Transport] a new instance of Transport
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#129
  def initialize(apis, default_api, logger: T.unsafe(nil)); end

  # Returns the value of attribute apis.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#127
  def apis; end

  # Returns the value of attribute client.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#127
  def client; end

  # source://datadog//lib/datadog/tracing/transport/traces.rb#179
  def current_api; end

  # Returns the value of attribute current_api_id.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#127
  def current_api_id; end

  # Returns the value of attribute default_api.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#127
  def default_api; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#127
  def logger; end

  # source://datadog//lib/datadog/tracing/transport/traces.rb#137
  def send_traces(traces); end

  # source://datadog//lib/datadog/tracing/transport/traces.rb#175
  def stats; end

  private

  # @raise [UnknownApiVersionError]
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#198
  def change_api!(api_id); end

  # @raise [NoDowngradeAvailableError]
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#191
  def downgrade!; end

  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#185
  def downgrade?(response); end

  # Queries the agent for native span events serialization support.
  # This changes how the serialization of span events performed.
  #
  # @return [Boolean]
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#207
  def native_events_supported?; end
end

# Raised when configured with an unknown API version
#
# source://datadog//lib/datadog/tracing/transport/traces.rb#241
class Datadog::Tracing::Transport::Traces::Transport::NoDowngradeAvailableError < ::StandardError
  # @return [NoDowngradeAvailableError] a new instance of NoDowngradeAvailableError
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#244
  def initialize(version); end

  # source://datadog//lib/datadog/tracing/transport/traces.rb#250
  def message; end

  # Returns the value of attribute version.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#242
  def version; end
end

# Raised when configured with an unknown API version
#
# source://datadog//lib/datadog/tracing/transport/traces.rb#226
class Datadog::Tracing::Transport::Traces::Transport::UnknownApiVersionError < ::StandardError
  # @return [UnknownApiVersionError] a new instance of UnknownApiVersionError
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#229
  def initialize(version); end

  # source://datadog//lib/datadog/tracing/transport/traces.rb#235
  def message; end

  # Returns the value of attribute version.
  #
  # source://datadog//lib/datadog/tracing/transport/traces.rb#227
  def version; end
end

# Utils contains low-level tracing utility functions.
#
# source://datadog//lib/datadog/tracing/utils.rb#10
module Datadog::Tracing::Utils
  extend ::Datadog::Core::Utils::Forking

  class << self
    # Return a randomly generated integer, valid as a Span ID or Trace ID.
    # This method is thread-safe and fork-safe.
    #
    # source://datadog//lib/datadog/tracing/utils.rb#35
    def next_id; end

    # Serialize values into Datadog span tags and metrics.
    # Notably, arrays are exploded into many keys, each with
    # a numeric suffix representing the array index, for example:
    # `'foo' => ['a','b']` becomes `'foo.0' => 'a', 'foo.1' => 'b'`
    #
    # source://datadog//lib/datadog/tracing/utils.rb#52
    def serialize_attribute(key, value); end

    private

    # source://datadog//lib/datadog/tracing/utils.rb#40
    def id_rng; end

    # source://datadog//lib/datadog/tracing/utils.rb#44
    def reset!; end
  end
end

# While we only generate 63-bit integers due to limitations in other languages, we support
# parsing 64-bit integers for distributed tracing since an upstream system may generate one
#
# source://datadog//lib/datadog/tracing/utils.rb#27
Datadog::Tracing::Utils::EXTERNAL_MAX_ID = T.let(T.unsafe(nil), Integer)

# Excludes zero from possible values
#
# source://datadog//lib/datadog/tracing/utils.rb#23
Datadog::Tracing::Utils::RUBY_ID_RANGE = T.let(T.unsafe(nil), Range)

# The max value for a {Datadog::Tracing::Span} identifier.
# Span and trace identifiers should be strictly positive and strictly inferior to this limit.
#
# Limited to +2<<62-1+ positive integers, as Ruby is able to represent such numbers "inline",
# inside a +VALUE+ scalar, thus not requiring memory allocation.
#
# The range of IDs also has to consider portability across different languages and platforms.
#
# source://datadog//lib/datadog/tracing/utils.rb#20
Datadog::Tracing::Utils::RUBY_MAX_ID = T.let(T.unsafe(nil), Integer)

# The module handles bitwise operation for trace id
#
# source://datadog//lib/datadog/tracing/utils.rb#67
module Datadog::Tracing::Utils::TraceId
  private

  # source://datadog//lib/datadog/tracing/utils.rb#93
  def concatenate(high_order, low_order); end

  # Format for generating 128 bits trace id =>
  # - 32-bits : seconds since Epoch
  # - 32-bits : set to zero,
  # - 64 bits : random 64-bits
  #
  # source://datadog//lib/datadog/tracing/utils.rb#76
  def next_id; end

  # source://datadog//lib/datadog/tracing/utils.rb#85
  def to_high_order(trace_id); end

  # source://datadog//lib/datadog/tracing/utils.rb#89
  def to_low_order(trace_id); end

  class << self
    # source://datadog//lib/datadog/tracing/utils.rb#93
    def concatenate(high_order, low_order); end

    # Format for generating 128 bits trace id =>
    # - 32-bits : seconds since Epoch
    # - 32-bits : set to zero,
    # - 64 bits : random 64-bits
    #
    # source://datadog//lib/datadog/tracing/utils.rb#76
    def next_id; end

    # source://datadog//lib/datadog/tracing/utils.rb#85
    def to_high_order(trace_id); end

    # source://datadog//lib/datadog/tracing/utils.rb#89
    def to_low_order(trace_id); end
  end
end

# source://datadog//lib/datadog/tracing/utils.rb#68
Datadog::Tracing::Utils::TraceId::MAX = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/workers.rb#8
module Datadog::Tracing::Workers; end

# Asynchronous worker that executes a +Send()+ operation after given
# seconds. Under the hood, it uses +Concurrent::TimerTask+ so that the thread
# will perform a task at regular intervals. The thread can be stopped
# with the +stop()+ method and can start with the +start()+ method.
#
# source://datadog//lib/datadog/tracing/workers.rb#13
class Datadog::Tracing::Workers::AsyncTransport
  # @return [AsyncTransport] a new instance of AsyncTransport
  #
  # source://datadog//lib/datadog/tracing/workers.rb#23
  def initialize(options = T.unsafe(nil)); end

  # Callback function that process traces and executes the +send_traces()+ method.
  #
  # source://datadog//lib/datadog/tracing/workers.rb#49
  def callback_traces; end

  # Enqueue an item in the trace internal buffer. This operation is thread-safe
  # because uses the +TraceBuffer+ data structure.
  #
  # source://datadog//lib/datadog/tracing/workers.rb#102
  def enqueue_trace(trace); end

  # Callback function that process traces and executes the +send_traces()+ method.
  #
  # source://datadog//lib/datadog/tracing/workers.rb#110
  def flush_data; end

  # Block until executor shutdown is complete or until timeout seconds have passed.
  #
  # source://datadog//lib/datadog/tracing/workers.rb#96
  def join; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/tracing/workers.rb#21
  def logger; end

  # Start the timer execution.
  #
  # source://datadog//lib/datadog/tracing/workers.rb#67
  def start; end

  # Closes all available queues and waits for the trace buffer to flush
  #
  # source://datadog//lib/datadog/tracing/workers.rb#82
  def stop; end

  # Returns the value of attribute trace_buffer.
  #
  # source://datadog//lib/datadog/tracing/workers.rb#21
  def trace_buffer; end

  private

  # source://datadog//lib/datadog/tracing/workers.rb#112
  def perform; end
end

# source://datadog//lib/datadog/tracing/workers.rb#18
Datadog::Tracing::Workers::AsyncTransport::BACK_OFF_MAX = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/workers.rb#17
Datadog::Tracing::Workers::AsyncTransport::BACK_OFF_RATIO = T.let(T.unsafe(nil), Float)

# source://datadog//lib/datadog/tracing/workers.rb#14
Datadog::Tracing::Workers::AsyncTransport::DEFAULT_BUFFER_MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/workers.rb#15
Datadog::Tracing::Workers::AsyncTransport::DEFAULT_FLUSH_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/workers.rb#19
Datadog::Tracing::Workers::AsyncTransport::DEFAULT_SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/tracing/workers.rb#16
Datadog::Tracing::Workers::AsyncTransport::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Processor that sends traces and metadata to the agent
# DEV: Our goal is for {Datadog::Tracing::Workers::TraceWriter} to replace this class in the future
#
# source://datadog//lib/datadog/tracing/writer.rb#14
class Datadog::Tracing::Writer
  # @return [Writer] a new instance of Writer
  #
  # source://datadog//lib/datadog/tracing/writer.rb#22
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute agent_settings.
  #
  # source://datadog//lib/datadog/tracing/writer.rb#15
  def agent_settings; end

  # Returns the value of attribute events.
  #
  # source://datadog//lib/datadog/tracing/writer.rb#15
  def events; end

  # Returns the value of attribute logger.
  #
  # source://datadog//lib/datadog/tracing/writer.rb#15
  def logger; end

  # flush spans to the trace-agent, handles spans only
  #
  # source://datadog//lib/datadog/tracing/writer.rb#86
  def send_spans(traces, transport); end

  # Explicitly starts the {Writer}'s internal worker.
  #
  # The {Writer} is also automatically started when necessary during calls to {.write}.
  #
  # source://datadog//lib/datadog/tracing/writer.rb#60
  def start; end

  # stats returns a dictionary of stats about the writer.
  #
  # source://datadog//lib/datadog/tracing/writer.rb#130
  def stats; end

  # Gracefully shuts down this writer.
  #
  # Once stopped methods calls won't fail, but
  # no internal work will be performed.
  #
  # It is not possible to restart a stopped writer instance.
  #
  # source://datadog//lib/datadog/tracing/writer.rb#80
  def stop; end

  # Returns the value of attribute transport.
  #
  # source://datadog//lib/datadog/tracing/writer.rb#15
  def transport; end

  # Returns the value of attribute worker.
  #
  # source://datadog//lib/datadog/tracing/writer.rb#15
  def worker; end

  # enqueue the trace for submission to the API
  #
  # source://datadog//lib/datadog/tracing/writer.rb#104
  def write(trace); end

  private

  # source://datadog//lib/datadog/tracing/writer.rb#184
  def reset_stats!; end

  # spawns a worker for spans; they share the same transport which is thread-safe
  #
  # source://datadog//lib/datadog/tracing/writer.rb#159
  def start_worker; end

  # source://datadog//lib/datadog/tracing/writer.rb#173
  def stop_worker; end
end

# Callback behavior
#
# source://datadog//lib/datadog/tracing/writer.rb#138
class Datadog::Tracing::Writer::Events
  # @return [Events] a new instance of Events
  #
  # source://datadog//lib/datadog/tracing/writer.rb#142
  def initialize; end

  # Returns the value of attribute after_send.
  #
  # source://datadog//lib/datadog/tracing/writer.rb#139
  def after_send; end
end

# Triggered after the writer sends traces through the transport.
# Provides the Writer instance and transport response list to the callback.
#
# source://datadog//lib/datadog/tracing/writer.rb#148
class Datadog::Tracing::Writer::Events::AfterSend < ::Datadog::Tracing::Event
  # @return [AfterSend] a new instance of AfterSend
  #
  # source://datadog//lib/datadog/tracing/writer.rb#149
  def initialize; end
end

# source://datadog//lib/datadog/version.rb#4
module Datadog::VERSION; end

# source://datadog//lib/datadog/version.rb#9
Datadog::VERSION::BUILD = T.let(T.unsafe(nil), T.untyped)

# source://datadog//lib/datadog/version.rb#5
Datadog::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# Restrict the installation of this gem with untested future versions of Ruby.
#
# This prevents crashes in the native extension code and sends a clear signal to the
# user that this version of the gem is untested for the host Ruby version.
#
# To allow testing with the next unreleased version of Ruby, the version check is performed
# as `< #{MAXIMUM_RUBY_VERSION}`, meaning prereleases of MAXIMUM_RUBY_VERSION are allowed
# but not stable MAXIMUM_RUBY_VERSION releases.
#
# source://datadog//lib/datadog/version.rb#24
Datadog::VERSION::MAXIMUM_RUBY_VERSION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/version.rb#14
Datadog::VERSION::MINIMUM_RUBY_VERSION = T.let(T.unsafe(nil), String)

# source://datadog//lib/datadog/version.rb#6
Datadog::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/version.rb#7
Datadog::VERSION::PATCH = T.let(T.unsafe(nil), Integer)

# source://datadog//lib/datadog/version.rb#8
Datadog::VERSION::PRE = T.let(T.unsafe(nil), T.untyped)

# PRE and BUILD above are modified for dev gems during gem build GHA workflow
#
# source://datadog//lib/datadog/version.rb#12
Datadog::VERSION::STRING = T.let(T.unsafe(nil), String)

# Railtie to include AutoInstrumentation in rails loading
#
# source://datadog//lib/datadog/tracing/contrib/rails/auto_instrument_railtie.rb#4
class DatadogAutoInstrumentRailtie < ::Rails::Railtie; end

module Process
  extend ::Datadog::Core::Utils::AtForkMonkeyPatch::ProcessMonkeyPatch
  extend ::ActiveSupport::ForkTracker::CoreExt
  extend ::FFI::ModernForkTracking
end
